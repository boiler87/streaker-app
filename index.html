<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Streaker</title>
    <!-- FAVICON LINK -->
    <link rel="icon" type="image/png" href="https://raw.githubusercontent.com/rynwynk/streaker-app/main/logo%20only.png">
    <!-- GOOGLE FONTS LINK -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
        }
        @font-face {
            font-family: 'AppleIIe';
            src: url('https://daniellopes.com.br/apple-ii/AppleIIe.ttf') format('truetype');
        }

        body {
            font-family: 'AppleIIe', monospace;
            background-color: #000;
            color: #27ff47;
            margin: 0;
            padding: 0;
        }
        
        /* --- Main App Layout --- */
        .app-layout {
            display: flex;
            width: 100%;
            height: 100vh;
        }

        .main-content {
            flex-grow: 1;
            padding: 20px;
            overflow-y: auto;
            margin-left: 65px; /* Space for the sidebar */
        }
        /* --- END: Main App Layout --- */

        .container {
            background-color: #000;
            padding: 30px;
            border: 2px solid #27ff47;
            box-shadow: 0 0 10px #27ff47;
            width: 100%;
            max-width: 900px;
            margin: 0 auto; /* Center the container */
        }
        .hidden {
            display: none !important; /* The definitive fix */
        }
        
        .logo-and-title {
            display: flex;
            align-items: center;
            gap: 15px; /* Increased gap */
        }
        .logo-and-title div {
           display: flex;
           flex-direction: column;
        }
        .logo-and-title h2 {
            font-family: 'Press Start 2P', cursive;
            margin-bottom: 5px; /* Space between title and subtitle */
        }
        .subtitle {
            font-size: 0.8em;
            color: #27ff47;
            margin: 0;
        }

        h2, h3, h4 {
            color: #27ff47;
            text-align: left;
            margin: 0;
            font-size: 2em;
        }
        h3 { font-size: 1.5em; margin-top: 25px; margin-bottom: 10px; }
        h4 { font-size: 1.2em; margin-top: 20px; margin-bottom: 10px; }
        #about-container ul { padding-left: 20px; }
        #about-container li { margin-bottom: 10px; }


        .logo {
            height: 60px; /* Adjusted height */
            width: auto;
            image-rendering: pixelated;
        }
        .header-container {
            margin-bottom: 20px;
        }
        form {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        input[type="email"],
        input[type="password"],
        input[type="date"],
        input[type="datetime-local"],
        input[type="number"],
        input[type="search"],
        input[type="text"] {
            padding: 12px;
            border: 2px solid #27ff47;
            background-color: #000;
            color: #27ff47;
            flex-grow: 1;
            font-size: 16px;
            font-family: 'AppleIIe', monospace;
        }
        textarea {
            padding: 12px;
            border: 2px solid #27ff47;
            background-color: #000;
            color: #27ff47;
            flex-basis: 100%;
            min-height: 80px;
            resize: vertical;
            font-family: 'AppleIIe', monospace;
            font-size: 16px;
        }
        button {
            padding: 12px 20px;
            border: 2px solid #27ff47;
            background-color: #27ff47;
            color: #000;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        button:hover {
            background-color: #1aff32;
        }
        button:disabled {
            background-color: #111;
            color: #444;
            border-color: #444;
            cursor: not-allowed;
        }
        .button-group {
            display: flex;
            gap: 10px;
        }

        /* --- START LOGIN PAGE REDESIGN --- */
        #auth-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%; /* Make auth container full width */
            padding: 20px;
        }

        #auth-container .logo-and-title {
            justify-content: center;
            margin-bottom: 40px;
        }
        
        .terminal-window {
            width: 100%;
            max-width: 450px;
            border: 2px solid #27ff47;
            background-color: #080808;
            padding: 0;
            box-shadow: 0 0 15px rgba(39, 255, 71, 0.5);
        }

        .terminal-header {
            background-color: #27ff47;
            color: #000;
            padding: 5px 10px;
            font-weight: bold;
            text-align: center;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8em;
        }
        
        #auth-form {
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: flex-start;
        }
        
        #auth-form .form-row {
             width: 100%;
        }

        #auth-form label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        
        #auth-form input {
            width: 100%;
        }
        
        #auth-form .button-group {
            width: 100%;
            justify-content: space-between;
        }

        #auth-form .button-group button {
            flex-grow: 1;
            flex-basis: 0;
        }
        
        .blinking-cursor {
            font-weight: bold;
            animation: blink 1s step-end infinite;
        }

        @keyframes blink {
            from, to { color: transparent; }
            50% { color: #27ff47; }
        }
        /* --- END LOGIN PAGE REDESIGN --- */


        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .error-message {
            color: #ff0000;
            text-align: center;
            margin-top: 10px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            border: 2px solid #27ff47;
            margin-top: 20px;
        }
        th, td {
            padding: 15px;
            text-align: left;
            border: 1px solid #27ff47;
        }
        th {
            background-color: #111;
            color: #27ff47;
            font-weight: 600;
            cursor: pointer;
        }
        th:hover {
            background-color: #333;
        }
        th .sort-icon {
            margin-left: 5px;
            font-size: 0.8em;
        }
        tr:hover {
            background-color: #001;
        }
        .delete-btn {
            background-color: #ff0000;
            color: #000;
        }
        .delete-btn:hover {
            background-color: #cc0000;
        }
        
        .edit-btn {
            background-color: #27ff47;
            color: #000;
            font-size: 14px;
            padding: 8px 12px;
            margin-right: 5px;
        }
        .edit-btn:hover {
            background-color: #1aff32;
        }

        .save-btn {
            background-color: #27ff47;
            color: #000;
        }
        .save-btn:hover {
            background-color: #1aff32;
        }
        .cancel-btn {
            background-color: #ff0000;
            color: #000;
        }
        .cancel-btn:hover {
            background-color: #cc0000;
        }

        .end-streak-btn {
            background-color: #27ff47;
            color: #000;
            font-size: 14px;
            padding: 8px 12px;
        }
        .end-streak-btn:hover {
            background-color: #1aff32;
        }

        #user-profile-display {
            word-break: break-all;
            text-align: center;
            font-weight: bold;
            font-size: 1.2em;
        }

        .username-change-section {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            align-items: center;
        }
        #new-username-input {
            flex-grow: 1;
            font-size: 0.9em;
            padding: 8px;
        }
        #save-username-btn {
            padding: 8px 12px;
            font-size: 0.9em;
        }
        #username-status {
            flex-basis: 100%;
            text-align: left;
            margin: 5px 0 0 0;
            font-size: 0.8em;
        }

        #refresh-public-data-btn, .logout-btn {
            width: 100%;
        }
        
        .toggle-switch {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 10px;
        }
        .toggle-switch label {
            cursor: pointer;
            white-space: nowrap;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            width: 40px;
            height: 20px;
            background-color: #333;
            border: 1px solid #27ff47;
            cursor: pointer;
            position: relative;
            transition: background-color 0.2s;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 2px;
            bottom: 2px;
            background-color: #27ff47;
            transition: .4s;
        }
        input:checked + .slider {
            background-color: #111;
        }
        input:checked + .slider:before {
            transform: translateX(20px);
        }
        #public-link-container {
            margin-top: 10px;
        }
        #public-link-display {
            flex-grow: 1;
        }
        

        .view-more-container {
            text-align: center;
            margin-top: 20px;
        }
        
        .stats-section-header {
            margin-top: 40px;
            text-align: center;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
            text-align: center;
        }
        
        .stat-card {
            background-color: #111;
            padding: 20px;
            border: 2px solid #27ff47;
            word-break: break-all; /* Prevents overflow */
        }
        
        .stat-card h3 {
            margin: 0 0 10px 0;
            color: #27ff47;
            text-align: center;
        }
        
        .stat-card p {
            font-size: 2em;
            font-weight: bold;
            color: #27ff47;
        }
        
        /* --- Dynamic Streak Counter Styles --- */
        .streak-counter-layout {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        .digital-clock {
            font-family: 'Press Start 2P', cursive;
            font-size: 1.6em; 
            display: flex;
            align-items: baseline;
            justify-content: center;
            gap: 5px;
            color: #27ff47;
            text-shadow: 0 0 5px #27ff47;
            flex-shrink: 0;
        }
        .digital-clock span {
            display: inline-block;
            min-width: 1.2em;
            text-align: right;
        }
        .digital-clock .unit-label {
            font-size: 0.5em;
            align-self: flex-end;
            margin-left: -5px;
            margin-right: 5px;
        }
        .progress-bar-ascii {
            font-family: 'AppleIIe', monospace;
            font-size: 1.2em;
            text-align: center;
            margin-top: 0; 
            white-space: pre-wrap;
            color: #27ff47;
        }
        /* --- END: Dynamic Streak Counter Styles --- */

        .progress-bar-container {
            width: 100%;
            height: 20px;
            border: 1px solid #27ff47;
            background-color: #000;
            margin-top: 10px;
        }
        .progress-bar {
            height: 100%;
            background-color: #27ff47;
            transition: width 0.5s ease-in-out;
        }
        .progress-text {
            font-size: 1.2em;
            margin-top: 10px;
        }
        
        .achievements-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 20px;
            margin-top: 20px;
            text-align: center;
        }
        .badge-card {
            background-color: #111;
            padding: 20px;
            border: 2px solid #27ff47;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .badge-icon {
            font-size: 3em;
            color: #444;
            transition: color 0.5s ease;
        }
        .badge-icon.unlocked {
            color: #27ff47;
            text-shadow: 0 0 10px #27ff47;
        }
        .badge-name {
            margin-top: 10px;
            font-weight: bold;
        }

        .journal-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
            border: 2px solid #27ff47;
            padding: 15px;
        }
        .journal-entry {
            background-color: #111;
            border: 2px solid #27ff47;
            padding: 20px;
            margin-bottom: 20px;
        }
        .journal-entry-date {
            font-weight: bold;
            margin-bottom: 10px;
        }
        .journal-entry-text {
            white-space: pre-wrap;
            line-height: 1.5;
        }
        .journal-entry-actions {
            margin-top: 15px;
            display: flex;
            gap: 10px;
        }

        #condensed-calendar-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
            border: 2px solid #27ff47;
            padding: 15px;
        }
        .month-grid-container {
            padding: 10px;
        }
        .month-grid-title {
            text-align: center;
            font-size: 1em;
            margin-bottom: 10px;
        }
        .month-grid-dow, .month-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 3px;
        }
        .month-grid-dow div {
            text-align: center;
            font-size: 0.7em;
        }
        .month-grid-day {
            width: 100%;
            padding-bottom: 100%;
            position: relative;
            background-color: #1a1a1a;
        }
        .month-grid-day.active {
            background-color: #27ff47;
        }
        .month-grid-day.end {
            background-color: #ff8c00;
        }
        .month-grid-day.end-and-start {
             background: linear-gradient(135deg, #ff8c00 49%, #27ff47 51%);
        }
        .month-grid-day.goal-day {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .month-grid-day.goal-day::after {
            content: '🎯';
            font-size: 0.8em;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .year-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .year-nav h2 {
            margin: 0;
        }
        .year-nav button {
            padding: 5px 10px;
            font-size: 1.2em;
            line-height: 1;
        }

        #goal-progress-container.stat-card {
             padding: 15px;
        }

        .goal-inputs {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 20px;
        }
        .goal-input-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .goal-inputs label {
            font-size: 0.9em;
        }
        .goal-inputs input {
            flex-grow: 1;
            min-width: 80px;
            padding: 8px;
        }
        .goal-inputs span {
            font-style: italic;
        }

        /* --- Sidebar Navigation (Desktop) --- */
        .sidebar-nav {
            position: fixed;
            top: 0;
            left: 0;
            height: 100vh;
            width: 65px;
            background-color: #000;
            border-right: 2px solid #27ff47;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 20px;
            gap: 15px;
            z-index: 1000;
        }
        .nav-link {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: none;
            border: none;
            color: #27ff47;
            cursor: pointer;
            padding: 10px 5px;
            width: 100%;
            text-align: center;
            transition: background-color 0.2s;
        }
        .nav-link svg {
            width: 28px;
            height: 28px;
            fill: currentColor;
            margin-bottom: 5px;
        }
        .nav-link-label {
            font-size: 0.6em;
            font-family: 'Press Start 2P', cursive;
        }
        .nav-link:hover {
            background-color: #111;
        }
        .nav-link.active {
            background-color: #27ff47;
            color: #000;
        }
        /* --- END: Sidebar Navigation --- */

        /* --- Bottom Navigation (Mobile) --- */
        .mobile-nav {
            display: none; /* Hidden by default */
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: #000;
            border-top: 2px solid #27ff47;
            z-index: 1000;
            justify-content: space-around;
        }
        .mobile-nav .nav-link {
            padding: 8px;
            flex-grow: 1;
        }
        /* --- END: Bottom Navigation --- */
        
        /* --- Gamification Styles --- */
        #xp-toast {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #27ff47;
            color: #000;
            padding: 10px 20px;
            border: 2px solid #000;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8em;
            z-index: 2000;
            opacity: 0;
            transition: opacity 0.5s, bottom 0.5s;
        }
        #level-up-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.9);
            z-index: 3000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
        }
        #level-up-modal h2 {
            font-family: 'Press Start 2P', cursive;
            font-size: 4em;
            text-shadow: 0 0 15px #27ff47;
            animation: level-up-glow 1.5s infinite alternate;
        }
        #level-up-modal p {
            font-size: 1.5em;
            margin-top: 20px;
        }
        @keyframes level-up-glow {
            from { text-shadow: 0 0 10px #27ff47; }
            to { text-shadow: 0 0 30px #1aff32; }
        }
        /* --- END: Gamification Styles --- */

        /* --- Streak History Styles --- */
        #streak-history-container {
            margin-top: 20px;
        }
        .streak-history-item {
            background-color: #111;
            border: 2px solid #27ff47;
            margin-bottom: 10px;
            transition: background-color 0.2s;
        }
        .streak-history-item-clickable {
            padding: 15px;
            cursor: pointer;
        }
        .streak-history-item-clickable:hover {
            background-color: #1a1a1a;
        }
        .streak-history-item.active {
            border-color: #1aff32;
            background-color: #0a2a0a;
        }
        .streak-history-item-header {
            display: flex;
            justify-content: space-between;
            font-weight: bold;
            flex-wrap: wrap;
        }
        .streak-history-item-details {
            font-size: 0.9em;
            color: #aaa;
        }

        /* Accordion Detail View */
        .streak-detail-view {
            max-height: 0;
            overflow: hidden;
            opacity: 0;
            transition: max-height 0.4s ease-out, padding 0.4s ease-out, opacity 0.3s ease-out;
            padding: 0 15px;
            background-color: #080808;
            border-top: 1px dashed #222;
        }

        .streak-detail-view.visible {
            max-height: 400px; /* Allow for scrolling */
            opacity: 1;
            padding: 15px;
            overflow-y: auto;
        }
        
        .xp-log-list {
            list-style: none;
            padding: 0;
            margin: 0;
            font-size: 0.9em;
        }
        .xp-log-list li {
            padding: 8px 0;
            border-bottom: 1px dashed #222;
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
        }
        .xp-log-list li:last-child {
            border-bottom: none;
        }
        .xp-log-date {
            color: #aaa;
            flex-basis: 100px;
        }
        .xp-log-reason {
            flex-grow: 1;
        }
        .xp-log-points {
            font-weight: bold;
        }
        /* --- END: Streak History Styles --- */


        @media (max-width: 768px) {
            .sidebar-nav {
                display: none;
            }
            .mobile-nav {
                display: flex;
            }
            .main-content {
                margin-left: 0;
                padding-bottom: 80px; /* Space for bottom nav */
            }
             .three-month-view {
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-width: 700px) { 
        }

        @media (max-width: 600px) {
            body {
                padding: 0;
            }
            .main-content {
                padding: 10px;
                padding-bottom: 80px; /* Space for bottom nav */
            }
            .container {
                padding: 20px;
            }
            form {
                flex-direction: column;
            }
            .button-group {
                flex-direction: column;
            }
            table, thead, tbody, th, td, tr {
                display: block;
            }
            thead tr {
                position: absolute;
                top: -9999px;
                left: -9999px;
            }
            tr {
                border: 1px solid #27ff47;
                margin-bottom: 15px;
            }
            td {
                border: none;
                border-bottom: 1px solid #27ff47;
                position: relative;
                padding-left: 50%;
                text-align: right;
            }
            td:before {
                position: absolute;
                top: 0;
                left: 6px;
                width: 45%;
                padding-right: 10px;
                white-space: nowrap;
                content: attr(data-label);
                text-align: left;
                font-weight: bold;
                color: #27ff47;
            }
            td:last-child {
                border-bottom: 0;
            }
            .delete-btn {
                width: 100%;
                margin-top: 10px;
            }
            .start-date-cell:before { content: "Start Date"; }
            .end-date-cell:before { content: "End Date"; }
            .duration-cell:before { content: "Duration"; }
            .actions-cell:before { content: "Actions"; }

            .journal-controls {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>

    <!-- NEW: Loading Screen -->
    <div id="loading-container" class="container" style="text-align: center; padding: 50px;">
        <p>LOADING STREAKER...</p>
    </div>
    
    <!-- NEW: Public View Container -->
    <div id="public-view-container" class="container hidden">
        <!-- Public, read-only content will be rendered here by JavaScript -->
    </div>


    <!-- Login/Signup Section -->
    <div id="auth-container" class="container hidden">
        <div class="logo-and-title" style="margin-bottom: 20px;">
            <img src="https://raw.githubusercontent.com/rynwynk/streaker-app/main/logo%20only.png" alt="Streaker Logo" class="logo">
            <div>
                <h2>Streaker</h2>
                <p class="subtitle">Satisfied Through Denial</p>
            </div>
        </div>
        <div class="terminal-window">
            <div class="terminal-header">USER AUTHENTICATION</div>
            <form id="auth-form">
                <div class="form-row hidden">
                    <label for="username-input">USERNAME:</label>
                    <input type="text" id="username-input" placeholder="ENTER USERNAME" autocomplete="username">
                </div>
                 <div class="form-row">
                    <label for="email-input">EMAIL:</label>
                    <input type="email" id="email-input" placeholder="ENTER EMAIL" required autocomplete="email">
                 </div>
                 <div class="form-row">
                    <label for="password-input">PASSWORD:</label>
                    <input type="password" id="password-input" placeholder="ENTER PASSWORD" required autocomplete="current-password">
                 </div>
                 <div style="width: 100%; text-align: left;">
                    > <span class="blinking-cursor">_</span>
                 </div>
                <div class="button-group">
                    <button type="submit" id="main-auth-btn">Log In</button>
                    <button type="button" id="toggle-auth-mode-btn">Sign Up</button>
                </div>
            </form>
        </div>
        <p id="auth-error" class="error-message"></p>
    </div>

    <!-- Main App Section with New Layout -->
    <div id="app-layout" class="app-layout hidden">
        
        <!-- Sidebar Nav -->
        <nav class="sidebar-nav">
             <!-- Dashboard -->
            <button class="nav-link active" data-tab="dashboard">
                <svg viewBox="0 0 24 24"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg>
                <span class="nav-link-label">DASH</span>
            </button>
            <!-- Stats -->
            <button class="nav-link" data-tab="stats">
                 <svg viewBox="0 0 24 24"><path d="M10 20h4V4h-4v16zm-6 0h4v-8H4v8zM16 9v11h4V9h-4z"/></svg>
                <span class="nav-link-label">STATS</span>
            </button>
            <!-- Achievements -->
             <button class="nav-link" data-tab="achievements">
                 <svg viewBox="0 0 24 24"><path d="M19 5h-2V3H7v2H5c-1.1 0-2 .9-2 2v1c0 2.55 1.92 4.63 4.39 4.94.63 1.5 1.74 2.77 3.11 3.5V19H7v2h10v-2h-3.5v-3.56c1.37-.73 2.48-2 3.11-3.5.07-.16.12-.33.18-.5.1-.3.15-.61.15-.93V7c0-1.1-.9-2-2-2zm-7 10c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3z"/></svg>
                <span class="nav-link-label">AWARDS</span>
            </button>
            <!-- Journal -->
            <button class="nav-link" data-tab="journal">
                 <svg viewBox="0 0 24 24"><path d="M18 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM6 4h5v8l-2.5-1.5L6 12V4z"/></svg>
                <span class="nav-link-label">JOURNAL</span>
            </button>
            <!-- About -->
            <button class="nav-link" data-tab="about">
                <svg viewBox="0 0 24 24"><path d="M11 18h2v-2h-2v2zm1-16C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm0-14c-2.21 0-4 1.79-4 4h2c0-1.1.9-2 2-2s2 .9 2 2c0 2-3 1.75-3 5h2c0-2.25 3-2.5 3-5 0-2.21-1.79-4-4-4z"/></svg>
                <span class="nav-link-label">ABOUT</span>
            </button>
             <!-- Profile -->
            <button class="nav-link" data-tab="profile">
                <svg viewBox="0 0 24 24"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>
                <span class="nav-link-label">PROFILE</span>
            </button>
        </nav>

        <div class="main-content">
            <div id="main-app-container" class="container">
                <div class="header">
                    <div class="logo-and-title">
                        <img src="https://raw.githubusercontent.com/rynwynk/streaker-app/main/logo%20only.png" alt="Streaker Logo" class="logo">
                        <div>
                            <h2>Streaker</h2>
                            <p class="subtitle">Satisfied Through Denial</p>
                        </div>
                    </div>
                </div>

                <!-- Dashboard Container -->
                <div id="dashboard-container">
                    <div class="stat-card" style="margin-bottom: 30px;">
                        <h3>Current Streak</h3>
                        <div class="streak-counter-layout">
                            <div id="current-streak-digital-clock" class="digital-clock">
                                <span id="streak-days">0</span><span class="unit-label">d</span>
                                <span id="streak-hours">00</span><span class="unit-label">h</span>
                                <span id="streak-minutes">00</span><span class="unit-label">m</span>
                                <span id="streak-seconds">00</span><span class="unit-label">s</span>
                            </div>
                            <pre id="daily-progress-bar" class="progress-bar-ascii"></pre>
                        </div>
                    </div>
                    <div id="goal-progress-container" class="stat-card" style="margin-bottom: 40px;">
                        <h3 style="font-size: 1.5em;">Goal Progress</h3>
                        <p class="subtitle" style="text-align: center; margin-bottom: 15px; font-size: 0.7em;">Tomorrow Never Cums</p>
                        <div id="progress-bar-container" class="progress-bar-container">
                            <div id="progress-bar" class="progress-bar"></div>
                        </div>
                        <p id="progress-text" class="progress-text" style="font-size: 1.2em; margin-top: 5px;">0%</p>
                        <p id="goal-date" style="font-size: 0.8em; margin-top: 5px; min-height: 1em;"></p>
                        <div class="goal-inputs">
                            <div class="goal-input-group">
                                <label for="goal-input">Days:</label>
                                <input type="number" id="goal-input" placeholder="e.g., 30">
                            </div>
                             <span>OR</span>
                            <div class="goal-input-group">
                                 <label for="goal-date-input">Date:</label>
                                 <input type="date" id="goal-date-input">
                            </div>
                        </div>
                         <button id="set-goal-btn" style="width: 100%; margin-top: 15px;">Set Goal</button>
                    </div>
                    
                    <h2 class="stats-section-header" style="text-align: left;">Log Book</h2>
                    <p class="subtitle" style="text-align: left; margin-top: -5px; margin-bottom: 20px;">Edge. Deny. Repeat.</p>
                    <div style="display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 20px; align-items: center;">
                        <form id="entry-form" style="flex-grow: 1; margin-bottom: 0; display: flex; flex-wrap: wrap; gap: 10px;">
                            <input type="datetime-local" id="start-date-input" required style="flex-grow: 1;">
                            <input type="datetime-local" id="end-date-input" style="flex-grow: 1;">
                            <button type="submit">Add Entry</button>
                        </form>
                        <button id="export-btn" style="height: fit-content;">Export to CSV</button>
                    </div>
                    
                    <table id="log-table">
                        <thead>
                            <tr>
                                <th data-sort-key="startDate">Start Date <span class="sort-icon"></span></th>
                                <th data-sort-key="endDate">End Date <span class="sort-icon"></span></th>
                                <th data-sort-key="duration">Duration <span class="sort-icon"></span></th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                        </tbody>
                    </table>
                    <div id="view-more-container" class="view-more-container hidden">
                        <button id="view-more-btn">View More</button>
                    </div>
                </div>

                <!-- Stats Container (formerly Logbook) -->
                <div id="logbook-container" class="hidden">
                    <h2 class="stats-section-header">All-Time Stats</h2>
                    <div class="stat-card" style="margin-bottom: 20px;">
                        <h3>Current Rank</h3>
                        <p id="user-level-display-stats" style="font-size: 1.2em; margin-bottom: 10px;">LEVEL: 1 - NOVICE</p>
                        <pre id="xp-progress-bar-stats" class="progress-bar-ascii">[XP: 0/100]</pre>
                    </div>
                    <div class="stats-grid">
                        <div class="stat-card">
                            <h3>Total Days This Year</h3>
                            <p id="total-days-year-stat">0 days</p>
                        </div>
                        <div class="stat-card">
                            <h3>Longest Streak</h3>
                            <p id="longest-streak-stat">0 days</p>
                        </div>
                        <div class="stat-card">
                            <h3>Average Duration</h3>
                            <p id="avg-duration-stat">0d 0h</p>
                        </div>
                    </div>
                    <div class="stats-section-header year-nav">
                        <button id="prev-year-btn" title="Previous Year">&lt;</button>
                        <h2 style="margin: 0;">Year in Review (<span id="current-year-label"></span>)</h2>
                        <button id="next-year-btn" title="Next Year">&gt;</button>
                    </div>
                    <div id="condensed-calendar-container"></div>
                     <p style="text-align: center; font-size: 0.8em; margin-top: 15px;">
                         <span style="display: inline-block; width: 12px; height: 12px; background-color: #27ff47;"></span> Active
                         <span style="display: inline-block; width: 12px; height: 12px; background-color: #ff8c00; margin-left: 15px;"></span> Ended
                         <span style="display: inline-block; width: 12px; height: 12px; background: linear-gradient(135deg, #ff8c00 49%, #27ff47 51%); margin-left: 15px;"></span> Ended & Restarted
                          <span style="margin-left: 15px;">🎯 Goal</span>
                    </p>

                    <!-- Streak History Section -->
                    <h2 class="stats-section-header">Streak History</h2>
                    <div id="streak-history-container">
                        <!-- History items will be injected here -->
                    </div>
                </div>

                <!-- Achievements Container -->
                <div id="achievements-container" class="hidden">
                    <h2 class="stats-section-header">My Achievements</h2>
                    <div id="my-achievements-grid" class="achievements-grid">
                    </div>

                    <h2 class="stats-section-header">Available Badges</h2>
                    <div id="available-badges-grid" class="achievements-grid">
                    </div>
                </div>

                <!-- Journal Container -->
                <div id="journal-container" class="hidden">
                    <h2 class="stats-section-header" style="text-align: left;">Journal</h2>
                    <form id="journal-form">
                        <textarea id="journal-input" placeholder="Write your journal entry here..."></textarea>
                        <button type="submit">Submit Entry</button>
                    </form>

                    <div class="journal-controls">
                        <input type="search" id="journal-search-input" placeholder="Search entries...">
                        <input type="date" id="journal-filter-start-date" title="Filter start date">
                        <input type="date" id="journal-filter-end-date" title="Filter end date">
                        <button id="journal-filter-clear-btn">Clear</button>
                    </div>

                    <div id="journal-entries-container">
                    </div>
                </div>

                <!-- NEW: About Container -->
                <div id="about-container" class="hidden" style="line-height: 1.8;">
                    <h2 class="stats-section-header" style="text-align: left;">About Streaker</h2>
                    <p>
                        Welcome to Streaker, your digital companion for building unbreakable habits. This app is built on a simple philosophy: consistency is the key to achieving any goal. The retro interface is designed to be simple and distraction-free, helping you focus on what truly matters: showing up every single day.
                    </p>

                    <h3>Core Features</h3>
                    <ul>
                        <li><strong>Comprehensive Streak Logging:</strong> Easily log the start and end dates of your streaks. The app automatically calculates the duration and maintains a detailed history in your Log Book.</li>
                        <li><strong>Goal Setting & Progress Tracking:</strong> Set a target for your streak, either by a number of days or a specific end date. Visualize your progress with a dynamic progress bar on your dashboard.</li>
                        <li><strong>In-Depth Statistics:</strong> The Stats page provides valuable insights, including your longest streak, average streak duration, and a full-year calendar view to visualize your consistency.</li>
                        <li><strong>Personal Journal:</strong> Document your thoughts, challenges, and victories. The built-in journal helps you reflect on your journey, with search and filter capabilities to easily find past entries.</li>
                        <li><strong>Gamified Achievements:</strong> Stay motivated by unlocking badges for reaching significant milestones in your current streak.</li>
                        <li><strong>Public Profile Sharing:</strong> Optionally, share a read-only version of your progress with others to keep yourself accountable and inspire them with your dedication.</li>
                    </ul>

                    <h3>The Gamification System: XP & Levels</h3>
                    <p>
                        To make your journey more engaging, Streaker includes a leveling system. Your level is a direct reflection of the effort you've put into your <strong>current, active streak.</strong>
                    </p>
                    <p>
                        You earn Experience Points (XP) in three ways:
                     </p>
                     <ul>
                         <li><strong>+10 XP</strong> for every full day you maintain your active streak.</li>
                         <li><strong>+5 XP</strong> for every journal entry you write during your active streak.</li>
                         <li><strong>+10 XP</strong> for every achievement badge you unlock during your active streak.</li>
                     </ul>
                     <p>
                        When a streak ends, your XP for that streak resets to zero for the next one. This system is designed to reward present consistency above all else. Your all-time stats, like your longest streak, are always saved.
                    </p>

                    <h4>Ranks & Levels</h4>
                    <p>As you accumulate XP within a streak, you will advance through the ranks:</p>
                    <table style="text-align: left; font-size: 0.9em;">
                        <thead>
                            <tr>
                                <th>Level</th>
                                <th>Title</th>
                                <th>XP Required</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr><td>1</td><td>NOVICE</td><td>0 XP</td></tr>
                            <tr><td>2</td><td>APPRENTICE</td><td>100 XP</td></tr>
                            <tr><td>3</td><td>JOURNEYMAN</td><td>250 XP</td></tr>
                            <tr><td>4</td><td>EXPERT</td><td>500 XP</td></tr>
                            <tr><td>5</td><td>MASTER</td><td>1000 XP</td></tr>
                            <tr><td>6</td><td>GRANDMASTER</td><td>2000 XP</td></tr>
                            <tr><td>7</td><td>LEGEND</td><td>4000 XP</td></tr>
                            <tr><td>8</td><td>DEMIGOD</td><td>8000 XP</td></tr>
                        </tbody>
                    </table>

                    <p style="margin-top: 25px;">
                        As the motto says, "Satisfied Through Denial." The only time to act is now.
                    </p>
                </div>
                
                <!-- NEW: Profile Container -->
                <div id="profile-container" class="hidden">
                    <h2 class="stats-section-header" style="text-align: left;">Profile Settings</h2>
                     <div class="stat-card" style="margin-top: 20px;">
                        <h3>Rank</h3>
                        <p id="user-level-display-profile" style="font-size: 1.2em; margin-bottom: 10px;">LEVEL: 1 - NOVICE</p>
                        <pre id="xp-progress-bar-profile" class="progress-bar-ascii">[XP: 0/100]</pre>
                    </div>
                    <div class="stat-card" style="margin-top: 20px;">
                        <h3>Current User</h3>
                        <p id="user-profile-display" style="font-size: 1em;"></p>
                    </div>

                    <div class="stat-card" style="margin-top: 20px;">
                        <h3>Change Username</h3>
                        <div class="username-change-section" style="margin-top: 10px;">
                            <input type="text" id="new-username-input" placeholder="New username">
                            <button id="save-username-btn">Save</button>
                            <p id="username-status" class="error-message" style="margin: 10px 0 0 0;"></p>
                        </div>
                    </div>

                    <div class="stat-card" style="margin-top: 20px;">
                         <h3>Public Profile</h3>
                         <div class="sharing-section" style="border-top: none; padding: 0; margin-top: 10px;">
                             <div class="toggle-switch">
                                 <label for="public-profile-toggle">Enable Public Profile</label>
                                 <label class="slider-container">
                                     <input type="checkbox" id="public-profile-toggle">
                                     <span class="slider"></span>
                                 </label>
                             </div>
                             <div id="public-link-container" class="hidden">
                                 <div style="display:flex; gap: 10px; align-items:center; margin-bottom: 10px;">
                                     <input type="text" id="public-link-display" readonly>
                                     <button id="copy-public-link-btn" title="Copy Link" style="padding: 12px; line-height: 1;">
                                         <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
                                     </button>
                                 </div>
                                 <button id="refresh-public-data-btn">Refresh Public Data</button>
                             </div>
                         </div>
                    </div>

                     <div class="stat-card" style="margin-top: 20px;">
                        <h3>Account</h3>
                        <button id="new-logout-btn" class="logout-btn" style="margin-top: 10px;">Log Out</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Mobile Nav -->
        <nav class="mobile-nav">
             <!-- Dashboard -->
            <button class="nav-link active" data-tab="dashboard">
                <svg viewBox="0 0 24 24"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg>
                <span class="nav-link-label">DASH</span>
            </button>
            <!-- Stats -->
            <button class="nav-link" data-tab="stats">
                 <svg viewBox="0 0 24 24"><path d="M10 20h4V4h-4v16zm-6 0h4v-8H4v8zM16 9v11h4V9h-4z"/></svg>
                <span class="nav-link-label">STATS</span>
            </button>
            <!-- Achievements -->
             <button class="nav-link" data-tab="achievements">
                 <svg viewBox="0 0 24 24"><path d="M19 5h-2V3H7v2H5c-1.1 0-2 .9-2 2v1c0 2.55 1.92 4.63 4.39 4.94.63 1.5 1.74 2.77 3.11 3.5V19H7v2h10v-2h-3.5v-3.56c1.37-.73 2.48-2 3.11-3.5.07-.16.12-.33.18-.5.1-.3.15-.61.15-.93V7c0-1.1-.9-2-2-2zm-7 10c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3z"/></svg>
                <span class="nav-link-label">AWARDS</span>
            </button>
            <!-- Journal -->
            <button class="nav-link" data-tab="journal">
                 <svg viewBox="0 0 24 24"><path d="M18 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM6 4h5v8l-2.5-1.5L6 12V4z"/></svg>
                <span class="nav-link-label">JOURNAL</span>
            </button>
            <!-- Profile -->
            <button class="nav-link" data-tab="profile">
                <svg viewBox="0 0 24 24"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>
                <span class="nav-link-label">PROFILE</span>
            </button>
        </nav>
        
        <!-- NEW Gamification Elements -->
        <div id="xp-toast" class="hidden"></div>
        <div id="level-up-modal" class="hidden">
            <h2>LEVEL UP!</h2>
            <p id="level-up-details"></p>
        </div>
    </div>

    <!-- Firebase SDK Scripts -->
    <script src="https://www.gstatic.com/firebasejs/8.6.8/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.6.8/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.6.8/firebase-firestore.js"></script>

    <script>
        // Your Firebase project's configuration object
        const firebaseConfig = {
          apiKey: "AIzaSyCxPG9RfxihL-Rfhu7fPSP95QDld6QMuik",
          authDomain: "streaker-1658d.firebaseapp.com",
          projectId: "streaker-1658d",
          storageBucket: "streaker-1658d.appspot.com",
          messagingSenderId: "12701860115",
          appId: "1:12701860115:web:0d4dcba33fd234df97dae6",
          measurementId: "G-XKE790N7ZL"
        };
        
        // This log is for debugging purposes.
        console.log("Firebase config:", firebaseConfig);

        // Initialize Firebase
        if (firebaseConfig.apiKey) {
            try {
                firebase.initializeApp(firebaseConfig);
                console.log("Firebase initialized successfully.");
            } catch (error)
            {
                console.error("Firebase initialization failed:", error.message);
                console.warn("This may be because you have not created a Firestore database for your project. Please follow the instructions in the Firebase console.");
            }
        } else {
            console.error("Firebase config is missing or invalid. Please ensure you have pasted your config correctly.");
        }
        
        const auth = firebase.auth();
        const db = firebase.firestore();

        // DOM elements
        const authContainer = document.getElementById('auth-container');
        const mainAppContainer = document.getElementById('main-app-container');
        const appLayout = document.getElementById('app-layout');
        const authForm = document.getElementById('auth-form');
        const toggleAuthModeBtn = document.getElementById('toggle-auth-mode-btn');
        const mainAuthBtn = document.getElementById('main-auth-btn');
        const usernameInput = document.getElementById('username-input');
        const emailInput = document.getElementById('email-input');
        const passwordInput = document.getElementById('password-input');

        const newLogoutBtn = document.getElementById('new-logout-btn');
        const exportBtn = document.getElementById('export-btn');
        
        const allNavLinkBtns = document.querySelectorAll('.nav-link');

        const dashboardContainer = document.getElementById('dashboard-container');
        const logbookContainer = document.getElementById('logbook-container');
        const achievementsContainer = document.getElementById('achievements-container');
        const journalContainer = document.getElementById('journal-container');
        const aboutContainer = document.getElementById('about-container');
        const profileContainer = document.getElementById('profile-container');

        // Logbook elements
        const entryForm = document.getElementById('entry-form');
        const logTableBody = document.querySelector('#log-table tbody');
        const authError = document.getElementById('auth-error');
        const startDateInput = document.getElementById('start-date-input');
        const endDateInput = document.getElementById('end-date-input');
        const tableHeaders = document.querySelectorAll('#log-table th[data-sort-key]');
        const viewMoreBtn = document.getElementById('view-more-btn');
        const viewMoreContainer = document.getElementById('view-more-container');
        const longestStreakStat = document.getElementById('longest-streak-stat');
        const avgDurationStat = document.getElementById('avg-duration-stat');
        const totalDaysYearStat = document.getElementById('total-days-year-stat');
        
        // Goal elements
        const goalInput = document.getElementById('goal-input');
        const goalDateInput = document.getElementById('goal-date-input');
        const progressBar = document.getElementById('progress-bar');
        const progressText = document.getElementById('progress-text');
        const goalDate = document.getElementById('goal-date');

        // Achievements elements
        const myAchievementsGrid = document.getElementById('my-achievements-grid');
        const availableBadgesGrid = document.getElementById('available-badges-grid');

        // Journal elements
        const journalForm = document.getElementById('journal-form');
        const journalInput = document.getElementById('journal-input');
        const journalEntriesContainer = document.getElementById('journal-entries-container');
        const journalSearchInput = document.getElementById('journal-search-input');
        const journalFilterStartDate = document.getElementById('journal-filter-start-date');
        const journalFilterEndDate = document.getElementById('journal-filter-end-date');
        const journalFilterClearBtn = document.getElementById('journal-filter-clear-btn');

        // NEW: Profile elements
        const userProfileDisplay = document.getElementById('user-profile-display');
        const publicProfileToggle = document.getElementById('public-profile-toggle');
        const publicLinkContainer = document.getElementById('public-link-container');
        const publicLinkDisplay = document.getElementById('public-link-display');
        const refreshPublicDataBtn = document.getElementById('refresh-public-data-btn');
        const copyPublicLinkBtn = document.getElementById('copy-public-link-btn');
        
        // NEW: Username change elements
        const newUsernameInput = document.getElementById('new-username-input');
        const saveUsernameBtn = document.getElementById('save-username-btn');
        const usernameStatus = document.getElementById('username-status');
        
        // NEW: Streak History elements
        const streakHistoryContainer = document.getElementById('streak-history-container');
        
        // NEW: Chart, Loading, and Public View containers
        const loadingContainer = document.getElementById('loading-container');
        const publicViewContainer = document.getElementById('public-view-container');
        
        let isSignupMode = false;
        let userLogs = [];
        let allJournalEntries = []; // Holds all journal entries for client-side filtering
        let sortState = {
            key: 'startDate',
            direction: 'desc'
        };
        let visibleLogEntriesCount = 5;
        let ongoingStreakInterval = null;
        let currentEditingLogId = null;
        let displayedYear = new Date().getFullYear(); // For year-in-review calendar
        let userData = {}; // To store user doc data like username, last check-in
        let mainAppListenersAdded = false; // Flag to ensure listeners are only added once
        let isUpdatingGoal = false; // Flag to prevent goal input loops
        let publicInterval = null; // To manage the public profile's update timer
        
        // --- START: GAMIFICATION LOGIC --- //
        
        // Configuration for levels based on XP
        const LEVEL_CONFIG = [
            { level: 1, xp: 0, title: 'NOVICE' },
            { level: 2, xp: 100, title: 'APPRENTICE' },
            { level: 3, xp: 250, title: 'JOURNEYMAN' },
            { level: 4, xp: 500, title: 'EXPERT' },
            { level: 5, xp: 1000, title: 'MASTER' },
            { level: 6, xp: 2000, title: 'GRANDMASTER' },
            { level: 7, xp: 4000, title: 'LEGEND' },
            { level: 8, xp: 8000, title: 'DEMIGOD' },
            // Add more levels as needed for endless progression
        ];

        const ACHIEVEMENTS_CONFIG = [
            { name: "Gotta Start Somewhere", days: 1, icon: '🌱' },
            { name: "7-Day Streak", days: 7, icon: '⭐' },
            { name: "2-Week Streak", days: 14, icon: '📅' },
            { name: "30-Day Streak", days: 30, icon: '🏆' },
            { name: "One-Month Wonder", days: 30, icon: '🌟' },
            { name: "Two-Month Trekker", days: 60, icon: '🚶‍♂️' },
            { name: "Three-Month Triumph", days: 90, icon: '🎉' },
            { name: "90-Day Streak", days: 90, icon: '🛡️' },
            { name: "100-Day Streak", days: 100, icon: '💯' },
            { name: "Four-Month Force", days: 120, icon: '💪' },
            { name: "Five-Month Fighter", days: 150, icon: '🥊' },
            { name: "Six-Month Soarer", days: 180, icon: '🕊️' },
            { name: "Seven-Month Success", days: 210, icon: '🎯' },
            { name: "Eight-Month Effort", days: 240, icon: '🥇' },
            { name: "Nine-Month Ninja", days: 270, icon: '🥷' },
            { name: "Ten-Month Titan", days: 300, icon: '👑' },
            { name: "Eleven-Month Emperor", days: 330, icon: '👑' },
            { name: "One-Year Victor", days: 365, icon: '🏅' },
        ];
        
        /**
         * Calculates user level and progress based on total experience points (XP).
         * @param {number} xp - The total XP of the user.
         * @returns {object} An object containing level, title, XP thresholds, and progress percentage.
         */
        function calculateLevelFromXp(xp = 0) {
            const currentLevelInfo = LEVEL_CONFIG.slice().reverse().find(l => xp >= l.xp) || LEVEL_CONFIG[0];
            const nextLevelInfo = LEVEL_CONFIG.find(l => l.level === currentLevelInfo.level + 1);

            const xpForCurrentLevel = currentLevelInfo.xp;
            const xpForNextLevel = nextLevelInfo ? nextLevelInfo.xp : Infinity;
            
            const xpInCurrentLevel = xp - xpForCurrentLevel;
            const xpNeededForNextLevel = xpForNextLevel - xpForCurrentLevel;

            let progress = 100;
            if (nextLevelInfo && xpNeededForNextLevel > 0) {
                 progress = Math.round((xpInCurrentLevel / xpNeededForNextLevel) * 100);
            }

            return {
                level: currentLevelInfo.level,
                title: currentLevelInfo.title,
                xpForCurrentLevel,
                xpForNextLevel,
                progress,
            };
        }
        
        /**
         * Calculates XP for a specific streak, whether active or completed.
         * @param {object} streakDoc - The Firestore document for the streak.
         * @param {Array} journalEntries - The list of journal entries to consider for XP calculation.
         * @returns {number} The total XP for that streak.
         */
        function calculateXpForStreak(streakDoc, journalEntries) {
             let totalXp = 0;
             if (!streakDoc || !streakDoc.data()) return 0;
             const streakData = streakDoc.data();
             if (!streakData.startDate) return 0;

             const streakStartDate = parseDate(streakData.startDate);
             const streakEndDate = streakData.endDate ? parseDate(streakData.endDate) : new Date();

             if (streakStartDate) {
                 const duration = calculateDuration(streakStartDate, streakEndDate);
                 // 1. XP from streak duration (10 XP per day)
                 totalXp += duration.days * 10;

                 // 2. XP from journal entries during this streak (5 XP per entry)
                 const journalEntriesDuringStreak = journalEntries.filter(doc => {
                     const entryData = doc.data();
                     if (entryData && entryData.date && typeof entryData.date.toDate === 'function') {
                         const entryDate = entryData.date.toDate();
                         // Check if entry is within the streak's timeframe
                         return entryDate >= streakStartDate && entryDate <= streakEndDate;
                     }
                     return false;
                 });
                 totalXp += journalEntriesDuringStreak.length * 5;

                 // 3. XP from achievements (10 XP per badge)
                 ACHIEVEMENTS_CONFIG.forEach(achievement => {
                     if (duration.days >= achievement.days) {
                         totalXp += 10;
                     }
                 });
             }
             return totalXp;
        }


        /**
         * Calculates XP based on the current active streak's duration and journal entries.
         * Then, updates all gamification UI elements.
         */
        async function calculateAndSetCurrentStreakXp() {
            const oldXp = userData.xp || 0;
            let totalXp = 0;
            const activeStreakDoc = userLogs.find(doc => doc.data() && !doc.data().endDate);

            if (activeStreakDoc) {
                totalXp = calculateXpForStreak(activeStreakDoc, allJournalEntries);
            }
            
            // Check for level up
            const oldLevelData = calculateLevelFromXp(oldXp);
            const newLevelData = calculateLevelFromXp(totalXp);
            if (newLevelData.level > oldLevelData.level) {
                showLevelUpModal(newLevelData.level, newLevelData.title);
            }
            
            // Update the global user data object for consistency
            userData.xp = totalXp;
            updateGamificationUI(totalXp);
        }
        
        /**
         * Updates all gamification-related UI elements (level, XP bar).
         */
        function updateGamificationUI(currentXp = 0) {
            const levelData = calculateLevelFromXp(currentXp);

            const levelText = `LEVEL: ${levelData.level} - ${levelData.title}`;
            document.getElementById('user-level-display-stats').textContent = levelText;
            document.getElementById('user-level-display-profile').textContent = levelText;

            const xpText = isFinite(levelData.xpForNextLevel) ? `[XP: ${currentXp}/${levelData.xpForNextLevel}]` : `[XP: ${currentXp} / MAX]`;
            const barWidth = 20;
            const filledChars = Math.round(barWidth * (levelData.progress / 100));
            const emptyChars = barWidth - filledChars;
            const asciiBar = `[${'█'.repeat(filledChars)}${'░'.repeat(emptyChars)}] ${levelData.progress}%`;
            
            const fullProgressBarText = `${xpText}\n${asciiBar}`;

            document.getElementById('xp-progress-bar-stats').textContent = fullProgressBarText;
            document.getElementById('xp-progress-bar-profile').textContent = fullProgressBarText;
        }

        /**
         * Shows a temporary toast notification for XP gain.
         */
        function showXpToast(amount, reason) {
            const toast = document.getElementById('xp-toast');
            toast.textContent = `${amount >= 0 ? '+' : ''}${amount} XP (${reason})`;
            toast.classList.remove('hidden');
            toast.style.opacity = '1';
            toast.style.bottom = '100px';

            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.bottom = '80px';
                setTimeout(() => toast.classList.add('hidden'), 500);
            }, 3000);
        }

        /**
         * Shows the level-up modal.
         */
        function showLevelUpModal(level, title) {
            const modal = document.getElementById('level-up-modal');
            const details = document.getElementById('level-up-details');
            details.textContent = `You've reached Level ${level}: ${title}!`;
            modal.classList.remove('hidden');

            setTimeout(() => {
                modal.classList.add('hidden');
            }, 4000);
        }
        
        // --- END: GAMIFICATION LOGIC --- //

        function parseDate(dateInput) {
            if (!dateInput) return null;
            // Handle Firestore Timestamps
            if (dateInput && typeof dateInput.toDate === 'function') {
                return dateInput.toDate();
            }
            // Handle existing Date objects
            if (dateInput instanceof Date) {
                return dateInput;
            }
            // Handle date-only strings (YYYY-MM-DD) as local time midnight
            if (typeof dateInput === 'string' && dateInput.match(/^\d{4}-\d{2}-\d{2}$/)) {
                return new Date(dateInput + 'T00:00:00');
            }
            // Fallback for other string types (like full ISO strings) or numbers
            const date = new Date(dateInput); 
            return isNaN(date.getTime()) ? null : date;
        }
        
        function formatShortDate(dateInput) {
             const date = parseDate(dateInput);
             if (!date) return 'Invalid';
             const options = { year: 'numeric', month: 'short', day: 'numeric' };
             return date.toLocaleDateString('en-US', options);
        }

        function formatDate(dateInput) {
            const date = parseDate(dateInput);
            if (!date) return 'Invalid Date';
            // Using UTC for date-only strings ensures consistency across timezones
            const options = { year: 'numeric', month: 'long', day: 'numeric', timeZone: 'UTC' };
            return date.toLocaleDateString('en-US', options);
        }

        // Helper function to format date for input fields
        function formatDateForInput(date) {
            if (!date || !(date instanceof Date)) return '';
            const pad = (num) => num.toString().padStart(2, '0');
            const year = date.getFullYear();
            const month = pad(date.getMonth() + 1);
            const day = pad(date.getDate());
            const hours = pad(date.getHours());
            const minutes = pad(date.getMinutes());
            return `${year}-${month}-${day}T${hours}:${minutes}`;
        }
        
        function formatFullDate(date) {
            if (!date || !(date instanceof Date)) return 'N/A'; // Graceful handling
            const options = { year: 'numeric', month: 'long', day: 'numeric', hour: 'numeric', minute: 'numeric' };
            return date.toLocaleDateString('en-US', options);
        }

        // Function to calculate and format duration
        function calculateDuration(startDateInput, endDateInput) {
            const start = parseDate(startDateInput);
            if (!start) return { totalMilliseconds: 0, formatted: "Invalid", days: 0, hours: 0, minutes: 0, seconds: 0 };

            const end = endDateInput ? parseDate(endDateInput) : new Date();
            if (!end) return { totalMilliseconds: 0, formatted: "Invalid", days: 0, hours: 0, minutes: 0, seconds: 0 };
        
            const diff = end - start;
            if (isNaN(diff) || diff < 0) return { totalMilliseconds: 0, formatted: "0d 0h 0m", days: 0, hours: 0, minutes: 0, seconds: 0 };

            const days = Math.floor(diff / (1000 * 60 * 60 * 24));
            const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((diff % (1000 * 60)) / 1000);

            // For completed streaks, don't show seconds. For ongoing, show them for the digital clock.
            const formatted = endDateInput 
                ? `${days}d ${hours}h ${minutes}m`
                : `${days}d ${hours}h ${minutes}m`;

            return { totalMilliseconds: diff, formatted, days, hours, minutes, seconds };
        }
        
        function formatDurationFromMs(ms) {
            if (isNaN(ms) || ms < 0) {
                return { formatted: "0d 0h 0m", days: 0, hours: 0, minutes: 0 };
            }
            const days = Math.round(ms / (1000 * 60 * 60 * 24));
            return { formatted: `${days} days`, days };
        }
        
        // Function to calculate total days in a streak for the current year
        function calculateTotalDaysThisYear() {
            const currentYear = new Date().getFullYear();
            let totalDays = 0;

            userLogs.forEach(doc => {
                const log = doc.data();
                const startDate = parseDate(log.startDate);
                const endDate = parseDate(log.endDate) || new Date();

                if (!startDate) return;

                if (startDate.getFullYear() > currentYear && endDate.getFullYear() > currentYear) return;

                const startOfYear = new Date(currentYear, 0, 1);
                const endOfYear = new Date(currentYear, 11, 31, 23, 59, 59);

                const streakStart = startDate < startOfYear ? startOfYear : startDate;
                const streakEnd = endDate > endOfYear ? endOfYear : endDate;
                
                if (streakEnd > streakStart) {
                    const diffTime = Math.abs(streakEnd - streakStart);
                    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                    totalDays += diffDays;
                }
            });
            return totalDays;
        }

        // Function to update goal progress bar
        function updateGoalProgress(goal) {
            const currentStreak = userLogs.find(doc => !doc.data().endDate);
            const currentDays = currentStreak ? calculateDuration(currentStreak.data().startDate, null).days : 0;
            const goalDays = goal || 0;

            if (!goalDays || goalDays <= 0) {
                progressBar.style.width = '0%';
                progressText.textContent = `0%`;
                return;
            }

            const progressPercentage = Math.min((currentDays / goalDays) * 100, 100);
            progressBar.style.width = `${progressPercentage}%`;
            
            const remainingDays = Math.max(0, goalDays - currentDays);
            
            if (remainingDays > 0) {
                progressText.textContent = `${Math.round(progressPercentage)}% (${remainingDays} ${remainingDays === 1 ? 'day' : 'days'} remaining)`;
            } else {
                progressText.textContent = `${Math.round(progressPercentage)}% (Goal reached!)`;
            }
        }

        // Function to calculate and render stats
        function calculateStats() {
            let longestDurationMs = 0;
            let totalCompletedDurationMs = 0;
            let completedEntriesCount = 0;
            let ongoingEntry = null;

            userLogs.forEach(doc => {
                const log = doc.data();
                const duration = calculateDuration(log.startDate, log.endDate);
                if (log.endDate) {
                    totalCompletedDurationMs += duration.totalMilliseconds;
                    completedEntriesCount++;
                } else {
                    ongoingEntry = log;
                }
                
                if (duration.totalMilliseconds > longestDurationMs) {
                    longestDurationMs = duration.totalMilliseconds;
                }
            });

            const longestDuration = formatDurationFromMs(longestDurationMs);
            longestStreakStat.textContent = `${longestDuration.days} days`;
            
            if (completedEntriesCount > 0) {
                const avgMs = totalCompletedDurationMs / completedEntriesCount;
                const roundedDays = Math.round(avgMs / (1000 * 60 * 60 * 24));
                avgDurationStat.textContent = `${roundedDays} days`;
            } else {
                avgDurationStat.textContent = "0 days";
            }

            if (ongoingEntry) {
                if (ongoingStreakInterval) clearInterval(ongoingStreakInterval);
                const update = () => {
                    const currentDuration = calculateDuration(ongoingEntry.startDate, null);
                    
                    document.getElementById('streak-days').textContent = currentDuration.days;
                    document.getElementById('streak-hours').textContent = String(currentDuration.hours).padStart(2, '0');
                    document.getElementById('streak-minutes').textContent = String(currentDuration.minutes).padStart(2, '0');
                    document.getElementById('streak-seconds').textContent = String(currentDuration.seconds).padStart(2, '0');

                    const now = new Date();
                    const secondsToday = now.getSeconds() + (now.getMinutes() * 60) + (now.getHours() * 3600);
                    const progressPercent = (secondsToday / 86400);
                    
                    const barWidth = 20;
                    const filledChars = Math.round(barWidth * progressPercent);
                    const emptyChars = barWidth - filledChars;
                    
                    document.getElementById('daily-progress-bar').textContent = `[${'█'.repeat(filledChars)}${'░'.repeat(emptyChars)}]`;
                };
                update();
                ongoingStreakInterval = setInterval(update, 1000);
            } else {
                if (ongoingStreakInterval) clearInterval(ongoingStreakInterval);
                document.getElementById('streak-days').textContent = '0';
                document.getElementById('streak-hours').textContent = '00';
                document.getElementById('streak-minutes').textContent = '00';
                document.getElementById('streak-seconds').textContent = '00';
                document.getElementById('daily-progress-bar').textContent = `[${'░'.repeat(20)}]`;
            }
            
            totalDaysYearStat.textContent = `${calculateTotalDaysThisYear()} days`;
            renderCondensedCalendar(displayedYear, userLogs, goalDateInput.value, '#condensed-calendar-container', '#current-year-label');
        }

        // Display log entries
        function renderLogs() {
            logTableBody.innerHTML = '';
            
            const sortedLogs = userLogs.slice().sort((a, b) => {
                const aData = a.data();
                const bData = b.data();
                let aVal, bVal;

                if (sortState.key === 'duration') {
                    aVal = calculateDuration(aData.startDate, aData.endDate).totalMilliseconds;
                    bVal = calculateDuration(bData.startDate, bData.endDate).totalMilliseconds;
                } else {
                    aVal = parseDate(aData.startDate)?.getTime() || 0;
                    bVal = parseDate(bData.startDate)?.getTime() || 0;
                }
                
                if (sortState.direction === 'asc') {
                    return aVal - bVal;
                } else {
                    return bVal - aVal;
                }
            });

            const visibleLogs = sortedLogs.slice(0, visibleLogEntriesCount);

            visibleLogs.forEach(doc => {
                const log = doc.data();
                const row = document.createElement('tr');
                row.dataset.id = doc.id;

                const startDateFormatted = formatFullDate(parseDate(log.startDate));
                const endDateFormatted = log.endDate ? formatFullDate(parseDate(log.endDate)) : `<button class="end-streak-btn">End & Restart</button>`;
                
                const duration = calculateDuration(log.startDate, log.endDate);
                const durationText = duration.formatted;

                if (doc.id === currentEditingLogId) {
                    const startDateForInput = formatDateForInput(parseDate(log.startDate));
                    if (log.endDate) {
                        // Editing a completed streak
                        const endDateForInput = formatDateForInput(parseDate(log.endDate));
                        row.innerHTML = `
                            <td class="start-date-cell" data-label="Start Date"><input type="datetime-local" value="${startDateForInput}" class="edit-start-input" /></td>
                            <td class="end-date-cell" data-label="End Date"><input type="datetime-local" value="${endDateForInput}" class="edit-end-input" /></td>
                            <td class="duration-cell" data-label="Duration">${durationText}</td>
                            <td data-label="Actions" class="actions-cell">
                                <button class="save-btn">Save</button>
                                <button class="cancel-btn">Cancel</button>
                            </td>
                        `;
                    } else {
                        // Editing an active streak
                        row.innerHTML = `
                            <td class="start-date-cell" data-label="Start Date"><input type="datetime-local" value="${startDateForInput}" class="edit-start-input" /></td>
                            <td class="end-date-cell" data-label="End Date">Ongoing</td>
                            <td class="duration-cell" data-label="Duration">${durationText}</td>
                            <td data-label="Actions" class="actions-cell">
                                <button class="save-btn">Save</button>
                                <button class="cancel-btn">Cancel</button>
                            </td>
                        `;
                    }
                } else if (log.endDate) {
                    // A completed streak, not in edit mode
                     row.innerHTML = `
                        <td class="start-date-cell" data-label="Start Date">${startDateFormatted}</td>
                        <td class="end-date-cell" data-label="End Date">${endDateFormatted}</td>
                        <td class="duration-cell" data-label="Duration">${durationText}</td>
                        <td data-label="Actions" class="actions-cell">
                            <button class="edit-btn">Edit</button>
                            <button class="delete-btn">Delete</button>
                        </td>
                    `;
                } else {
                    // An active streak, not in edit mode
                    row.innerHTML = `
                        <td class="start-date-cell" data-label="Start Date">${startDateFormatted}</td>
                        <td class="end-date-cell" data-label="End Date">${endDateFormatted}</td>
                        <td class="duration-cell" data-label="Duration">${durationText}</td>
                        <td data-label="Actions" class="actions-cell">
                            <button class="edit-btn">Edit</button>
                            <button class="delete-btn">Delete</button>
                        </td>
                    `;
                }

                logTableBody.appendChild(row);
            });

            viewMoreContainer.classList.toggle('hidden', userLogs.length <= visibleLogEntriesCount);

            tableHeaders.forEach(header => {
                const icon = header.querySelector('.sort-icon');
                if (header.dataset.sortKey === sortState.key) {
                    icon.textContent = sortState.direction === 'asc' ? '▲' : '▼';
                } else {
                    icon.textContent = '';
                }
            });
        }
        
        // Function to render achievements
        function renderAchievements() {
            myAchievementsGrid.innerHTML = '';
            availableBadgesGrid.innerHTML = '';
            
            const ongoingEntry = userLogs.find(doc => !doc.data().endDate);
            const currentStreakDays = ongoingEntry ? calculateDuration(ongoingEntry.data().startDate, null).days : 0;
            
            ACHIEVEMENTS_CONFIG.sort((a,b) => a.days - b.days).forEach(achievement => {
                const unlocked = currentStreakDays >= achievement.days;
                const grid = unlocked ? myAchievementsGrid : availableBadgesGrid;
                const badge = document.createElement('div');
                badge.className = 'badge-card';
                badge.innerHTML = `
                    <div class="badge-icon ${unlocked ? 'unlocked' : ''}">${achievement.icon}</div>
                    <div class="badge-name">${achievement.name}</div>
                `;
                grid.appendChild(badge);
            });
            
            if (myAchievementsGrid.children.length === 0) {
                myAchievementsGrid.innerHTML = '<p style="font-style: italic; color: #aaa;">Keep going! You haven\'t earned any badges yet on this streak.</p>';
            }

            if (availableBadgesGrid.children.length === 0 && ongoingEntry) {
                 availableBadgesGrid.innerHTML = '<p style="font-style: italic; color: #aaa;">Congratulations! You have collected all available badges for this streak!</p>';
            }
        }
        
        function renderCondensedCalendar(year, allLogs, goalDateString, containerSelector, yearLabelSelector) {
            const container = document.querySelector(containerSelector);
            const yearLabel = document.querySelector(yearLabelSelector);
            if(!container || !yearLabel) return;
            
            container.innerHTML = '';
            yearLabel.textContent = year;

            const activeDays = new Set();
            const endDays = new Set();
            const startDays = new Set();

            allLogs.forEach(doc => {
                const log = doc.data ? doc.data() : doc;
                const logStart = parseDate(log.startDate);
                if (!logStart) return;

                const logEnd = parseDate(log.endDate) || new Date();
                
                if (logStart.getFullYear() === year) {
                    startDays.add(logStart.toISOString().split('T')[0]);
                }

                if (log.endDate && logEnd.getFullYear() === year) {
                     endDays.add(logEnd.toISOString().split('T')[0]);
                }

                for (let d = new Date(logStart); d <= logEnd; d.setDate(d.getDate() + 1)) {
                    if (d.getFullYear() === year) {
                        activeDays.add(d.toISOString().split('T')[0]);
                    }
                }
            });

            const monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
            
            for(let month = 0; month < 12; month++) {
                const monthContainer = document.createElement('div');
                monthContainer.className = 'month-grid-container';
                monthContainer.innerHTML = `
                    <h3 class="month-grid-title">${monthNames[month]}</h3>
                    <div class="month-grid-dow">
                        ${['S', 'M', 'T', 'W', 'T', 'F', 'S'].map(d => `<div>${d}</div>`).join('')}
                    </div>
                `;
                const monthGrid = document.createElement('div');
                monthGrid.className = 'month-grid';

                const firstDayOfMonth = new Date(year, month, 1).getDay();
                const daysInMonth = new Date(year, month + 1, 0).getDate();

                for(let i=0; i<firstDayOfMonth; i++) {
                    monthGrid.appendChild(document.createElement('div'));
                }

                for(let day = 1; day <= daysInMonth; day++) {
                    const dayCell = document.createElement('div');
                    dayCell.className = 'month-grid-day';
                    const dateString = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                    dayCell.title = dateString;

                    const isEndDay = endDays.has(dateString);
                    const isActiveDay = activeDays.has(dateString);
                    const isStartDay = startDays.has(dateString);

                    if (isEndDay && isStartDay) dayCell.classList.add('end-and-start');
                    else if (isEndDay) dayCell.classList.add('end');
                    else if (isActiveDay) dayCell.classList.add('active');
                    
                    if (dateString === goalDateString) dayCell.classList.add('goal-day');

                    monthGrid.appendChild(dayCell);
                }
                monthContainer.appendChild(monthGrid);
                container.appendChild(monthContainer);
            }
        }

        function applyAndRenderJournalFilters() {
            const searchTerm = journalSearchInput.value.toLowerCase();
            const startDate = journalFilterStartDate.value;
            const endDate = journalFilterEndDate.value;

            const filteredEntries = allJournalEntries.filter(doc => {
                const entry = doc.data();
                if (!entry.date || typeof entry.date.toDate !== 'function') return false;
                
                const entryDate = entry.date.toDate();
                const textMatch = (entry.text || '').toLowerCase().includes(searchTerm);
                const startDateMatch = !startDate || entryDate >= new Date(startDate);
                const endDateMatch = !endDate || entryDate <= new Date(new Date(endDate).setHours(23, 59, 59));
                
                return textMatch && startDateMatch && endDateMatch;
            });
            
            renderJournalEntries(filteredEntries);
        }

        function renderJournalEntries(journalDocs) {
            journalEntriesContainer.innerHTML = '';
            if (journalDocs.length === 0) {
                journalEntriesContainer.innerHTML = '<p style="text-align: center; margin-top: 20px;">No entries to display.</p>';
                return;
            }

            journalDocs.forEach(doc => {
                const entry = doc.data();
                const entryDiv = document.createElement('div');
                entryDiv.className = 'journal-entry';
                entryDiv.dataset.id = doc.id;

                entryDiv.innerHTML = `
                    <div class="journal-entry-date">${formatFullDate(entry.date.toDate())}</div>
                    <div class="journal-entry-content"><p class="journal-entry-text">${entry.text}</p></div>
                    <div class="journal-entry-actions">
                        <button class="edit-btn">Edit</button>
                        <button class="delete-btn">Delete</button>
                    </div>
                `;
                journalEntriesContainer.appendChild(entryDiv);
            });
        }
        
        function exportToCsv() {
            if (userLogs.length === 0) {
                alert("No data to export.");
                return;
            }

            const rows = userLogs.map(doc => {
                const log = doc.data();
                const duration = calculateDuration(log.startDate, log.endDate);
                return [log.startDate || '', log.endDate || '', duration.formatted];
            });

            let csvContent = "data:text/csv;charset=utf-8,Start Date,End Date,Duration\n" 
                + rows.map(e => e.join(",")).join("\n");

            const link = document.createElement("a");
            link.setAttribute("href", encodeURI(csvContent));
            link.setAttribute("download", "streaker_data.csv");
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        async function updatePublicData(user) {
            if (!user) {
                alert('Cannot update public data. You must be logged in.');
                return;
            }
            
            const userDoc = await db.collection('users').doc(user.uid).get();
            const currentData = userDoc.exists ? userDoc.data() : {};

            const logsSnapshot = await db.collection('users').doc(user.uid).collection('logs').get();
            const currentLogs = logsSnapshot.docs;
            
            const ongoingEntry = currentLogs.find(doc => doc.data() && !doc.data().endDate);
            const currentStreakStartDate = ongoingEntry ? ongoingEntry.data().startDate : null;

            let longestDurationMs = 0;
            let totalCompletedDurationMs = 0;
            let completedEntriesCount = 0;

            currentLogs.forEach(doc => {
                const log = doc.data();
                if(!log || !log.startDate) return;
                const duration = calculateDuration(log.startDate, log.endDate);
                if (duration.totalMilliseconds > longestDurationMs) {
                    longestDurationMs = duration.totalMilliseconds;
                }
                if (log.endDate) {
                    totalCompletedDurationMs += duration.totalMilliseconds;
                    completedEntriesCount++;
                }
            });
            const longestStreakDays = formatDurationFromMs(longestDurationMs).days;
            
            let avgDurationFormatted = "0 days";
            if (completedEntriesCount > 0) {
                const avgMs = totalCompletedDurationMs / completedEntriesCount;
                const roundedDays = Math.round(avgMs / (1000 * 60 * 60 * 24));
                avgDurationFormatted = `${roundedDays} days`;
            }

            const publicLogs = currentLogs
                .filter(doc => doc.data() && doc.data().startDate)
                .map(doc => ({
                    startDate: doc.data().startDate,
                    endDate: doc.data().endDate || null
                }));

            const currentStreakDays = ongoingEntry ? calculateDuration(ongoingEntry.data().startDate, null).days : 0;

            const unlockedAchievements = ACHIEVEMENTS_CONFIG
                .filter(achievement => currentStreakDays >= achievement.days)
                .map(({ name, icon }) => ({ name, icon }));
            
            const journalSnapshot = await db.collection('users').doc(user.uid).collection('journal').get();
            const allJournalEntriesPublic = journalSnapshot.docs;
            let currentStreakXp = 0;
            if (ongoingEntry) {
                 currentStreakXp = calculateXpForStreak(ongoingEntry, allJournalEntriesPublic);
            }

            const { level, title } = calculateLevelFromXp(currentStreakXp);

            const publicData = {
                displayName: currentData.username || user.email || 'Anonymous User',
                currentStreakStartDate,
                longestStreakDays,
                averageStreakDuration: avgDurationFormatted,
                level: level,
                title: title,
                xp: currentStreakXp,
                goal: currentData.goal || null,
                goalDate: currentData.goalDate || null,
                logs: publicLogs,
                unlockedAchievements,
                lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
            };

            try {
                await db.collection('publicProfiles').doc(user.uid).set(publicData);
                alert('Your public profile has been updated!');
            } catch (error) {
                console.error("Error updating public profile:", error);
                alert('Could not update public profile. Check console for errors.');
            }
        }
        
        async function handleUpdateUsername() {
            const user = auth.currentUser;
            if (!user) return;

            const newUsername = newUsernameInput.value.trim();
            usernameStatus.textContent = '';

            if (!newUsername) return;
            if (newUsername.length < 3 || newUsername.length > 15 || /\s/.test(newUsername)) {
                usernameStatus.textContent = "Must be 3-15 characters, no spaces.";
                return;
            }
            if (userData && userData.username && newUsername.toLowerCase() === userData.username.toLowerCase()) {
                return;
            }
            
            const newUsernameLower = newUsername.toLowerCase();
            const usernamesCollection = db.collection('usernames');
            const userRef = db.collection('users').doc(user.uid);

            try {
                await db.runTransaction(async (transaction) => {
                    const newUsernameRef = usernamesCollection.doc(newUsernameLower);
                    const newUsernameDoc = await transaction.get(newUsernameRef);

                    if (newUsernameDoc.exists) throw "This username is already taken.";
                    
                    if (userData.username) {
                        const oldUsernameRef = usernamesCollection.doc(userData.username.toLowerCase());
                        transaction.delete(oldUsernameRef);
                    }

                    transaction.set(newUsernameRef, { uid: user.uid });
                    transaction.update(userRef, { username: newUsername });
                });
                
                usernameStatus.style.color = '#27ff47';
                usernameStatus.textContent = "Username updated!";
                newUsernameInput.value = '';

            } catch (error) {
                console.error("Error updating username: ", error);
                usernameStatus.style.color = '#ff0000';
                usernameStatus.textContent = typeof error === 'string' ? error : "An error occurred.";
            } finally {
                 setTimeout(() => usernameStatus.textContent = '', 3000);
            }
        }


        function setAuthMode(isSignup) {
            isSignupMode = isSignup;
            authError.textContent = '';
            usernameInput.parentElement.classList.toggle('hidden', !isSignup);
            mainAuthBtn.textContent = isSignup ? 'Create Account' : 'Log In';
            toggleAuthModeBtn.textContent = isSignup ? 'Back to Log In' : 'Sign Up';
            passwordInput.setAttribute('autocomplete', isSignup ? 'new-password' : 'current-password');
        }
        
        toggleAuthModeBtn.addEventListener('click', () => setAuthMode(!isSignupMode));

        authForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const email = emailInput.value;
            const password = passwordInput.value;
            const username = usernameInput.value.trim();
            authError.textContent = '';

            try {
                if (isSignupMode) {
                    if (!username || username.length < 3 || username.length > 15 || /\s/.test(username)) {
                        throw new Error("Username must be 3-15 characters with no spaces.");
                    }
                    const usernameDoc = await db.collection('usernames').doc(username.toLowerCase()).get();
                    if (usernameDoc.exists) throw new Error("This username is already taken.");

                    const userCredential = await auth.createUserWithEmailAndPassword(email, password);
                    const user = userCredential.user;

                    const userRef = db.collection('users').doc(user.uid);
                    const usernameRef = db.collection('usernames').doc(username.toLowerCase());
                    
                    const batch = db.batch();
                    batch.set(userRef, { username, email: user.email, createdAt: firebase.firestore.FieldValue.serverTimestamp() });
                    batch.set(usernameRef, { uid: user.uid });
                    await batch.commit();
                } else {
                    await auth.signInWithEmailAndPassword(email, password);
                }
            } catch (error) {
                authError.textContent = error.message;
            }
        });

        exportBtn.addEventListener('click', exportToCsv);
        
        function setActiveTab(activeTab) {
            const tabs = {
                dashboard: { container: dashboardContainer },
                stats: { container: logbookContainer },
                achievements: { container: achievementsContainer },
                journal: { container: journalContainer },
                about: { container: aboutContainer },
                profile: { container: profileContainer },
            };

            allNavLinkBtns.forEach(btn => {
                btn.classList.remove('active');
                if(btn.dataset.tab === activeTab) {
                    btn.classList.add('active');
                }
            });

            Object.values(tabs).forEach(t => t.container.classList.add('hidden'));

            if(tabs[activeTab]) {
                tabs[activeTab].container.classList.remove('hidden');
                if(activeTab === 'achievements') renderAchievements();
                if(activeTab === 'stats') renderStreakHistory();
            }
        }
        
        // --- Streak History Functions ---

        /**
         * Renders the list of completed streaks on the Stats page.
         */
        function renderStreakHistory() {
            streakHistoryContainer.innerHTML = '';
            
            const activeStreak = userLogs.find(doc => doc.data() && !doc.data().endDate);
            const completedStreaks = userLogs
                .filter(doc => doc.data() && doc.data().endDate)
                .sort((a, b) => parseDate(b.data().startDate) - parseDate(a.data().startDate));
            
            const streaksToRender = activeStreak ? [activeStreak, ...completedStreaks] : completedStreaks;

            if (streaksToRender.length === 0) {
                streakHistoryContainer.innerHTML = '<p style="text-align: center; font-style: italic;">No streaks to display yet.</p>';
                return;
            }

            streaksToRender.forEach(doc => {
                const log = doc.data();
                const isCurrent = !log.endDate;
                let headerText, detailText, duration;
                
                if (isCurrent) {
                    const currentXp = calculateXpForStreak(doc, allJournalEntries);
                    const currentRankData = calculateLevelFromXp(currentXp);
                    headerText = `Current Streak (Started: ${formatShortDate(log.startDate)})`;
                    detailText = `Current Rank: Lvl ${currentRankData.level} - ${currentRankData.title} (${currentXp} XP)`;
                } else {
                    duration = calculateDuration(log.startDate, log.endDate);
                    const finalXp = log.finalXp !== undefined ? log.finalXp : calculateXpForStreak(doc, allJournalEntries);
                    const finalRankData = calculateLevelFromXp(finalXp);
                    const finalRankText = log.finalRank || `Lvl ${finalRankData.level} - ${finalRankData.title}`;
                    headerText = `<span>${formatShortDate(log.startDate)} - ${formatShortDate(log.endDate)}</span><span>${duration.formatted}</span>`;
                    detailText = `Final Rank: ${finalRankText} (${finalXp} XP)`;
                }

                const item = document.createElement('div');
                item.className = 'streak-history-item';
                item.dataset.streakId = doc.id;
                item.innerHTML = `
                    <div class="streak-history-item-clickable">
                        <div class="streak-history-item-header">${headerText}</div>
                        <div class="streak-history-item-details">${detailText}</div>
                    </div>
                    <div class="streak-detail-view"></div>
                `;
                streakHistoryContainer.appendChild(item);
            });
        }
        
        /**
         * Generates and displays a detailed XP log for a selected streak.
         */
        function generateXpHistoryHtml(streakDoc) {
            const streakData = streakDoc.data();
            const startDate = parseDate(streakData.startDate);
            const endDate = parseDate(streakData.endDate) || new Date(); 

            let xpEvents = [];
            const duration = calculateDuration(startDate, endDate);

            // 1. Gather XP from streak duration
            for (let d = 1; d <= duration.days; d++) {
                 let eventDate = new Date(startDate);
                 eventDate.setDate(eventDate.getDate() + d);
                 xpEvents.push({
                     date: eventDate,
                     points: 10,
                     reason: `Day ${d} maintained`
                 });
            }

            // 2. Gather XP from journal entries
            const journalEntriesDuringStreak = allJournalEntries.filter(doc => {
                const entryDate = parseDate(doc.data().date);
                return entryDate >= startDate && entryDate <= endDate;
            });
            journalEntriesDuringStreak.forEach(doc => {
                xpEvents.push({
                    date: parseDate(doc.data().date),
                    points: 5,
                    reason: 'Journal Entry'
                });
            });

            // 3. Gather XP from achievements
            ACHIEVEMENTS_CONFIG.forEach(achievement => {
                 if (duration.days >= achievement.days) {
                    let eventDate = new Date(startDate);
                    eventDate.setDate(eventDate.getDate() + achievement.days);
                    xpEvents.push({
                         date: eventDate,
                         points: 10,
                         reason: `Badge: ${achievement.name}`
                    });
                 }
            });

            // 4. Sort events and build HTML string
            xpEvents.sort((a, b) => a.date - b.date);

            if(xpEvents.length === 0){
                 return '<ul class="xp-log-list"><li>No XP events recorded for this period.</li></ul>';
            }
            
            let runningTotal = 0;
            const listItemsHtml = xpEvents.map(event => {
                runningTotal += event.points;
                return `
                    <li>
                        <span class="xp-log-date">${formatShortDate(event.date)}</span>
                        <span class="xp-log-reason">${event.reason}</span>
                        <span class="xp-log-points">+${event.points} XP (Total: ${runningTotal})</span>
                    </li>
                `;
            }).join('');
            
            return `<ul class="xp-log-list">${listItemsHtml}</ul>`;
        }


        function addMainAppEventListeners() {
            if (mainAppListenersAdded) return;

            document.querySelectorAll('.sidebar-nav, .mobile-nav').forEach(nav => {
                nav.addEventListener('click', (e) => {
                    const navLink = e.target.closest('.nav-link');
                    if(navLink) {
                        setActiveTab(navLink.dataset.tab);
                    }
                });
            });
            
            newLogoutBtn.addEventListener('click', () => auth.signOut());

            publicProfileToggle.addEventListener('change', async (e) => {
                const isPublic = e.target.checked;
                const user = auth.currentUser;
                if (!user) return;
                try {
                    await db.collection('users').doc(user.uid).update({ isPublic });
                    publicLinkContainer.classList.toggle('hidden', !isPublic);
                } catch (error) {
                    console.error("Error updating public profile status:", error);
                }
            });
            
            copyPublicLinkBtn.addEventListener('click', () => {
                publicLinkDisplay.select();
                document.execCommand('copy');
                copyPublicLinkBtn.textContent = 'Copied!';
                setTimeout(() => {
                    copyPublicLinkBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>`;
                }, 2000);
            });

            refreshPublicDataBtn.addEventListener('click', () => updatePublicData(auth.currentUser));
            saveUsernameBtn.addEventListener('click', handleUpdateUsername);

            tableHeaders.forEach(header => {
                header.addEventListener('click', () => {
                    const key = header.dataset.sortKey;
                    if (sortState.key === key) {
                        sortState.direction = sortState.direction === 'asc' ? 'desc' : 'asc';
                    } else {
                        sortState.key = key;
                        sortState.direction = 'desc';
                    }
                    renderLogs();
                });
            });

            viewMoreBtn.addEventListener('click', () => {
                visibleLogEntriesCount += 10;
                renderLogs();
            });
            
            goalInput.addEventListener('input', () => {
                if (isUpdatingGoal) return;
                isUpdatingGoal = true;

                const goalDays = parseInt(goalInput.value, 10);
                
                if (goalDays > 0) {
                    updateGoalProgress(goalDays); // Update progress bar
                    const currentStreak = userLogs.find(doc => !doc.data().endDate);
                    if (currentStreak) {
                        const projectedDate = parseDate(currentStreak.data().startDate);
                        projectedDate.setDate(projectedDate.getDate() + goalDays);
                        const formattedDate = projectedDate.toISOString().split('T')[0];
                        
                        goalDateInput.value = formattedDate; 

                        goalDate.textContent = `Goal of ${goalDays} days reached on: ${formatDate(formattedDate)}`;
                        renderCondensedCalendar(displayedYear, userLogs, formattedDate, '#condensed-calendar-container', '#current-year-label');
                    } else {
                        goalDateInput.value = ''; // Clear date if no active streak
                        goalDate.textContent = 'Start a streak to see goal date.';
                        renderCondensedCalendar(displayedYear, userLogs, null, '#condensed-calendar-container', '#current-year-label');
                    }
                } else {
                    // Clear everything if input is invalid
                    goalDateInput.value = '';
                    updateGoalProgress(null);
                    goalDate.textContent = '';
                    renderCondensedCalendar(displayedYear, userLogs, null, '#condensed-calendar-container', '#current-year-label');
                }
                isUpdatingGoal = false;
            });

            goalDateInput.addEventListener('input', () => {
                if (isUpdatingGoal) return;
                isUpdatingGoal = true;

                const goalDateValue = goalDateInput.value;
                goalInput.value = ''; // Mutually exclusive

                if (goalDateValue) {
                    const currentStreak = userLogs.find(doc => !doc.data().endDate);
                    if (currentStreak) {
                        const startDate = parseDate(currentStreak.data().startDate);
                        const targetDate = parseDate(goalDateValue);
                        const totalGoalDays = calculateDuration(startDate, targetDate).days;

                        if (totalGoalDays > 0) {
                            goalInput.value = totalGoalDays; // Set the days input for consistency
                            updateGoalProgress(totalGoalDays);
                             goalDate.textContent = `Goal set for: ${formatDate(goalDateValue)}`;
                        } else {
                             updateGoalProgress(null);
                             goalDate.textContent = 'Date must be in the future.';
                        }
                    } else {
                        updateGoalProgress(null);
                        goalDate.textContent = 'Start a streak to set a goal date.';
                    }
                    renderCondensedCalendar(displayedYear, userLogs, goalDateValue, '#condensed-calendar-container', '#current-year-label');
                } else {
                    // Clear everything if input is invalid
                    updateGoalProgress(null);
                    goalDate.textContent = '';
                    renderCondensedCalendar(displayedYear, userLogs, null, '#condensed-calendar-container', '#current-year-label');
                }

                isUpdatingGoal = false;
            });
            
            document.getElementById('set-goal-btn').addEventListener('click', async () => {
                const user = auth.currentUser;
                if (!user) return;
                
                const goalDays = goalInput.value ? parseInt(goalInput.value, 10) : null;
                const goalDateValue = goalDateInput.value || null;

                const goalData = {
                    goal: goalDays,
                    goalDate: goalDateValue
                };
                
                await db.collection('users').doc(user.uid).set(goalData, { merge: true });
            });

            document.getElementById('prev-year-btn').addEventListener('click', () => {
                displayedYear--;
                renderCondensedCalendar(displayedYear, userLogs, userData.goalDate, '#condensed-calendar-container', '#current-year-label');
            });
            document.getElementById('next-year-btn').addEventListener('click', () => {
                if (displayedYear < new Date().getFullYear()) {
                    displayedYear++;
                    renderCondensedCalendar(displayedYear, userLogs, userData.goalDate, '#condensed-calendar-container', '#current-year-label');
                }
            });
            
            journalSearchInput.addEventListener('input', applyAndRenderJournalFilters);
            journalFilterStartDate.addEventListener('change', applyAndRenderJournalFilters);
            journalFilterEndDate.addEventListener('change', applyAndRenderJournalFilters);
            journalFilterClearBtn.addEventListener('click', () => {
                journalSearchInput.value = '';
                journalFilterStartDate.value = '';
                journalFilterEndDate.value = '';
                applyAndRenderJournalFilters();
            });

            entryForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const startDateString = startDateInput.value;
                const endDateString = endDateInput.value;
                const user = auth.currentUser;
                
                const hasOngoing = userLogs.some(doc => !doc.data().endDate);
                if (hasOngoing && !endDateString) {
                    alert("You can only have one ongoing streak at a time. End your current one first.");
                    return;
                }
                if (endDateString && startDateString >= endDateString) {
                    alert("End date must be after start date.");
                    return;
                }

                if (user && startDateString) {
                    const startDate = new Date(startDateString);
                    const endDate = endDateString ? new Date(endDateString) : null;

                    await db.collection('users').doc(user.uid).collection('logs').add({ 
                        startDate: firebase.firestore.Timestamp.fromDate(startDate),
                        endDate: endDate ? firebase.firestore.Timestamp.fromDate(endDate) : null 
                    });
                    entryForm.reset();
                }
            });

            journalForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const text = journalInput.value.trim();
                const user = auth.currentUser;

                if (user && text) {
                    await db.collection('users').doc(user.uid).collection('journal').add({
                        text,
                        date: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    showXpToast(5, 'Journal Entry');
                    journalInput.value = '';
                }
            });
            
            logTableBody.addEventListener('click', async (e) => {
                const user = auth.currentUser;
                if (!user) return;
                const row = e.target.closest('tr');
                if (!row) return;
                const docId = row.dataset.id;
                const logRef = db.collection('users').doc(user.uid).collection('logs').doc(docId);

                if (e.target.classList.contains('delete-btn')) {
                    if (confirm('Are you sure you want to delete this entry?')) {
                       await logRef.delete();
                    }
                } else if (e.target.classList.contains('edit-btn')) {
                    currentEditingLogId = docId;
                    renderLogs();
                } else if (e.target.classList.contains('save-btn')) {
                    const newStartDateString = row.querySelector('.edit-start-input').value;
                    const newStartDate = new Date(newStartDateString);
                    const newStartDateAsTimestamp = firebase.firestore.Timestamp.fromDate(newStartDate);
                    
                    const logData = userLogs.find(log => log.id === docId)?.data();

                    if (logData && logData.endDate) {
                        // Editing a completed streak
                        const newEndDateString = row.querySelector('.edit-end-input').value;
                        const newEndDate = new Date(newEndDateString);
                        
                        if (newEndDate <= newStartDate) {
                            alert("End date and time must be after the start date and time.");
                            return;
                        }
                        const newEndDateAsTimestamp = firebase.firestore.Timestamp.fromDate(newEndDate);
                        await logRef.update({ startDate: newStartDateAsTimestamp, endDate: newEndDateAsTimestamp });
                    } else {
                        // Editing an active streak
                        await logRef.update({ startDate: newStartDateAsTimestamp });
                    }
                    
                    currentEditingLogId = null;
                } else if (e.target.classList.contains('cancel-btn')) {
                    currentEditingLogId = null;
                    renderLogs();
                } else if (e.target.classList.contains('end-streak-btn')) {
                    if (confirm('Are you sure you want to end this streak and start a new one?')) {
                        const now = firebase.firestore.Timestamp.now();
                        const batch = db.batch();
                        
                        // --- NEW: Calculate and store final XP/Rank ---
                        const streakToEndDoc = userLogs.find(doc => doc.id === docId);
                        const finalXp = calculateXpForStreak(streakToEndDoc, allJournalEntries);
                        const { level, title } = calculateLevelFromXp(finalXp);
                        const finalRank = `Lvl ${level} - ${title}`;

                        // 1. Update the current streak with the end time and final stats
                        batch.update(logRef, { 
                            endDate: now,
                            finalXp: finalXp,
                            finalRank: finalRank
                        });

                        // 2. Create a new streak that starts at the same time
                        const newStreakRef = db.collection('users').doc(user.uid).collection('logs').doc();
                        batch.set(newStreakRef, { startDate: now, endDate: null });

                        await batch.commit();
                        showXpToast(0, 'Streak Ended - XP Reset');
                    }
                }
            });

            journalEntriesContainer.addEventListener('click', async (e) => {
                const user = auth.currentUser;
                if (!user) return;
                const entryDiv = e.target.closest('.journal-entry');
                if (!entryDiv) return;
                const docId = entryDiv.dataset.id;
                const entryRef = db.collection('users').doc(user.uid).collection('journal').doc(docId);
                
                if (e.target.classList.contains('delete-btn')) {
                    if(confirm('Delete this journal entry?')) await entryRef.delete();
                } else if (e.target.classList.contains('edit-btn')) {
                    const contentDiv = entryDiv.querySelector('.journal-entry-content');
                    const currentText = contentDiv.querySelector('p').textContent;
                    contentDiv.innerHTML = `<textarea class="journal-edit-area">${currentText}</textarea><button class="save-btn">Save</button>`;
                } else if (e.target.classList.contains('save-btn')) {
                    const newText = entryDiv.querySelector('.journal-edit-area').value.trim();
                    if (newText) await entryRef.update({ text: newText });
                }
            });
            
             // --- Event listener for streak history accordion ---
            streakHistoryContainer.addEventListener('click', (e) => {
                const clickableArea = e.target.closest('.streak-history-item-clickable');
                if (!clickableArea) return;

                const item = clickableArea.parentElement;
                const detailView = item.querySelector('.streak-detail-view');
                const isOpen = detailView.classList.contains('visible');

                // Close any other open items
                document.querySelectorAll('.streak-detail-view.visible').forEach(openDetail => {
                    if (openDetail !== detailView) {
                        openDetail.classList.remove('visible');
                        openDetail.parentElement.classList.remove('active');
                        openDetail.innerHTML = ''; // Clear content to save memory
                    }
                });

                // If the clicked item was already open, close it. Otherwise, open it.
                if (isOpen) {
                    detailView.classList.remove('visible');
                    item.classList.remove('active');
                    detailView.innerHTML = '';
                } else {
                    item.classList.add('active');
                    const streakId = item.dataset.streakId;
                    const selectedStreakDoc = userLogs.find(doc => doc.id === streakId);
                    
                    if (selectedStreakDoc) {
                        // Generate and inject content, then show
                        detailView.innerHTML = generateXpHistoryHtml(selectedStreakDoc);
                        detailView.classList.add('visible');
                    }
                }
            });

            mainAppListenersAdded = true;
        }


        function initializeAppForUser(user) {
            authContainer.classList.add('hidden');
            appLayout.classList.remove('hidden');
            addMainAppEventListeners();

            const logsCollection = db.collection('users').doc(user.uid).collection('logs');
            const journalCollection = db.collection('users').doc(user.uid).collection('journal');
            const userDocRef = db.collection('users').doc(user.uid);

            logsCollection.orderBy('startDate', 'desc').onSnapshot(snapshot => {
                userLogs = snapshot.docs.filter(doc => doc.data().startDate);
                renderLogs();
                calculateStats();
                renderAchievements();
                calculateAndSetCurrentStreakXp();
                renderStreakHistory(); // Render history whenever logs change
            });
            
            journalCollection.orderBy('date', 'desc').onSnapshot(snapshot => {
                allJournalEntries = snapshot.docs;
                applyAndRenderJournalFilters(); 
                calculateAndSetCurrentStreakXp();
            });

            userDocRef.onSnapshot((doc) => {
                if (doc.exists) {
                    userData = doc.data();
                    userProfileDisplay.textContent = userData.username || user.email;
                    
                    const isPublic = !!userData.isPublic;
                    publicProfileToggle.checked = isPublic;
                    publicLinkContainer.classList.toggle('hidden', !isPublic);
                    if(isPublic && userData.username) {
                        publicLinkDisplay.value = `${window.location.origin}${window.location.pathname}?username=${userData.username}`;
                    } else {
                        publicLinkDisplay.value = '';
                    }

                    if (!isUpdatingGoal) {
                        goalInput.value = userData.goal || '';
                        goalDateInput.value = userData.goalDate || '';
                        
                        if (userData.goal) {
                            updateGoalProgress(userData.goal);
                            const currentStreak = userLogs.find(doc => !doc.data().endDate);
                            if (currentStreak) {
                                const projectedDate = parseDate(currentStreak.data().startDate);
                                projectedDate.setDate(projectedDate.getDate() + userData.goal);
                                const formattedDate = projectedDate.toISOString().split('T')[0];
                                goalDate.textContent = `Goal of ${userData.goal} days reached on: ${formatDate(formattedDate)}`;
                                renderCondensedCalendar(displayedYear, userLogs, formattedDate, '#condensed-calendar-container', '#current-year-label');
                            } else { 
                                goalDate.textContent = 'Start a streak to see goal date.';
                                renderCondensedCalendar(displayedYear, userLogs, null, '#condensed-calendar-container', '#current-year-label');
                            } 
                        } else if (userData.goalDate) {
                            const currentStreak = userLogs.find(doc => !doc.data().endDate);
                            if(currentStreak){
                                const startDate = parseDate(currentStreak.data().startDate);
                                const targetDate = parseDate(userData.goalDate);
                                const totalGoalDays = calculateDuration(startDate, targetDate).days;
                                if (totalGoalDays > 0) {
                                    updateGoalProgress(totalGoalDays);
                                }
                            }
                            goalDate.textContent = `Goal set for: ${formatDate(userData.goalDate)}`;
                            renderCondensedCalendar(displayedYear, userLogs, userData.goalDate, '#condensed-calendar-container', '#current-year-label');
                        } else {
                            updateGoalProgress(null);
                            goalDate.textContent = '';
                            renderCondensedCalendar(displayedYear, userLogs, null, '#condensed-calendar-container', '#current-year-label');
                        }
                    }
                }
            });
            
            setActiveTab('dashboard');
        }

        function showLoginScreen() {
            [appLayout, publicViewContainer].forEach(c => c.classList.add('hidden'));
            authContainer.classList.remove('hidden');
            setAuthMode(false);
        }
        
        function startApp() {
            const urlParams = new URLSearchParams(window.location.search);
            const publicUsername = urlParams.get('username');
            
            auth.onAuthStateChanged(user => {
                loadingContainer.classList.add('hidden');
                if (publicUsername) {
                    publicViewContainer.classList.remove('hidden');
                    db.collection('usernames').doc(publicUsername.toLowerCase()).get()
                        .then(usernameDoc => {
                            if (usernameDoc.exists) {
                                const uid = usernameDoc.data().uid;
                                db.collection('publicProfiles').doc(uid).onSnapshot(profileDoc => {
                                    if (profileDoc.exists) {
                                        renderPublicView(profileDoc.data());
                                    } else {
                                         publicViewContainer.innerHTML = `<p style="text-align:center;">Could not load profile for "${publicUsername}". The owner may need to refresh their public data from the Profile page.</p>`;
                                    }
                                }, error => {
                                    console.error("Error with public profile listener:", error);
                                    publicViewContainer.innerHTML = `<p style="text-align:center;">An error occurred while loading the profile.</p>`;
                                });
                            } else {
                                 // This was causing an unhandled rejection. Now it sets the HTML directly.
                                publicViewContainer.innerHTML = `<p style="text-align:center;">Could not load profile for "${publicUsername}". This user does not exist.</p>`;
                            }
                        })
                        .catch(error => {
                            console.error("Error loading public profile:", error);
                            publicViewContainer.innerHTML = `<p style="text-align:center;">Could not load profile for "${publicUsername}". It may not exist or may not be public.</p>`;
                        });
                } else if (user) {
                    initializeAppForUser(user);
                } else {
                    showLoginScreen();
                }
            });
        }
        
        startApp();
    </script>
</body>
</html>

