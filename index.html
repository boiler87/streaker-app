<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Streaker</title>
    <!-- FAVICON LINK -->
    <link rel="icon" type="image/png" href="https://raw.githubusercontent.com/rynwynk/streaker-app/main/logo%20only.png">
    <!-- GOOGLE FONTS LINK -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
        }
        @font-face {
            font-family: 'AppleIIe';
            src: url('https://daniellopes.com.br/apple-ii/AppleIIe.ttf') format('truetype');
        }

        body {
            font-family: 'AppleIIe', monospace;
            background-color: #000;
            color: #27ff47;
            margin: 0;
            padding: 0;
        }
        
        /* --- Main App Layout --- */
        .app-layout {
            display: flex;
            width: 100%;
            height: 100vh;
        }

        .main-content {
            flex-grow: 1;
            padding: 20px;
            overflow-y: auto;
            margin-left: 65px; /* Space for the sidebar */
        }
        /* --- END: Main App Layout --- */

        .container {
            background-color: #000;
            padding: 30px;
            border: 2px solid #27ff47;
            box-shadow: 0 0 10px #27ff47;
            width: 100%;
            max-width: 900px;
            margin: 0 auto; /* Center the container */
        }
        .hidden {
            display: none !important; /* The definitive fix */
        }
        
        .logo-and-title {
            display: flex;
            align-items: center;
            gap: 15px; /* Increased gap */
        }
        .logo-and-title div {
           display: flex;
           flex-direction: column;
        }
        .logo-and-title h2 {
            font-family: 'Press Start 2P', cursive;
            margin-bottom: 5px; /* Space between title and subtitle */
        }
        .subtitle {
            font-size: 0.8em;
            color: #27ff47;
            margin: 0;
        }

        h2, h3, h4 {
            color: #27ff47;
            text-align: left;
            margin: 0;
            font-size: 2em;
        }
        h3 { font-size: 1.5em; margin-top: 25px; margin-bottom: 10px; }
        h4 { font-size: 1.2em; margin-top: 20px; margin-bottom: 10px; }
        #about-container ul { padding-left: 20px; }
        #about-container li { margin-bottom: 10px; }


        .logo {
            height: 60px; /* Adjusted height */
            width: auto;
            image-rendering: pixelated;
        }
        .header-container {
            margin-bottom: 20px;
        }
        form {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        input[type="email"],
        input[type="password"],
        input[type="date"],
        input[type="datetime-local"],
        input[type="number"],
        input[type="search"],
        input[type="text"] {
            padding: 12px;
            border: 2px solid #27ff47;
            background-color: #000;
            color: #27ff47;
            flex-grow: 1;
            font-size: 16px;
            font-family: 'AppleIIe', monospace;
        }
        textarea {
            padding: 12px;
            border: 2px solid #27ff47;
            background-color: #000;
            color: #27ff47;
            flex-basis: 100%;
            min-height: 120px;
            resize: vertical;
            font-family: 'AppleIIe', monospace;
            font-size: 16px;
        }
        button {
            padding: 12px 20px;
            border: 2px solid #27ff47;
            background-color: #27ff47;
            color: #000;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        button:hover {
            background-color: #1aff32;
        }
        button:disabled {
            background-color: #111;
            color: #444;
            border-color: #444;
            cursor: not-allowed;
        }
        .button-group {
            display: flex;
            gap: 10px;
        }

        /* --- START LOGIN PAGE REDESIGN --- */
        #auth-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%; /* Make auth container full width */
            padding: 20px;
        }

        #auth-container .logo-and-title {
            justify-content: center;
            margin-bottom: 40px;
        }
        
        .terminal-window {
            width: 100%;
            max-width: 450px;
            border: 2px solid #27ff47;
            background-color: #080808;
            padding: 0;
            box-shadow: 0 0 15px rgba(39, 255, 71, 0.5);
        }

        .terminal-header {
            background-color: #27ff47;
            color: #000;
            padding: 5px 10px;
            font-weight: bold;
            text-align: center;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8em;
        }
        
        #auth-form {
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: flex-start;
        }
        
        #auth-form .form-row {
             width: 100%;
        }

        #auth-form label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        
        #auth-form input {
            width: 100%;
        }
        
        #auth-form .button-group {
            width: 100%;
            justify-content: space-between;
        }

        #auth-form .button-group button {
            flex-grow: 1;
            flex-basis: 0;
        }
        
        .blinking-cursor {
            font-weight: bold;
            animation: blink 1s step-end infinite;
        }

        @keyframes blink {
            from, to { color: transparent; }
            50% { color: #27ff47; }
        }
        /* --- END LOGIN PAGE REDESIGN --- */


        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .error-message {
            color: #ff0000;
            text-align: center;
            margin-top: 10px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            border: 2px solid #27ff47;
            margin-top: 20px;
        }
        th, td {
            padding: 15px;
            text-align: left;
            border: 1px solid #27ff47;
        }
        th {
            background-color: #111;
            color: #27ff47;
            font-weight: 600;
            cursor: pointer;
        }
        th:hover {
            background-color: #333;
        }
        th .sort-icon {
            margin-left: 5px;
            font-size: 0.8em;
        }
        tr:hover {
            background-color: #001;
        }
        .delete-btn {
            background-color: #ff0000;
            color: #000;
        }
        .delete-btn:hover {
            background-color: #cc0000;
        }
        
        .edit-btn {
            background-color: #27ff47;
            color: #000;
            font-size: 14px;
            padding: 8px 12px;
            margin-right: 5px;
        }
        .edit-btn:hover {
            background-color: #1aff32;
        }

        .save-btn {
            background-color: #27ff47;
            color: #000;
        }
        .save-btn:hover {
            background-color: #1aff32;
        }
        .cancel-btn {
            background-color: #ff0000;
            color: #000;
        }
        .cancel-btn:hover {
            background-color: #cc0000;
        }

        .end-streak-btn {
            background-color: #27ff47;
            color: #000;
            font-size: 14px;
            padding: 8px 12px;
        }
        .end-streak-btn:hover {
            background-color: #1aff32;
        }

        #user-profile-display {
            word-break: break-all;
            text-align: center;
            font-weight: bold;
            font-size: 1.2em;
        }

        .username-change-section {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            align-items: center;
        }
        #new-username-input {
            flex-grow: 1;
            font-size: 0.9em;
            padding: 8px;
        }
        #save-username-btn {
            padding: 8px 12px;
            font-size: 0.9em;
        }
        #username-status {
            flex-basis: 100%;
            text-align: left;
            margin: 5px 0 0 0;
            font-size: 0.8em;
        }

        #new-logout-btn {
            padding: 8px 12px;
            font-size: 14px;
            background-color: transparent;
            color: #27ff47;
            border: 2px solid #27ff47;
        }
        #new-logout-btn:hover {
            background-color: #27ff47;
            color: #000;
        }

        .toggle-switch {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 10px;
        }
        .toggle-switch label {
            cursor: pointer;
            white-space: nowrap;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            width: 40px;
            height: 20px;
            background-color: #333;
            border: 1px solid #27ff47;
            cursor: pointer;
            position: relative;
            transition: background-color 0.2s;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 2px;
            bottom: 2px;
            background-color: #27ff47;
            transition: .4s;
        }
        input:checked + .slider {
            background-color: #111;
        }
        input:checked + .slider:before {
            transform: translateX(20px);
        }
        #public-link-container {
            margin-top: 10px;
        }
        #public-link-display {
            flex-grow: 1;
        }
        

        .view-more-container {
            text-align: center;
            margin-top: 20px;
        }
        
        .stats-section-header {
            margin-top: 40px;
            text-align: center;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
            text-align: center;
        }
        
        .stat-card {
            background-color: #111;
            padding: 20px;
            border: 2px solid #27ff47;
        }
        
        .stat-card h3 {
            margin: 0 0 10px 0;
            color: #27ff47;
            text-align: center;
        }
        
        .stat-card p {
            font-size: clamp(1.4em, 4vw, 2em);
            font-weight: bold;
            color: #27ff47;
            line-height: 1.2;
            min-height: 2.4em;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* --- Dynamic Streak Counter Styles --- */
        .streak-counter-layout {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        .digital-clock {
            font-family: 'Press Start 2P', cursive;
            font-size: 1.6em; 
            display: flex;
            align-items: baseline;
            justify-content: center;
            gap: 5px;
            color: #27ff47;
            text-shadow: 0 0 5px #27ff47;
            flex-shrink: 0;
        }
        .digital-clock span {
            display: inline-block;
            min-width: 1.2em;
            text-align: right;
        }
        .digital-clock .unit-label {
            font-size: 0.5em;
            align-self: flex-end;
            margin-left: -5px;
            margin-right: 5px;
        }
        .progress-bar-ascii {
            font-family: 'AppleIIe', monospace;
            font-size: 1.2em;
            text-align: center;
            margin-top: 0; 
            white-space: pre-wrap;
            color: #27ff47;
        }
        /* --- END: Dynamic Streak Counter Styles --- */

        .progress-bar-container {
            width: 100%;
            height: 20px;
            border: 1px solid #27ff47;
            background-color: #000;
            margin-top: 10px;
        }
        .progress-bar {
            height: 100%;
            background-color: #27ff47;
            transition: width 0.5s ease-in-out;
        }
        .progress-text {
            font-size: 1.2em;
            margin-top: 10px;
        }
        
        .achievements-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 20px;
            margin-top: 20px;
            text-align: center;
        }
        .badge-card {
            background-color: #111;
            padding: 20px;
            border: 2px solid #27ff47;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative; /* Added for tooltip positioning */
        }
        .badge-icon {
            font-size: 3em;
            color: #444;
            transition: color 0.5s ease;
        }
        .badge-icon.unlocked {
            color: #27ff47;
            text-shadow: 0 0 10px #27ff47;
        }
        .badge-name {
            margin-top: 10px;
            font-weight: bold;
        }

        .badge-tooltip {
            visibility: hidden;
            opacity: 0;
            width: max-content;
            max-width: 150px;
            background-color: #27ff47;
            color: #000;
            text-align: center;
            padding: 8px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.6em;
            
            position: absolute;
            z-index: 1;
            bottom: 105%; /* Position above the badge */
            left: 50%;
            transform: translateX(-50%);
            transition: opacity 0.3s ease;
            
            pointer-events: none;
        }
        
        .badge-tooltip::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #27ff47 transparent transparent transparent;
        }

        .badge-card:hover .badge-tooltip {
            visibility: visible;
            opacity: 1;
        }

        .journal-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
            border: 2px solid #27ff47;
            padding: 15px;
        }
        .journal-entry {
            background-color: #111;
            border: 2px solid #27ff47;
            padding: 20px;
            margin-bottom: 20px;
        }
        .journal-entry.pinned {
            border-left: 4px solid #ffd700;
        }
        .pin-btn {
            background-color: transparent;
            color: #ffd700;
            border-color: #ffd700;
        }
        .pin-btn:hover {
            background-color: rgba(255, 215, 0, 0.1);
        }
        .journal-entry-date {
            font-weight: bold;
            margin-bottom: 10px;
        }
        .journal-entry-text {
            white-space: pre-wrap;
            line-height: 1.5;
        }
        .journal-entry-actions {
            margin-top: 15px;
            display: flex;
            gap: 10px;
        }

        .checkin-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .checkin-group input[type="checkbox"] {
            width: 20px;
            height: 20px;
            flex-shrink: 0;
        }
        .checkin-group label {
            font-size: 1.1em;
        }

        #condensed-calendar-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
            border: 2px solid #27ff47;
            padding: 15px;
        }
        #public-condensed-calendar-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 20px;
            border: 2px solid #27ff47;
            padding: 15px;
        }
        .month-grid-container {
            padding: 10px;
        }
        .month-grid-title {
            text-align: center;
            font-size: 1em;
            margin-bottom: 10px;
        }
        .month-grid-dow, .month-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 3px;
        }
        .month-grid-dow div {
            text-align: center;
            font-size: 0.7em;
        }
        .month-grid-day {
            width: 100%;
            padding-bottom: 100%;
            position: relative;
            background-color: #1a1a1a;
        }
        .month-grid-day.active {
            background-color: #27ff47;
        }
        .month-grid-day.end {
            background-color: #ff8c00;
        }
        .month-grid-day.end-and-start {
             background: linear-gradient(135deg, #ff8c00 49%, #27ff47 51%);
        }
        .month-grid-day.goal-day {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .month-grid-day.goal-day::after {
            content: 'ðŸŽ¯';
            font-size: 0.8em;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .year-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .year-nav h2 {
            margin: 0;
        }
        .year-nav button {
            padding: 5px 10px;
            font-size: 1.2em;
            line-height: 1;
        }
        .calendar-view-toggle button {
            padding: 5px 10px;
            font-size: 0.8em;
            background-color: #111;
            color: #27ff47;
        }
        .calendar-view-toggle button.active {
            background-color: #27ff47;
            color: #000;
        }

        #goal-progress-container.stat-card {
             padding: 15px;
        }

        .goal-inputs {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 20px;
        }
        .goal-input-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .goal-inputs label {
            font-size: 0.9em;
        }
        .goal-inputs input {
            flex-grow: 1;
            min-width: 80px;
            padding: 8px;
        }
        .goal-inputs span {
            font-style: italic;
        }

        #rank-projection-select {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border: 2px solid #27ff47;
            background-color: #000;
            color: #27ff47;
            font-family: 'AppleIIe', monospace;
            font-size: 0.9em;
        }
        #rank-projection-select option {
            background-color: #000;
            color: #27ff47;
        }

        /* --- Sidebar Navigation (Desktop) --- */
        .sidebar-nav {
            position: fixed;
            top: 0;
            left: 0;
            height: 100vh;
            width: 65px;
            background-color: #000;
            border-right: 2px solid #27ff47;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 20px;
            gap: 15px;
            z-index: 1000;
        }
        .nav-link {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: none;
            border: none;
            color: #27ff47;
            cursor: pointer;
            padding: 10px 5px;
            width: 100%;
            text-align: center;
            transition: background-color 0.2s;
        }
        .nav-link svg {
            width: 28px;
            height: 28px;
            fill: currentColor;
            margin-bottom: 5px;
        }
        .nav-link-label {
            font-size: 0.6em;
            font-family: 'Press Start 2P', cursive;
        }
        .nav-link:hover {
            background-color: #111;
        }
        .nav-link.active {
            background-color: #27ff47;
            color: #000;
        }
        /* --- END: Sidebar Navigation --- */

        /* --- Bottom Navigation (Mobile) --- */
        .mobile-nav {
            display: none; /* Hidden by default */
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: #000;
            border-top: 2px solid #27ff47;
            z-index: 1000;
            justify-content: space-around;
        }
        .mobile-nav .nav-link {
            padding: 8px;
            flex-grow: 1;
        }
        /* --- END: Bottom Navigation --- */
        
        /* --- Gamification Styles --- */
        #xp-toast {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #27ff47;
            color: #000;
            padding: 10px 20px;
            border: 2px solid #000;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8em;
            z-index: 2000;
            opacity: 0;
            transition: opacity 0.5s, bottom 0.5s;
        }
        #levels-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.9);
            z-index: 3000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
        }
        .clickable-level {
            cursor: pointer;
            transition: color 0.2s;
        }
        .clickable-level:hover {
            color: #fff;
        }
        #levels-modal-content table {
            font-size: 0.9em;
            margin-top: 0;
        }
        @keyframes level-up-glow {
            from { text-shadow: 0 0 10px #27ff47; }
            to { text-shadow: 0 0 30px #1aff32; }
        }
        /* --- END: Gamification Styles --- */

        /* --- Streak History Styles --- */
        #streak-history-container {
            margin-top: 20px;
        }
        .streak-history-item {
            background-color: #111;
            border: 2px solid #27ff47;
            margin-bottom: 10px;
            transition: background-color 0.2s;
        }
        .streak-history-item-clickable {
            padding: 15px;
            cursor: pointer;
        }
        .streak-history-item-clickable:hover {
            background-color: #1a1a1a;
        }
        .streak-history-item.active {
            border-color: #1aff32;
            background-color: #0a2a0a;
        }
        .streak-history-item-header {
            display: flex;
            justify-content: space-between;
            font-weight: bold;
            flex-wrap: wrap;
        }
        .streak-history-item-details {
            font-size: 0.9em;
            color: #aaa;
        }

        /* Accordion Detail View */
        .streak-detail-view {
            max-height: 0;
            overflow: hidden;
            opacity: 0;
            transition: max-height 0.4s ease-out, padding 0.4s ease-out, opacity 0.3s ease-out;
            padding: 0 15px;
            background-color: #080808;
            border-top: 1px dashed #222;
        }

        .streak-detail-view.visible {
            max-height: 400px; /* Allow for scrolling */
            opacity: 1;
            padding: 15px;
            overflow-y: auto;
        }
        
        .xp-log-list {
            list-style: none;
            padding: 0;
            margin: 0;
            font-size: 0.9em;
        }
        .xp-log-list li {
            padding: 8px 0;
            border-bottom: 1px dashed #222;
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
        }
        .xp-log-list li:last-child {
            border-bottom: none;
        }
        .xp-log-date {
            color: #aaa;
            flex-basis: 100px;
        }
        .xp-log-reason {
            flex-grow: 1;
        }
        .xp-log-points {
            font-weight: bold;
        }
        /* --- END: Streak History Styles --- */

        /* --- NEW: Data Export Styles --- */
        .export-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 15px;
        }


        @media (max-width: 768px) {
            .sidebar-nav {
                display: none;
            }
            .mobile-nav {
                display: flex;
            }
            .main-content {
                margin-left: 0;
            }
        }
        
        @media (max-width: 700px) { 
            #public-condensed-calendar-container {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 600px) {
            .header {
                flex-wrap: wrap;
                justify-content: center;
                gap: 15px;
            }

            body {
                padding: 0;
            }
            .main-content {
                padding: 10px;
                padding-bottom: 80px; /* Space for bottom nav */
            }
            .container {
                padding: 20px;
            }
            form {
                flex-direction: column;
            }
            .button-group {
                flex-direction: column;
            }
            table, thead, tbody, th, td, tr {
                display: block;
            }
            thead tr {
                position: absolute;
                top: -9999px;
                left: -9999px;
            }
            tr {
                border: 1px solid #27ff47;
                margin-bottom: 15px;
            }
            td {
                border: none;
                border-bottom: 1px solid #27ff47;
                position: relative;
                padding-left: 50%;
                text-align: right;
            }
            td:before {
                position: absolute;
                top: 0;
                left: 6px;
                width: 45%;
                padding-right: 10px;
                white-space: nowrap;
                content: attr(data-label);
                text-align: left;
                font-weight: bold;
                color: #27ff47;
            }
            td:last-child {
                border-bottom: 0;
            }
            .delete-btn {
                width: 100%;
                margin-top: 10px;
            }
            .start-date-cell:before { content: "Start Date"; }
            .end-date-cell:before { content: "End Date"; }
            .duration-cell:before { content: "Duration"; }
            .actions-cell:before { content: "Actions"; }

            #public-condensed-calendar-container {
                grid-template-columns: 1fr;
            }

            .journal-controls {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>

    <!-- NEW: Loading Screen -->
    <div id="loading-container" class="container" style="text-align: center; padding: 50px;">
        <p>LOADING STREAKER...</p>
    </div>
    
    <!-- NEW: Public View Container -->
    <div id="public-view-container" class="container hidden">
        <!-- Public, read-only content will be rendered here by JavaScript -->
    </div>


    <!-- Login/Signup Section -->
    <div id="auth-container" class="container hidden">
        <div class="logo-and-title" style="margin-bottom: 20px;">
            <img src="https://raw.githubusercontent.com/rynwynk/streaker-app/main/logo%20only.png" alt="Streaker Logo" class="logo">
            <div>
                <h2>Streaker</h2>
                <p class="subtitle">Satisfied Through Denial</p>
            </div>
        </div>
        <div class="terminal-window">
            <div class="terminal-header">USER AUTHENTICATION</div>
            <form id="auth-form">
                <div class="form-row hidden">
                    <label for="username-input">USERNAME:</label>
                    <input type="text" id="username-input" placeholder="ENTER USERNAME" autocomplete="username">
                </div>
                 <div class="form-row">
                    <label for="email-input">EMAIL:</label>
                    <input type="email" id="email-input" placeholder="ENTER EMAIL" required autocomplete="email">
                 </div>
                 <div class="form-row">
                    <label for="password-input">PASSWORD:</label>
                    <input type="password" id="password-input" placeholder="ENTER PASSWORD" required autocomplete="current-password">
                 </div>
                 <div style="width: 100%; text-align: left;">
                    > <span class="blinking-cursor">_</span>
                 </div>
                <div class="button-group">
                    <button type="submit" id="main-auth-btn">Log In</button>
                    <button type="button" id="toggle-auth-mode-btn">Sign Up</button>
                </div>
            </form>
        </div>
        <p id="auth-error" class="error-message"></p>
    </div>

    <!-- Main App Section with New Layout -->
    <div id="app-layout" class="app-layout hidden">
        
        <!-- Sidebar Nav -->
        <nav class="sidebar-nav">
             <!-- Dashboard -->
            <button class="nav-link active" data-tab="dashboard">
                <svg viewBox="0 0 24 24"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg>
                <span class="nav-link-label">DASH</span>
            </button>
            <!-- Stats -->
            <button class="nav-link" data-tab="stats">
                 <svg viewBox="0 0 24 24"><path d="M10 20h4V4h-4v16zm-6 0h4v-8H4v8zM16 9v11h4V9h-4z"/></svg>
                <span class="nav-link-label">STATS</span>
            </button>
            <!-- Achievements -->
             <button class="nav-link" data-tab="achievements">
                 <svg viewBox="0 0 24 24"><path d="M19 5h-2V3H7v2H5c-1.1 0-2 .9-2 2v1c0 2.55 1.92 4.63 4.39 4.94.63 1.5 1.74 2.77 3.11 3.5V19H7v2h10v-2h-3.5v-3.56c1.37-.73 2.48-2 3.11-3.5.07-.16.12-.33.18-.5.1-.3.15-.61.15-.93V7c0-1.1-.9-2-2-2zm-7 10c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3z"/></svg>
                <span class="nav-link-label">AWARDS</span>
            </button>
            <!-- Journal -->
            <button class="nav-link" data-tab="journal">
                 <svg viewBox="0 0 24 24"><path d="M18 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM6 4h5v8l-2.5-1.5L6 12V4z"/></svg>
                <span class="nav-link-label">JOURNAL</span>
            </button>
            <!-- About -->
            <button class="nav-link" data-tab="about">
                <svg viewBox="0 0 24 24"><path d="M11 18h2v-2h-2v2zm1-16C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm0-14c-2.21 0-4 1.79-4 4h2c0-1.1.9-2 2-2s2 .9 2 2c0 2-3 1.75-3 5h2c0-2.25 3-2.5 3-5 0-2.21-1.79-4-4-4z"/></svg>
                <span class="nav-link-label">ABOUT</span>
            </button>
            <!-- Profile -->
            <button class="nav-link" data-tab="profile">
                <svg viewBox="0 0 24 24"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>
                <span class="nav-link-label">PROFILE</span>
            </button>
        </nav>

        <div class="main-content">
            <div id="main-app-container" class="container">
                <div class="header">
                    <div class="logo-and-title">
                        <img src="https://raw.githubusercontent.com/rynwynk/streaker-app/main/logo%20only.png" alt="Streaker Logo" class="logo">
                        <div>
                            <h2>Streaker</h2>
                            <p class="subtitle">Satisfied Through Denial</p>
                        </div>
                    </div>
                    <button id="new-logout-btn">Log Out</button>
                </div>

                <!-- Dashboard Container -->
                <div id="dashboard-container">
                    <div class="stat-card" style="margin-bottom: 30px;">
                        <h3>Current Streak</h3>
                        <div class="streak-counter-layout">
                            <div id="current-streak-digital-clock" class="digital-clock">
                                <span id="streak-days">0</span><span class="unit-label">d</span>
                                <span id="streak-hours">00</span><span class="unit-label">h</span>
                                <span id="streak-minutes">00</span><span class="unit-label">m</span>
                                <span id="streak-seconds">00</span><span class="unit-label">s</span>
                            </div>
                            <pre id="daily-progress-bar" class="progress-bar-ascii"></pre>
                        </div>
                    </div>
                    <div id="goal-progress-container" class="stat-card" style="margin-bottom: 30px;">
                        <h3 style="font-size: 1.5em;">Goal Progress</h3>
                        <p class="subtitle" style="text-align: center; margin-bottom: 15px; font-size: 0.7em;">Tomorrow Never Cums</p>
                        <div id="progress-bar-container" class="progress-bar-container">
                            <div id="progress-bar" class="progress-bar"></div>
                        </div>
                        <p id="progress-text" class="progress-text" style="font-size: 1.2em; margin-top: 5px;">0%</p>
                        <p id="goal-date" style="font-size: 0.8em; margin-top: 5px; min-height: 1em;"></p>
                        <div class="goal-inputs">
                            <div class="goal-input-group">
                                <label for="goal-input">Days:</label>
                                <input type="number" id="goal-input" placeholder="e.g., 30">
                            </div>
                             <span>OR</span>
                            <div class="goal-input-group">
                                 <label for="goal-date-input">Date:</label>
                                 <input type="date" id="goal-date-input">
                            </div>
                        </div>
                         <button id="set-goal-btn" style="width: 100%; margin-top: 15px;">Set Goal</button>
                    </div>

                    <h2 class="stats-section-header" style="text-align: left;">Log Book</h2>
                    <p class="subtitle" style="text-align: left; margin-top: -5px; margin-bottom: 20px;">Edge. Deny. Repeat.</p>
                    <div style="display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 20px; align-items: center;">
                        <form id="entry-form" style="flex-grow: 1; margin-bottom: 0; display: flex; flex-wrap: wrap; gap: 10px;">
                            <input type="datetime-local" id="start-date-input" required style="flex-grow: 1;">
                            <input type="datetime-local" id="end-date-input" style="flex-grow: 1;">
                            <button type="submit">Add Entry</button>
                        </form>
                    </div>
                    
                    <div id="streak-history-container"></div>
                </div>

                <!-- Stats Container (formerly Logbook) -->
                <div id="logbook-container" class="hidden">
                    <h2 class="stats-section-header">All-Time Stats</h2>
                    <div class="stat-card" style="margin-bottom: 20px;">
                        <h3 id="rank-header-stats" class="clickable-level">Current Rank</h3>
                        <pre id="xp-progress-bar-stats" class="progress-bar-ascii">[XP: 0/100]</pre>
                        <p id="next-rank-estimate" style="font-size: 0.8em; margin-top: 10px; min-height: 1em;"></p>
                    </div>
                    <div class="stats-grid">
                        <div class="stat-card">
                            <h3>Total Days This Year</h3>
                            <p id="total-days-year-stat">0 days</p>
                        </div>
                        <div class="stat-card">
                            <h3>Longest Streak</h3>
                            <p id="longest-streak-stat">0 days</p>
                        </div>
                        <div class="stat-card">
                            <h3>Highest Rank Ever</h3>
                            <p id="highest-rank-stat">-</p>
                        </div>
                        <div class="stat-card">
                            <h3>Average Duration</h3>
                            <p id="avg-duration-stat">0d 0h</p>
                        </div>
                        <div class="stat-card">
                            <h3>Rank Projection</h3>
                            <select id="rank-projection-select"></select>
                            <p id="rank-projection-days" style="font-size: 2em; margin-bottom: 5px;">-</p>
                            <p id="rank-projection-date" style="font-size: 0.8em; margin-top: 0;">Select a Rank</p>
                        </div>
                    </div>
                    <div class="stats-section-header year-nav">
                        <button id="prev-year-btn" title="Previous Year">&lt;</button>
                        <h2 style="margin: 0;">Year in Review (<span id="current-year-label"></span>)</h2>
                        <button id="next-year-btn" title="Next Year">&gt;</button>
                    </div>
                    <div class="calendar-view-toggle button-group" style="justify-content: center; margin-top: 10px;">
                        <button data-view="1" class="view-toggle-btn">Month</button>
                        <button data-view="3" class="view-toggle-btn">3 Months</button>
                        <button data-view="6" class="view-toggle-btn">6 Months</button>
                        <button data-view="12" class="view-toggle-btn active">Year</button>
                    </div>
                    <div id="condensed-calendar-container"></div>
                     <p style="text-align: center; font-size: 0.8em; margin-top: 15px;">
                          <span style="display: inline-block; width: 12px; height: 12px; background-color: #27ff47;"></span> Active
                          <span style="display: inline-block; width: 12px; height: 12px; background-color: #ff8c00; margin-left: 15px;"></span> Ended
                          <span style="display: inline-block; width: 12px; height: 12px; background: linear-gradient(135deg, #ff8c00 49%, #27ff47 51%); margin-left: 15px;"></span> Ended & Restarted
                           <span style="margin-left: 15px;">ðŸŽ¯ Goal</span>
                     </p>
                </div>

                <!-- Achievements Container -->
                <div id="achievements-container" class="hidden">
                    <h2 class="stats-section-header">My Achievements</h2>
                    <div id="my-achievements-grid" class="achievements-grid"></div>
                    <h2 class="stats-section-header">Available Badges</h2>
                    <div id="available-badges-grid" class="achievements-grid"></div>
                </div>

                <!-- Journal Container -->
                <div id="journal-container" class="hidden">
                    <h2 class="stats-section-header" style="text-align: left;">Journal</h2>

                    <!-- NEW Daily Check-in Card -->
                    <div class="stat-card" style="margin-bottom: 20px;">
                        <h3 id="daily-checkin-header">Daily Check-in</h3>
                        <form id="checkin-form" style="margin-top: 15px; margin-bottom: 0; justify-content: space-around;">
                            <div class="checkin-group">
                                <input type="checkbox" id="checkin-locked" name="locked">
                                <label for="checkin-locked">Locked</label>
                            </div>
                            <div class="checkin-group">
                                <input type="checkbox" id="checkin-sex" name="sex">
                                <label for="checkin-sex">Sex</label>
                            </div>
                            <div class="checkin-group">
                                <input type="checkbox" id="checkin-edged" name="edged">
                                <label for="checkin-edged">Edged</label>
                            </div>
                            <button type="submit" id="save-checkin-btn" style="flex-basis: 100%; margin-top: 10px;">Save Check-in</button>
                        </form>
                    </div>

                    <form id="journal-form">
                        <textarea id="journal-input" placeholder="Write your journal entry here..."></textarea>
                        <button type="submit">Submit Entry</button>
                    </form>

                    <div class="journal-controls">
                        <input type="search" id="journal-search-input" placeholder="Search entries...">
                        <input type="date" id="journal-filter-start-date" title="Filter start date">
                        <input type="date" id="journal-filter-end-date" title="Filter end date">
                        <button id="journal-filter-clear-btn">Clear</button>
                    </div>

                    <div id="journal-entries-container">
                    </div>
                </div>

                <!-- NEW: About Container -->
                <div id="about-container" class="hidden" style="line-height: 1.8;">
                    <h2 class="stats-section-header" style="text-align: left;">About Streaker</h2>
                    <p>
                        Welcome to Streaker, your digital companion for building unbreakable habits. This app is built on a simple philosophy: consistency is the key to achieving any goal. The retro interface is designed to be simple and distraction-free, helping you focus on what truly matters: showing up every single day.
                    </p>

                    <h3>Getting Started: The Dashboard</h3>
                    <ul>
                        <li><strong>Log Your First Streak:</strong> In the "Log Book" section, use the date and time inputs to select a start time for your new streak. Leave the end time blank and click "Add Entry." Your "Current Streak" will begin counting up immediately.</li>
                        <li><strong>End a Streak:</strong> To end your current streak, simply find it in the Log Book table on the Dashboard and click the "End & Restart" button. This automatically logs the end time and starts a new streak from that moment.</li>
                        <li><strong>Set a Goal:</strong> Use the "Goal Progress" card to set a target for your current streak, either by a number of days or a specific calendar date. Your progress will be visualized in the progress bar.</li>
                    </ul>

                    <h3>Analyze Your Progress: The Stats Page</h3>
                    <p>The <strong>STATS</strong> tab gives you a high-level view of your journey:</p>
                    <ul>
                        <li><strong>All-Time Stats:</strong> Here you'll find key metrics like your longest-ever streak, your average streak duration, and your progress towards the "Demigod" rank.</li>
                        <li><strong>Year in Review:</strong> This interactive calendar visualizes your streaks throughout the year, helping you see your consistency at a glance. You can navigate between years and change the view to focus on 1, 3, or 6 months.</li>
                        <li><strong>Streak History:</strong> This section provides a detailed, expandable list of every streak you've completed. Click on any past streak to see a full log of all the Experience Points (XP) you earned during that period.</li>
                    </ul>
                    
                    <h3>Gamified Journey: Achievements & Journal</h3>
                     <ul>
                        <li><strong>Achievements:</strong> On the <strong>AWARDS</strong> tab, you can view all the badges you've unlocked for your current streak, as well as all the badges that are still available to earn.</li>
                        <li><strong>Journal:</strong> The <strong>JOURNAL</strong> tab is your space for reflection. Write down your thoughts, challenges, and victories. You can search your entries by keyword, filter by date, and "pin" important entries to the top of the list.</li>
                    </ul>


                    <h3>Your Account: The Profile Page</h3>
                    <p>The <strong>PROFILE</strong> tab is where you manage your account and data:</p>
                    <ul>
                         <li><strong>Public Profile:</strong> Enable this feature to share a public, read-only version of your profile. Once enabled, you can customize exactly which cards (like your Current Streak, Stats, and Calendar) are visible to others.</li>
                         <li><strong>Username:</strong> Set or change your public username here. This is required to generate your unique public profile link.</li>
                         <li><strong>Data Export:</strong> You own your data. Export your streak logs or journal entries to a CSV file at any time.</li>
                    </ul>


                    <h3>The Gamification System: XP & Levels</h3>
                    <p>
                        To make your journey more engaging, Streaker includes a leveling system. Your level is a direct reflection of the effort you've put into your <strong>current, active streak.</strong>
                    </p>
                    <p>
                        You earn Experience Points (XP) in several ways:
                       </p>
                       <ul>
                           <li><strong>+5 XP</strong> for every full day you maintain your active streak.</li>
                           <li><strong>+5 XP</strong> for every journal entry you write during your active streak.</li>
                           <li><strong>+10 XP</strong> for every achievement badge you unlock during your active streak.</li>
                           <li><strong>+10 XP</strong> for each new Rank you achieve.</li>
                       </ul>
                       <p>
                        When a streak ends, your XP for that streak resets to zero for the next one. This system is designed to reward present consistency above all else. Your all-time stats, like your longest streak, are always saved.
                    </p>

                    <h4>Ranks & Levels</h4>
                    <p>As you accumulate XP within a streak, you will advance through the ranks:</p>
                    <table style="text-align: left; font-size: 0.9em;">
                        <thead>
                            <tr>
                                <th>Level</th>
                                <th>Title</th>
                                <th>XP Required</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr><td>1</td><td>NOVICE</td><td>0 XP</td></tr>
                            <tr><td>2</td><td>APPRENTICE</td><td>100 XP</td></tr>
                            <tr><td>3</td><td>JOURNEYMAN</td><td>250 XP</td></tr>
                            <tr><td>4</td><td>EXPERT</td><td>500 XP</td></tr>
                            <tr><td>5</td><td>MASTER</td><td>1000 XP</td></tr>
                            <tr><td>6</td><td>GRANDMASTER</td><td>2000 XP</td></tr>
                            <tr><td>7</td><td>LEGEND</td><td>4000 XP</td></tr>
                            <tr><td>8</td><td>DEMIGOD</td><td>8000 XP</td></tr>
                        </tbody>
                    </table>

                </div>
                
                <!-- NEW: Profile Container -->
                <div id="profile-container" class="hidden">
                    <h2 class="stats-section-header" style="text-align: left;">Profile Settings</h2>
                    <div class="stat-card" style="margin-top: 20px;">
                        <h3>User Account</h3>
                        <p id="user-profile-display" style="font-size: 1em; margin-bottom: 15px;"></p>
                        <div class="username-change-section">
                            <input type="text" id="new-username-input" placeholder="New username">
                            <button id="save-username-btn">Save</button>
                            <p id="username-status" class="error-message" style="margin: 10px 0 0 0;"></p>
                        </div>
                    </div>

                    <div class="stat-card" style="margin-top: 20px;">
                        <h3>Public Profile</h3>
                         <div class="sharing-section" style="border-top: none; padding: 0; margin-top: 10px;">
                               <div class="toggle-switch">
                                   <label for="public-profile-toggle">Enable Public Profile</label>
                                   <label class="slider-container">
                                       <input type="checkbox" id="public-profile-toggle">
                                       <span class="slider"></span>
                                   </label>
                               </div>
                               <div id="public-link-container" class="hidden">
                                   <div style="display:flex; gap: 10px; align-items:center; margin-bottom: 10px;">
                                       <input type="text" id="public-link-display" readonly>
                                       <button id="copy-public-link-btn" title="Copy Link" style="padding: 12px; line-height: 1;">
                                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
                                       </button>
                                   </div>
                                   <!-- UPDATED: Section for card visibility toggles -->
                                   <div id="public-cards-selection" class="hidden" style="margin-top: 20px; border-top: 1px dashed #27ff47; padding-top: 15px;">
                                       <h4 style="margin-top: 0; margin-bottom: 15px;">Public Card Visibility</h4>
                                       <div class="toggle-switch">
                                           <label for="public-toggle-current-streak">Show Current Streak</label>
                                           <label class="slider-container">
                                               <input type="checkbox" id="public-toggle-current-streak" data-setting="showCurrentStreak">
                                               <span class="slider"></span>
                                           </label>
                                       </div>
                                       <div class="toggle-switch">
                                           <label for="public-toggle-goal-progress">Show Goal Progress</label>
                                           <label class="slider-container">
                                               <input type="checkbox" id="public-toggle-goal-progress" data-setting="showGoalProgress">
                                               <span class="slider"></span>
                                           </label>
                                       </div>
                                       <div class="toggle-switch">
                                           <label for="public-toggle-longest-streak">Show Longest Streak</label>
                                           <label class="slider-container">
                                               <input type="checkbox" id="public-toggle-longest-streak" data-setting="showLongestStreak">
                                               <span class="slider"></span>
                                           </label>
                                       </div>
                                       <div class="toggle-switch">
                                           <label for="public-toggle-average-streak">Show Average Streak</label>
                                           <label class="slider-container">
                                               <input type="checkbox" id="public-toggle-average-streak" data-setting="showAverageStreak">
                                               <span class="slider"></span>
                                           </label>
                                       </div>
                                     <div class="toggle-switch">
                                        <label for="public-toggle-total-days-year">Show Total Days This Year</label>
                                        <label class="slider-container">
                                            <input type="checkbox" id="public-toggle-total-days-year" data-setting="showTotalDaysYear">
                                            <span class="slider"></span>
                                        </label>
                                    </div>
                                    <div class="toggle-switch">
                                        <label for="public-toggle-highest-rank">Show Highest Rank Ever</label>
                                        <label class="slider-container">
                                            <input type="checkbox" id="public-toggle-highest-rank" data-setting="showHighestRank">
                                            <span class="slider"></span>
                                        </label>
                                    </div>
                                       <div class="toggle-switch">
                                           <label for="public-toggle-achievements">Show Achievements</label>
                                           <label class="slider-container">
                                               <input type="checkbox" id="public-toggle-achievements" data-setting="showAchievements">
                                               <span class="slider"></span>
                                           </label>
                                       </div>
                                       <div class="toggle-switch">
                                           <label for="public-toggle-history">Show Streak History</label>
                                           <label class="slider-container">
                                               <input type="checkbox" id="public-toggle-history" data-setting="showHistory">
                                               <span class="slider"></span>
                                           </label>
                                       </div>
                                       <div class="toggle-switch">
                                           <label for="public-toggle-calendar">Show Calendar</label>
                                           <label class="slider-container">
                                               <input type="checkbox" id="public-toggle-calendar" data-setting="showCalendar">
                                               <span class="slider"></span>
                                           </label>
                                       </div>
                                   </div>
                               </div>
                          </div>
                    </div>
                    
                    <!-- NEW: Data Export Section -->
                    <div class="stat-card" style="margin-top: 20px;">
                        <h3>Data Export</h3>
                        <div class="export-buttons">
                            <button id="export-logs-btn">Export Streak Logs (CSV)</button>
                            <button id="export-journal-btn">Export Journal Entries (CSV)</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Mobile Nav -->
        <nav class="mobile-nav">
             <!-- Dashboard -->
            <button class="nav-link active" data-tab="dashboard">
                <svg viewBox="0 0 24 24"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg>
                <span class="nav-link-label">DASH</span>
            </button>
            <!-- Stats -->
            <button class="nav-link" data-tab="stats">
                 <svg viewBox="0 0 24 24"><path d="M10 20h4V4h-4v16zm-6 0h4v-8H4v8zM16 9v11h4V9h-4z"/></svg>
                <span class="nav-link-label">STATS</span>
            </button>
            <!-- Achievements -->
             <button class="nav-link" data-tab="achievements">
                 <svg viewBox="0 0 24 24"><path d="M19 5h-2V3H7v2H5c-1.1 0-2 .9-2 2v1c0 2.55 1.92 4.63 4.39 4.94.63 1.5 1.74 2.77 3.11 3.5V19H7v2h10v-2h-3.5v-3.56c1.37-.73 2.48-2 3.11-3.5.07-.16.12-.33.18-.5.1-.3.15-.61.15-.93V7c0-1.1-.9-2-2-2zm-7 10c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3z"/></svg>
                <span class="nav-link-label">AWARDS</span>
            </button>
            <!-- Journal -->
            <button class="nav-link" data-tab="journal">
                 <svg viewBox="0 0 24 24"><path d="M18 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM6 4h5v8l-2.5-1.5L6 12V4z"/></svg>
                <span class="nav-link-label">JOURNAL</span>
            </button>
            <!-- Profile -->
            <button class="nav-link" data-tab="profile">
                <svg viewBox="0 0 24 24"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>
                <span class="nav-link-label">PROFILE</span>
            </button>
        </nav>
        
        <!-- NEW Gamification Elements -->
        <div id="xp-toast" class="hidden"></div>
        <div id="levels-modal" class="hidden">
            <div class="terminal-window" style="max-width: 500px;">
                <div class="terminal-header">RANKS & LEVELS</div>
                <div id="levels-modal-content" style="padding: 20px;">
                    <!-- Table will be generated here -->
                </div>
                <button id="close-levels-modal-btn" style="width: 100%;">Close</button>
            </div>
        </div>
    </div>

    <!-- Firebase SDK Scripts -->
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore-compat.js"></script>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const firebaseConfig = {
         apiKey: "AIzaSyCxPG9RfxihL-Rfhu7fPSP95QDld6QMuik",
         authDomain: "streaker-1658d.firebaseapp.com",
         projectId: "streaker-1658d",
         storageBucket: "streaker-1658d.firebasestorage.app",
         messagingSenderId: "12701860115",
         appId: "1:12701860115:web:0d4dcba33fd234df97dae6",
         measurementId: "G-XKE790N7ZL"
        };
        
        // Initialize Firebase
        if (!firebase.apps.length) {
            try {
                firebase.initializeApp(firebaseConfig);
            } catch (error) {
                console.error("Firebase initialization failed:", error.message);
            }
        }
        
        const auth = firebase.auth();
        const db = firebase.firestore();

        // DOM elements
        const authContainer = document.getElementById('auth-container');
        const mainAppContainer = document.getElementById('main-app-container');
        const appLayout = document.getElementById('app-layout');
        const authForm = document.getElementById('auth-form');
        const toggleAuthModeBtn = document.getElementById('toggle-auth-mode-btn');
        const mainAuthBtn = document.getElementById('main-auth-btn');
        const usernameInput = document.getElementById('username-input');
        const emailInput = document.getElementById('email-input');
        const passwordInput = document.getElementById('password-input');

        const newLogoutBtn = document.getElementById('new-logout-btn');
        
        // NEW: Export buttons
        const exportLogsBtn = document.getElementById('export-logs-btn');
        const exportJournalBtn = document.getElementById('export-journal-btn');
        
        const allNavLinkBtns = document.querySelectorAll('.nav-link');

        const dashboardContainer = document.getElementById('dashboard-container');
        const logbookContainer = document.getElementById('logbook-container');
        const achievementsContainer = document.getElementById('achievements-container');
        const journalContainer = document.getElementById('journal-container');
        const aboutContainer = document.getElementById('about-container');
        const profileContainer = document.getElementById('profile-container');

        // Logbook elements
        const entryForm = document.getElementById('entry-form');
        const authError = document.getElementById('auth-error');
        const startDateInput = document.getElementById('start-date-input');
        const endDateInput = document.getElementById('end-date-input');
        const longestStreakStat = document.getElementById('longest-streak-stat');
        const avgDurationStat = document.getElementById('avg-duration-stat');
        const highestRankStat = document.getElementById('highest-rank-stat');
        const totalDaysYearStat = document.getElementById('total-days-year-stat');
        const rankProjectionSelect = document.getElementById('rank-projection-select');
        const rankProjectionDays = document.getElementById('rank-projection-days');
        const rankProjectionDate = document.getElementById('rank-projection-date');
        
        // Goal elements
        const goalInput = document.getElementById('goal-input');
        const goalDateInput = document.getElementById('goal-date-input');
        const progressBar = document.getElementById('progress-bar');
        const progressText = document.getElementById('progress-text');
        const goalDate = document.getElementById('goal-date');

        // Achievements elements
        const myAchievementsGrid = document.getElementById('my-achievements-grid');
        const availableBadgesGrid = document.getElementById('available-badges-grid');
        

        // Journal elements
        const journalForm = document.getElementById('journal-form');
        const journalInput = document.getElementById('journal-input');
        const journalEntriesContainer = document.getElementById('journal-entries-container');
        const journalSearchInput = document.getElementById('journal-search-input');
        const journalFilterStartDate = document.getElementById('journal-filter-start-date');
        const journalFilterEndDate = document.getElementById('journal-filter-end-date');
        const journalFilterClearBtn = document.getElementById('journal-filter-clear-btn');
        const checkinForm = document.getElementById('checkin-form');
        const checkinLocked = document.getElementById('checkin-locked');
        const checkinSex = document.getElementById('checkin-sex');
        const checkinEdged = document.getElementById('checkin-edged');
        const dailyCheckinHeader = document.getElementById('daily-checkin-header');

        // NEW: Profile elements
        const userProfileDisplay = document.getElementById('user-profile-display');
        const publicProfileToggle = document.getElementById('public-profile-toggle');
        const publicLinkContainer = document.getElementById('public-link-container');
        const publicLinkDisplay = document.getElementById('public-link-display');
        const copyPublicLinkBtn = document.getElementById('copy-public-link-btn');
        // UPDATED: New elements for public card settings
        const publicCardsSelection = document.getElementById('public-cards-selection');
        
        // NEW: Username change elements
        const newUsernameInput = document.getElementById('new-username-input');
        const saveUsernameBtn = document.getElementById('save-username-btn');
        const usernameStatus = document.getElementById('username-status');
        
        // NEW: Streak History elements
        const streakHistoryContainer = document.getElementById('streak-history-container');
        
        // NEW: Modal elements
        const levelsModal = document.getElementById('levels-modal');
        const closeLevelsModalBtn = document.getElementById('close-levels-modal-btn');
        const calendarViewToggle = document.querySelector('.calendar-view-toggle');


        // NEW: Chart, Loading, and Public View containers
        const loadingContainer = document.getElementById('loading-container');
        const publicViewContainer = document.getElementById('public-view-container');
        
        let isSignupMode = false;
        let userLogs = [];
        let allJournalEntries = []; // Holds all journal entries for client-side filtering
        let userCheckins = [];
        let ongoingStreakInterval = null;
        let currentEditingLogId = null;
        let displayedYear = new Date().getFullYear(); // For year-in-review calendar
        let userData = {}; // To store user doc data like username, last check-in
        let mainAppListenersAdded = false; // Flag to ensure listeners are only added once
        let isUpdatingGoal = false; // Flag to prevent goal input loops
        let publicInterval = null; // To manage the public profile's update timer
        let calendarMonthsToShow = 12;
        let highestAnnouncedLevelClient = 0; // Client-side state for announced levels

        // --- START: GAMIFICATION LOGIC --- //
        
        // Configuration for levels based on XP
        const LEVEL_CONFIG = [
            { level: 1, xp: 0, title: 'NOVICE' },
            { level: 2, xp: 100, title: 'APPRENTICE' },
            { level: 3, xp: 250, title: 'JOURNEYMAN' },
            { level: 4, xp: 500, title: 'EXPERT' },
            { level: 5, xp: 1000, title: 'MASTER' },
            { level: 6, xp: 2000, title: 'GRANDMASTER' },
            { level: 7, xp: 4000, title: 'LEGEND' },
            { level: 8, xp: 8000, title: 'DEMIGOD' },
        ];
        
        const LEVEL_BADGES_CONFIG = [
            { level: 1, name: 'Novice', icon: 'ðŸ”°' },
            { level: 2, name: 'Apprentice', icon: 'ðŸŽ“' },
            { level: 3, name: 'Journeyman', icon: 'ðŸ› ï¸' },
            { level: 4, name: 'Expert', icon: 'ðŸ§' },
            { level: 5, name: 'Master', icon: 'ðŸ¥‹' },
            { level: 6, name: 'Grandmaster', icon: 'ðŸ‘‘' },
            { level: 7, name: 'Legend', icon: 'ðŸŒŸ' },
            { level: 8, name: 'Demigod', icon: 'ðŸ”±' },
        ];

        const ACHIEVEMENTS_CONFIG = [
            { name: "Gotta Start Somewhere", days: 1, icon: 'ðŸŒ±' },
            { name: "7-Day Streak", days: 7, icon: 'â­' },
            { name: "2-Week Streak", days: 14, icon: 'ðŸ“…' },
            { name: "30-Day Streak", days: 30, icon: 'ðŸ†' },
            { name: "Two-Month Trekker", days: 60, icon: 'ðŸš¶â€â™‚ï¸' },
            { name: "90-Day Streak", days: 90, icon: 'ðŸ›¡ï¸' },
            { name: "100-Day Streak", days: 100, icon: 'ðŸ’¯' },
            { name: "Four-Month Force", days: 120, icon: 'ðŸ’ª' },
            { name: "Five-Month Fighter", days: 150, icon: 'ðŸ¥Š' },
            { name: "Six-Month Soarer", days: 180, icon: 'ðŸ•Šï¸' },
            { name: "Seven-Month Success", days: 210, icon: 'ðŸŽ¯' },
            { name: "Eight-Month Effort", days: 240, icon: 'ðŸ¥‡' },
            { name: "Nine-Month Ninja", days: 270, icon: 'ðŸ¥·' },
            { name: "Ten-Month Titan", days: 300, icon: 'ðŸ‘‘' },
            { name: "Eleven-Month Emperor", days: 330, icon: 'ðŸ‘‘' },
            { name: "One-Year Victor", days: 365, icon: 'ðŸ…' },
        ];
        
        function calculateLevelFromXp(xp = 0) {
            const currentLevelInfo = LEVEL_CONFIG.slice().reverse().find(l => xp >= l.xp) || LEVEL_CONFIG[0];
            const nextLevelInfo = LEVEL_CONFIG.find(l => l.level === currentLevelInfo.level + 1);

            const xpForCurrentLevel = currentLevelInfo.xp;
            const xpForNextLevel = nextLevelInfo ? nextLevelInfo.xp : Infinity;
            
            const xpInCurrentLevel = xp - xpForCurrentLevel;
            const xpNeededForNextLevel = xpForNextLevel - xpForCurrentLevel;

            let progress = 100;
            if (nextLevelInfo && xpNeededForNextLevel > 0) {
                 progress = Math.round((xpInCurrentLevel / xpNeededForNextLevel) * 100);
            }

            return {
                level: currentLevelInfo.level,
                title: currentLevelInfo.title,
                xpForCurrentLevel,
                xpForNextLevel,
                progress,
            };
        }
        
        function calculateXpForStreak(streakDoc, journalEntries) {
             let totalXp = 0;
             if (!streakDoc || !streakDoc.data()) return 0;
             const streakData = streakDoc.data();
             if (!streakData.startDate) return 0;

             const streakStartDate = parseDate(streakData.startDate);
             const streakEndDate = streakData.endDate ? parseDate(streakData.endDate) : new Date();

             if (streakStartDate) {
                 const duration = calculateDuration(streakStartDate, streakEndDate);
                
                 // Base XP sources
                 let baseXp = duration.days * 5;
                 const journalEntriesDuringStreak = journalEntries.filter(doc => {
                     const entryData = doc.data();
                     if (entryData && entryData.date && typeof entryData.date.toDate === 'function') {
                         const entryDate = entryData.date.toDate();
                         return entryDate >= streakStartDate && entryDate <= streakEndDate;
                     }
                     return false;
                 });
                 baseXp += journalEntriesDuringStreak.length * 5;

                 // Day-based achievements XP
                 ACHIEVEMENTS_CONFIG.forEach(achievement => {
                     if (duration.days >= achievement.days) {
                         baseXp += 10;
                     }
                 });

                 // Iteratively calculate level-up XP to prevent infinite loops
                 let levelBadgeXp = 0;
                 let lastCalculatedLevel = 1;
                 let hasLeveledUp = true; // Start loop
                
                 while(hasLeveledUp) {
                     const tempTotalXp = baseXp + levelBadgeXp;
                     const newLevelData = calculateLevelFromXp(tempTotalXp);

                     if (newLevelData.level > lastCalculatedLevel) {
                         levelBadgeXp += (newLevelData.level - lastCalculatedLevel) * 10;
                         lastCalculatedLevel = newLevelData.level;
                     } else {
                         hasLeveledUp = false; // No more level ups, exit loop
                     }
                 }
                
                 totalXp = baseXp + levelBadgeXp;
             }
            return totalXp;
        }

        async function calculateAndSetCurrentStreakXp() {
            const oldXp = userData.xp || 0;
            let totalXp = 0;
            const activeStreakDoc = userLogs.find(doc => doc.data() && !doc.data().endDate);

            if (activeStreakDoc) {
                totalXp = calculateXpForStreak(activeStreakDoc, allJournalEntries);
            }
            
            const oldLevelData = calculateLevelFromXp(oldXp);
            const newLevelData = calculateLevelFromXp(totalXp);

            // NEW ROBUST LOGIC: Check against a value on the main user document
            if (newLevelData.level > oldLevelData.level) {
                const user = auth.currentUser;
                // Check against the more reliable client-side variable
                if (newLevelData.level > highestAnnouncedLevelClient && user) {
                    // showLevelUpModal(newLevelData.level, newLevelData.title);
                    
                    // Immediately update the client-side variable to prevent race conditions
                    highestAnnouncedLevelClient = newLevelData.level;

                    // Persist the new highest announced level to the main user doc
                    const userRef = db.collection('users').doc(user.uid);
                    userRef.update({
                        highestAnnouncedLevelForCurrentStreak: newLevelData.level
                    }).catch(err => console.error("Could not update highest announced level", err));
                }
            }
            
            userData.xp = totalXp;
            updateGamificationUI(totalXp);
            updateRankProjection();
            updateNextRankEstimate();
        }
        
        function updateGamificationUI(currentXp = 0) {
            const levelData = calculateLevelFromXp(currentXp);

            const levelText = `: LEVEL ${levelData.level} - ${levelData.title}`;
            document.getElementById('rank-header-stats').textContent = "Current Rank" + levelText;

            const xpText = isFinite(levelData.xpForNextLevel) ? `[XP: ${currentXp}/${levelData.xpForNextLevel}]` : `[XP: ${currentXp} / MAX]`;
            const barWidth = 20;
            const filledChars = Math.round(barWidth * (levelData.progress / 100));
            const emptyChars = barWidth - filledChars;
            const asciiBar = `[${'â–ˆ'.repeat(filledChars)}${'â–‘'.repeat(emptyChars)}] ${levelData.progress}%`;
            
            const fullProgressBarText = `${xpText}\n${asciiBar}`;

            document.getElementById('xp-progress-bar-stats').textContent = fullProgressBarText;
        }

        function showXpToast(amount, reason) {
            const toast = document.getElementById('xp-toast');
            toast.textContent = `${amount >= 0 ? '+' : ''}${amount} XP (${reason})`;
            toast.classList.remove('hidden');
            toast.style.opacity = '1';
            toast.style.bottom = '100px';

            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.bottom = '80px';
                setTimeout(() => toast.classList.add('hidden'), 500);
            }, 3000);
        }
        
        function showLevelsModal() {
            const modalContent = document.getElementById('levels-modal-content');
            let tableHTML = '<table><thead><tr><th>Level</th><th>Title</th><th>XP Required</th></tr></thead><tbody>';
            LEVEL_CONFIG.forEach(level => {
                tableHTML += `<tr><td>${level.level}</td><td>${level.title}</td><td>${level.xp} XP</td></tr>`;
            });
            tableHTML += '</tbody></table>';
            modalContent.innerHTML = tableHTML;
            levelsModal.classList.remove('hidden');
        }

        function hideLevelsModal() {
            levelsModal.classList.add('hidden');
        }
        
        function updateRankProjection() {
            if (!rankProjectionSelect.value) {
                rankProjectionDays.textContent = '-';
                rankProjectionDate.textContent = 'Select a Rank';
                return;
            }

            const targetLevel = parseInt(rankProjectionSelect.value, 10);
            const targetLevelData = LEVEL_CONFIG.find(l => l.level === targetLevel);
            if (!targetLevelData) return;

            const targetXp = targetLevelData.xp;
            const currentXp = userData.xp || 0;

            if (currentXp >= targetXp) {
                rankProjectionDays.textContent = '0';
                rankProjectionDate.textContent = 'Achieved!';
                return;
            }

            const activeStreak = userLogs.find(doc => doc.data() && !doc.data().endDate);
            if (!activeStreak) {
                rankProjectionDays.textContent = 'N/A';
                rankProjectionDate.textContent = 'Start a streak';
                return;
            }
            
            const streakDuration = calculateDuration(activeStreak.data().startDate, null).totalMilliseconds;
            const daysSoFar = Math.max(1, streakDuration / (1000 * 60 * 60 * 24));
            const xpPerDay = currentXp / daysSoFar;

            if (xpPerDay <= 0) {
                rankProjectionDays.textContent = 'âˆž';
                rankProjectionDate.textContent = 'Earn some XP!';
                return;
            }

            const xpNeeded = targetXp - currentXp;
            const daysRemaining = Math.ceil(xpNeeded / xpPerDay);
            
            const today = new Date();
            const estimatedDate = new Date();
            estimatedDate.setDate(today.getDate() + daysRemaining);
            const formattedDate = formatShortDate(estimatedDate);

            rankProjectionDays.textContent = `~${daysRemaining} days`;
            rankProjectionDate.textContent = formattedDate;
        }

        function updateNextRankEstimate() {
            const nextRankEstimateEl = document.getElementById('next-rank-estimate');
            if (!nextRankEstimateEl) return;

            const currentXp = userData.xp || 0;
            const levelData = calculateLevelFromXp(currentXp);
            const nextLevelXp = levelData.xpForNextLevel;

            if (!isFinite(nextLevelXp)) {
                nextRankEstimateEl.textContent = 'Max Rank Achieved!';
                return;
            }

            const activeStreak = userLogs.find(doc => doc.data() && !doc.data().endDate);
            if (!activeStreak) {
                nextRankEstimateEl.textContent = 'Start a streak to estimate.';
                return;
            }
            
            const streakDuration = calculateDuration(activeStreak.data().startDate, null).totalMilliseconds;
            const daysSoFar = Math.max(1, streakDuration / (1000 * 60 * 60 * 24));
            const xpPerDay = currentXp / daysSoFar;

            if (xpPerDay <= 0) {
                nextRankEstimateEl.textContent = 'Next rank in âˆž days (Earn XP!)';
                return;
            }

            const xpNeeded = nextLevelXp - currentXp;
            const daysRemaining = Math.ceil(xpNeeded / xpPerDay);
            
            const today = new Date();
            const estimatedDate = new Date();
            estimatedDate.setDate(today.getDate() + daysRemaining);
            const formattedDate = formatShortDate(estimatedDate);

            nextRankEstimateEl.textContent = `Next rank in ~${daysRemaining} days (${formattedDate})`;
        }

        function parseDate(dateInput) {
            if (!dateInput) return null;
            if (dateInput && typeof dateInput.toDate === 'function') {
                return dateInput.toDate();
            }
            if (dateInput instanceof Date) {
                return dateInput;
            }
            if (typeof dateInput === 'string' && dateInput.match(/^\d{4}-\d{2}-\d{2}$/)) {
                return new Date(dateInput + 'T00:00:00');
            }
            const date = new Date(dateInput); 
            return isNaN(date.getTime()) ? null : date;
        }
        
        function formatShortDate(dateInput) {
             const date = parseDate(dateInput);
             if (!date) return 'Invalid';
             const options = { year: 'numeric', month: 'short', day: 'numeric' };
             return date.toLocaleDateString('en-US', options);
            }

        function formatDate(dateInput) {
            const date = parseDate(dateInput);
            if (!date) return 'Invalid Date';
            const options = { year: 'numeric', month: 'long', day: 'numeric', timeZone: 'UTC' };
            return date.toLocaleDateString('en-US', options);
        }

        function formatDateForInput(date) {
            if (!date || !(date instanceof Date)) return '';
            const pad = (num) => num.toString().padStart(2, '0');
            const year = date.getFullYear();
            const month = pad(date.getMonth() + 1);
            const day = pad(date.getDate());
            const hours = pad(date.getHours());
            const minutes = pad(date.getMinutes());
            return `${year}-${month}-${day}T${hours}:${minutes}`;
        }
        
        function formatFullDate(date) {
            if (!date || !(date instanceof Date)) return 'N/A';
            const options = { year: 'numeric', month: 'long', day: 'numeric', hour: 'numeric', minute: 'numeric' };
            return date.toLocaleDateString('en-US', options);
        }

        function calculateDuration(startDateInput, endDateInput) {
            const start = parseDate(startDateInput);
            if (!start) return { totalMilliseconds: 0, formatted: "Invalid", days: 0, hours: 0, minutes: 0, seconds: 0 };

            const end = endDateInput ? parseDate(endDateInput) : new Date();
            if (!end) return { totalMilliseconds: 0, formatted: "Invalid", days: 0, hours: 0, minutes: 0, seconds: 0 };
        
            const diff = end - start;
            if (isNaN(diff) || diff < 0) return { totalMilliseconds: 0, formatted: "0d 0h 0m", days: 0, hours: 0, minutes: 0, seconds: 0 };

            const days = Math.floor(diff / (1000 * 60 * 60 * 24));
            const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((diff % (1000 * 60)) / 1000);

            const formatted = endDateInput 
                ? `${days}d ${hours}h ${minutes}m`
                : `${days}d ${hours}h ${minutes}m`;

            return { totalMilliseconds: diff, formatted, days, hours, minutes, seconds };
        }
        
        function formatDurationFromMs(ms) {
            if (isNaN(ms) || ms < 0) {
                return { formatted: "0d 0h 0m", days: 0, hours: 0, minutes: 0 };
            }
            const days = Math.round(ms / (1000 * 60 * 60 * 24));
            return { formatted: `${days} days`, days };
        }
        
        function calculateTotalDaysThisYear(logsToCalculate) {
            const currentYear = new Date().getFullYear();
            let totalDays = 0;

            logsToCalculate.forEach(doc => {
                const log = doc.data();
                const startDate = parseDate(log.startDate);
                const endDate = parseDate(log.endDate) || new Date();

                if (!startDate) return;

                if (startDate.getFullYear() > currentYear && endDate.getFullYear() > currentYear) return;

                const startOfYear = new Date(currentYear, 0, 1);
                const endOfYear = new Date(currentYear, 11, 31, 23, 59, 59);

                const streakStart = startDate < startOfYear ? startOfYear : startDate;
                const streakEnd = endDate > endOfYear ? endOfYear : endDate;
                
                if (streakEnd > streakStart) {
                    const diffTime = Math.abs(streakEnd - streakStart);
                    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                    totalDays += diffDays;
                }
            });
            return totalDays;
        }

        function updateGoalProgress(goal) {
            const currentStreak = userLogs.find(doc => !doc.data().endDate);
            const currentDays = currentStreak ? calculateDuration(currentStreak.data().startDate, null).days : 0;
            const goalDays = goal || 0;

            if (!goalDays || goalDays <= 0) {
                progressBar.style.width = '0%';
                progressText.textContent = `0%`;
                return;
            }

            const progressPercentage = Math.min((currentDays / goalDays) * 100, 100);
            progressBar.style.width = `${progressPercentage}%`;
            
            const remainingDays = Math.max(0, goalDays - currentDays);
            
            if (remainingDays > 0) {
                progressText.textContent = `${Math.round(progressPercentage)}% (${remainingDays} ${remainingDays === 1 ? 'day' : 'days'} remaining)`;
            } else {
                progressText.textContent = `${Math.round(progressPercentage)}% (Goal reached!)`;
            }
        }

        function calculateStats() {
            let longestDurationMs = 0;
            let totalCompletedDurationMs = 0;
            let completedEntriesCount = 0;
            let ongoingEntry = null;

            userLogs.forEach(doc => {
                const log = doc.data();
                const duration = calculateDuration(log.startDate, log.endDate);
                if (log.endDate) {
                    totalCompletedDurationMs += duration.totalMilliseconds;
                    completedEntriesCount++;
                } else {
                    ongoingEntry = log;
                }
                
                if (duration.totalMilliseconds > longestDurationMs) {
                    longestDurationMs = duration.totalMilliseconds;
                }
            });

            const longestDuration = formatDurationFromMs(longestDurationMs);
            longestStreakStat.textContent = `${longestDuration.days} days`;
            
            if (completedEntriesCount > 0) {
                const avgMs = totalCompletedDurationMs / completedEntriesCount;
                const roundedDays = Math.round(avgMs / (1000 * 60 * 60 * 24));
                avgDurationStat.textContent = `${roundedDays} days`;
            } else {
                avgDurationStat.textContent = "0 days";
            }

            if (ongoingEntry) {
                if (ongoingStreakInterval) clearInterval(ongoingStreakInterval);
                const update = () => {
                    const currentDuration = calculateDuration(ongoingEntry.startDate, null);
                    
                    document.getElementById('streak-days').textContent = currentDuration.days;
                    document.getElementById('streak-hours').textContent = String(currentDuration.hours).padStart(2, '0');
                    document.getElementById('streak-minutes').textContent = String(currentDuration.minutes).padStart(2, '0');
                    document.getElementById('streak-seconds').textContent = String(currentDuration.seconds).padStart(2, '0');

                    // NEW: Update duration in the log book as well
                    const activeStreakDurationEl = document.getElementById('active-streak-duration-in-log');
                    if (activeStreakDurationEl) {
                        activeStreakDurationEl.textContent = currentDuration.formatted;
                    }


                    const now = new Date();
                    const secondsToday = now.getSeconds() + (now.getMinutes() * 60) + (now.getHours() * 3600);
                    const progressPercent = (secondsToday / 86400);
                    
                    const barWidth = 20;
                    const filledChars = Math.round(barWidth * progressPercent);
                    const emptyChars = barWidth - filledChars;
                    
                    document.getElementById('daily-progress-bar').textContent = `[${'â–ˆ'.repeat(filledChars)}${'â–‘'.repeat(emptyChars)}]`;
                };
                update();
                ongoingStreakInterval = setInterval(update, 1000);
            } else {
                if (ongoingStreakInterval) clearInterval(ongoingStreakInterval);
                document.getElementById('streak-days').textContent = '0';
                document.getElementById('streak-hours').textContent = '00';
                document.getElementById('streak-minutes').textContent = '00';
                document.getElementById('streak-seconds').textContent = '00';
                document.getElementById('daily-progress-bar').textContent = `[${'â–‘'.repeat(20)}]`;
            }
            
            totalDaysYearStat.textContent = `${calculateTotalDaysThisYear(userLogs)} days`;
            // FIX: Pass the calendarMonthsToShow variable for consistency
            renderCondensedCalendar(displayedYear, userLogs, goalDateInput.value, '#condensed-calendar-container', '#current-year-label', calendarMonthsToShow);
            calculateAndDisplayHighestRank();
        }

        function calculateAndDisplayHighestRank() {
            if (!highestRankStat) return;

            let highestLevel = 1;
            let highestTitle = 'NOVICE';

            // Check current streak first
            const activeStreak = userLogs.find(doc => doc.data() && !doc.data().endDate);
            if (activeStreak) {
                const currentRankData = calculateLevelFromXp(userData.xp || 0);
                highestLevel = currentRankData.level;
                highestTitle = currentRankData.title;
            }

            // Then check completed streaks
            const completedStreaks = userLogs.filter(doc => doc.data() && doc.data().endDate);
            completedStreaks.forEach(streak => {
                const data = streak.data();
                let rankData;
                if (typeof data.finalXp === 'number') {
                    rankData = calculateLevelFromXp(data.finalXp);
                } else {
                    // Fallback for older data that didn't store finalXp
                    const xp = calculateXpForStreak(streak, allJournalEntries);
                    rankData = calculateLevelFromXp(xp);
                }
                
                if (rankData.level > highestLevel) {
                    highestLevel = rankData.level;
                    highestTitle = rankData.title;
                }
            });

            highestRankStat.innerHTML = `Lvl ${highestLevel} - ${highestTitle}`;
        }
        
        function renderAchievements() {
            myAchievementsGrid.innerHTML = '';
            availableBadgesGrid.innerHTML = '';
            
            const ongoingEntry = userLogs.find(doc => doc.data() && !doc.data().endDate);
            const currentStreakDays = ongoingEntry ? calculateDuration(ongoingEntry.data().startDate, null).days : 0;
            const currentXp = userData.xp || 0;
            const { level: currentLevel } = calculateLevelFromXp(currentXp);
            
            const allBadges = [...ACHIEVEMENTS_CONFIG, ...LEVEL_BADGES_CONFIG];

            allBadges.forEach(badge => {
                let unlocked = false;
                let tooltipText = '';

                if (badge.days !== undefined) {
                    unlocked = currentStreakDays >= badge.days;
                    tooltipText = `Maintain a streak for ${badge.days} day${badge.days > 1 ? 's' : ''}.`;
                } else if (badge.level !== undefined) {
                    unlocked = currentLevel >= badge.level;
                    tooltipText = `Reach Level ${badge.level}: ${badge.name}.`;
                }

                const grid = unlocked ? myAchievementsGrid : availableBadgesGrid;
                const badgeEl = document.createElement('div');
                badgeEl.className = 'badge-card';
                let badgeName = badge.name;
                if (badge.level) {
                    badgeName = `Lvl ${badge.level}: ${badge.name}`;
                }
                badgeEl.innerHTML = `
                    <span class="badge-tooltip">${tooltipText}</span>
                    <div class="badge-icon ${unlocked ? 'unlocked' : ''}">${badge.icon}</div>
                    <div class="badge-name">${badgeName}</div>
                `;
                grid.appendChild(badgeEl);
            });

            if (myAchievementsGrid.children.length === 0) {
                myAchievementsGrid.innerHTML = '<p style="font-style: italic; color: #aaa;">Keep going! You haven\'t earned any badges yet on this streak.</p>';
            }

            if (availableBadgesGrid.children.length === 0 && ongoingEntry) {
                 availableBadgesGrid.innerHTML = '<p style="font-style: italic; color: #aaa;">Congratulations! You have collected all available badges!</p>';
            }
        }
        
        function renderCondensedCalendar(year, allLogs, goalDateString, containerSelector, yearLabelSelector, monthsToShow = 12) {
            const container = document.querySelector(containerSelector);
            const yearLabel = document.querySelector(yearLabelSelector);
            if(!container || !yearLabel) return;
            
            container.innerHTML = '';
            
            const activeDays = new Set();
            const endDays = new Set();
            const startDays = new Set();

            allLogs.forEach(doc => {
                const log = doc.data ? doc.data() : doc;
                const logStart = parseDate(log.startDate);
                if (!logStart) return;

                const logEnd = parseDate(log.endDate) || new Date();
                
                if (logStart.getFullYear() === year) {
                    startDays.add(logStart.toISOString().split('T')[0]);
                }

                if (log.endDate && logEnd.getFullYear() === year) {
                     endDays.add(logEnd.toISOString().split('T')[0]);
                }

                for (let d = new Date(logStart); d <= logEnd; d.setDate(d.getDate() + 1)) {
                    if (d.getFullYear() === year) {
                        activeDays.add(d.toISOString().split('T')[0]);
                    }
                }
            });

            const monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
            
            const monthsToRender = [];
            const now = new Date();
            const centerDate = new Date(year, now.getMonth(), 1); 

            if (monthsToShow === 12) {
                for (let i = 0; i < 12; i++) {
                    monthsToRender.push({ month: i, year: year });
                }
            } else {
                let startMonthOffset;
                switch(monthsToShow) {
                    case 1:
                        startMonthOffset = 0; // Current month
                        break;
                    case 3:
                        startMonthOffset = -1; // One month before, current, one after
                        break;
                    case 6:
                        startMonthOffset = -3; // Three months before, current, two after
                        break;
                    default:
                        startMonthOffset = 0;
                }

                for (let i = 0; i < monthsToShow; i++) {
                    const monthDate = new Date(centerDate.getFullYear(), centerDate.getMonth() + startMonthOffset + i, 1);
                    monthsToRender.push({ month: monthDate.getMonth(), year: monthDate.getFullYear() });
                }
            }
            
            const firstMonth = monthsToRender[0];
            const lastMonth = monthsToRender[monthsToRender.length - 1];
            if (firstMonth.year !== lastMonth.year) {
                yearLabel.textContent = `${firstMonth.year} - ${lastMonth.year}`;
            } else {
                yearLabel.textContent = year;
            }

            monthsToRender.forEach(dateInfo => {
                const month = dateInfo.month;
                const currentFullYear = dateInfo.year;
                
                const monthContainer = document.createElement('div');
                monthContainer.className = 'month-grid-container';
                monthContainer.innerHTML = `
                    <h3 class="month-grid-title">${monthNames[month]} ${currentFullYear}</h3>
                    <div class="month-grid-dow">
                        ${['S', 'M', 'T', 'W', 'T', 'F', 'S'].map(d => `<div>${d}</div>`).join('')}
                    </div>
                `;
                const monthGrid = document.createElement('div');
                monthGrid.className = 'month-grid';

                const firstDayOfMonth = new Date(currentFullYear, month, 1).getDay();
                const daysInMonth = new Date(currentFullYear, month + 1, 0).getDate();

                for(let i=0; i<firstDayOfMonth; i++) {
                    monthGrid.appendChild(document.createElement('div'));
                }

                for(let day = 1; day <= daysInMonth; day++) {
                    const dayCell = document.createElement('div');
                    dayCell.className = 'month-grid-day';
                    const dateString = `${currentFullYear}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                    dayCell.title = dateString;

                    const isEndDay = endDays.has(dateString);
                    const isActiveDay = activeDays.has(dateString);
                    const isStartDay = startDays.has(dateString);

                    if (isEndDay && isStartDay) dayCell.classList.add('end-and-start');
                    else if (isEndDay) dayCell.classList.add('end');
                    else if (isActiveDay) dayCell.classList.add('active');
                    
                    if (dateString === goalDateString) dayCell.classList.add('goal-day');

                    monthGrid.appendChild(dayCell);
                }
                monthContainer.appendChild(monthGrid);
                container.appendChild(monthContainer);
            });
        }

        function applyAndRenderJournalFilters() {
            const searchTerm = journalSearchInput.value.toLowerCase();
            const startDate = journalFilterStartDate.value;
            const endDate = journalFilterEndDate.value;

            const filteredEntries = allJournalEntries.filter(doc => {
                const entry = doc.data();
                if (!entry.date || typeof entry.date.toDate !== 'function') return false;
                
                const entryDate = entry.date.toDate();
                const textMatch = (entry.text || '').toLowerCase().includes(searchTerm);
                const startDateMatch = !startDate || entryDate >= new Date(startDate);
                const endDateMatch = !endDate || entryDate <= new Date(new Date(endDate).setHours(23, 59, 59));
                
                return textMatch && startDateMatch && endDateMatch;
            });
            
            renderJournalEntries(filteredEntries);
        }

        function renderJournalEntries(journalDocs) {
            journalEntriesContainer.innerHTML = '';
            if (journalDocs.length === 0) {
                journalEntriesContainer.innerHTML = '<p style="text-align: center; margin-top: 20px;">No entries to display.</p>';
                return;
            }
             // Separate pinned from unpinned entries
            const pinnedEntries = journalDocs.filter(doc => doc.data().isPinned);
            const unpinnedEntries = journalDocs.filter(doc => !doc.data().isPinned);

            const renderEntry = (doc) => {
                const entry = doc.data();
                const entryDiv = document.createElement('div');
                entryDiv.className = 'journal-entry';
                entryDiv.dataset.id = doc.id;
                const isPinned = !!entry.isPinned;
                if (isPinned) {
                    entryDiv.classList.add('pinned');
                }

                entryDiv.innerHTML = `
                    <div class="journal-entry-date">${formatFullDate(entry.date.toDate())} ${isPinned ? 'ðŸ“Œ' : ''}</div>
                    <div class="journal-entry-content"><p class="journal-entry-text">${entry.text}</p></div>
                    <div class="journal-entry-actions">
                        <button class="pin-btn">${isPinned ? 'Unpin' : 'Pin'}</button>
                        <button class="edit-btn">Edit</button>
                        <button class="delete-btn">Delete</button>
                    </div>
                `;
                journalEntriesContainer.appendChild(entryDiv);
            };

            // Render pinned entries first, then unpinned
            pinnedEntries.forEach(renderEntry);
            unpinnedEntries.forEach(renderEntry);
        }
        
        /**
         * Generates and displays a detailed XP log for a selected streak.
         */
        function generateXpHistoryHtml(streakDoc) {
            const streakData = streakDoc.data();
            const startDate = parseDate(streakData.startDate);
            const endDate = parseDate(streakData.endDate) || new Date(); 

            // 1. Gather all base events that can grant XP
            let xpEvents = [];
            const duration = calculateDuration(startDate, endDate);
            for (let d = 1; d <= duration.days; d++) {
                 let eventDate = new Date(startDate);
                 eventDate.setDate(eventDate.getDate() + d);
                 xpEvents.push({
                     date: eventDate,
                     points: 5,
                     reason: `Day ${d} maintained`
                 });
            }

            const journalEntriesDuringStreak = allJournalEntries.filter(doc => {
                const entryDate = parseDate(doc.data().date);
                return entryDate >= startDate && entryDate <= endDate;
            });
            journalEntriesDuringStreak.forEach(doc => {
                xpEvents.push({
                    date: parseDate(doc.data().date),
                    points: 5,
                    reason: 'Journal Entry'
                });
            });

            ACHIEVEMENTS_CONFIG.forEach(achievement => {
                 if (duration.days >= achievement.days) {
                      let eventDate = new Date(startDate);
                      eventDate.setDate(eventDate.getDate() + achievement.days);
                      xpEvents.push({
                          date: eventDate,
                          points: 10,
                          reason: `Badge: ${achievement.name}`
                      });
                 }
            });

            // 2. Gather check-in events (they don't grant XP)
            const checkinEvents = userCheckins
                .filter(doc => {
                    const checkinDate = parseDate(doc.data().date);
                    return checkinDate >= startDate && checkinDate <= endDate;
                })
                .map(doc => {
                    const data = doc.data();
                    const activities = [];
                    if (data.locked) activities.push('Locked');
                    if (data.sex) activities.push('Sex');
                    if (data.edged) activities.push('Edged');
                    
                    return {
                        date: parseDate(data.date),
                        type: 'checkin',
                        details: activities.length > 0 ? `Check-in: ${activities.join(', ')}` : 'Check-in: No activities'
                    };
                });

            // 3. Combine and sort all events chronologically to process them
            const chronologicalEvents = [
                ...xpEvents.map(e => ({...e, type: 'xp'})),
                ...checkinEvents
            ];
            chronologicalEvents.sort((a, b) => a.date - b.date);

            // 4. Create the final log, calculating running totals and level-ups as we go
            const finalEventsLog = [];
            let runningTotal = 0;
            let lastLevel = 1;

            chronologicalEvents.forEach(event => {
                if (event.type === 'xp') {
                    runningTotal += event.points;
                    finalEventsLog.push({ ...event, totalAfterEvent: runningTotal });
                    
                    const newLevelData = calculateLevelFromXp(runningTotal);
                    if (newLevelData.level > lastLevel) {
                        const levelUpPoints = (newLevelData.level - lastLevel) * 10;
                        runningTotal += levelUpPoints;
                        finalEventsLog.push({
                            date: event.date,
                            type: 'xp',
                            points: levelUpPoints,
                            reason: `Rank Up Bonus (Lvl ${newLevelData.level})`,
                            totalAfterEvent: runningTotal
                        });
                        lastLevel = newLevelData.level;
                    }
                } else {
                    finalEventsLog.push(event); // Add check-ins directly to the log
                }
            });
            
            // 5. Reverse for display (newest first) and build HTML
            const listItemsHtml = finalEventsLog.reverse().map(event => {
                if (event.type === 'xp') {
                    return `
                        <li>
                            <span class="xp-log-date">${formatShortDate(event.date)}</span>
                            <span class="xp-log-reason">${event.reason}</span>
                            <span class="xp-log-points">+${event.points} XP (Total: ${event.totalAfterEvent})</span>
                        </li>
                    `;
                } else { // 'checkin'
                    return `
                        <li>
                            <span class="xp-log-date">${formatShortDate(event.date)}</span>
                            <span class="xp-log-reason">${event.details}</span>
                            <span class="xp-log-points"></span>
                        </li>
                    `;
                }
            }).join('');
            
            if (finalEventsLog.length === 0){
                 return '<ul class="xp-log-list"><li>No events recorded for this period.</li></ul>';
            }

            return `<ul class="xp-log-list">${listItemsHtml}</ul>`;
        }
        
        function setAuthMode(isSignup) {
            isSignupMode = isSignup;
            authError.textContent = '';
            usernameInput.parentElement.classList.toggle('hidden', !isSignup);
            mainAuthBtn.textContent = isSignup ? 'Create Account' : 'Log In';
            toggleAuthModeBtn.textContent = isSignup ? 'Back to Log In' : 'Sign Up';
            passwordInput.setAttribute('autocomplete', isSignup ? 'new-password' : 'current-password');
        }
        
        // --- START: ADDED MISSING FUNCTIONS ---

        function setActiveTab(tabId) {
            // Hide all containers
            [dashboardContainer, logbookContainer, achievementsContainer, journalContainer, aboutContainer, profileContainer].forEach(container => {
                container.classList.add('hidden');
            });

            // Show the selected container
            const containerToShow = document.getElementById(`${tabId}-container`);
            if (containerToShow) {
                containerToShow.classList.remove('hidden');
            } else if (tabId === 'stats') { // 'stats' maps to 'logbook-container'
                logbookContainer.classList.remove('hidden');
            }


            // Update active class on nav links
            allNavLinkBtns.forEach(btn => {
                if (btn.dataset.tab === tabId) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }

        function renderStreakHistory() {
            streakHistoryContainer.innerHTML = '';
            
            // Render active streak first if it exists
            const activeStreakDoc = userLogs.find(doc => doc.data() && !doc.data().endDate);
            if (activeStreakDoc) {
                const streak = activeStreakDoc.data();
                const item = document.createElement('div');
                item.className = 'streak-history-item active'; // Always active style
                item.dataset.streakId = activeStreakDoc.id;

                const currentDuration = calculateDuration(streak.startDate, null);
                const currentRankData = calculateLevelFromXp(userData.xp || 0);

                item.innerHTML = `
                    <div class="streak-history-item-clickable">
                        <div class="streak-history-item-header">
                            <span>${formatDate(streak.startDate)} - Present</span>
                            <span id="active-streak-duration-in-log">${currentDuration.formatted}</span>
                        </div>
                        <div class="streak-history-item-details">
                            Current Rank: Lvl ${currentRankData.level} - ${currentRankData.title} (${userData.xp || 0} XP)
                        </div>
                         <div class="journal-entry-actions" style="justify-content: flex-end;">
                            <button class="end-streak-btn" data-streak-id="${activeStreakDoc.id}">End & Restart</button>
                        </div>
                    </div>
                    <div class="streak-detail-view"></div>
                `;
                streakHistoryContainer.appendChild(item);
            }


            const completedStreaks = userLogs.filter(doc => doc.data() && doc.data().endDate);
            
            if (completedStreaks.length === 0 && !activeStreakDoc) {
                 streakHistoryContainer.innerHTML = '<p style="text-align:center; font-style: italic; color: #aaa;">No streaks logged yet. Add one above to get started!</p>';
                 return;
            }

            completedStreaks.forEach(doc => {
                const streak = doc.data();
                const duration = calculateDuration(streak.startDate, streak.endDate);
                const item = document.createElement('div');
                item.className = 'streak-history-item';
                item.dataset.streakId = doc.id;

                const finalXp = streak.finalXp || calculateXpForStreak(doc, allJournalEntries);
                const rankData = calculateLevelFromXp(finalXp);

                item.innerHTML = `
                    <div class="streak-history-item-clickable">
                        <div class="streak-history-item-header">
                            <span>${formatDate(streak.startDate)} - ${formatDate(streak.endDate)}</span>
                            <span>${duration.formatted}</span>
                        </div>
                        <div class="streak-history-item-details">
                            Final Rank: Lvl ${rankData.level} - ${rankData.title} (${finalXp} XP)
                        </div>
                    </div>
                    <div class="streak-detail-view"></div>
                `;
                streakHistoryContainer.appendChild(item);
            });
        }


        async function handleUpdateUsername() {
            const user = auth.currentUser;
            if (!user) return;

            const newUsername = newUsernameInput.value.trim();
            const oldUsername = userData.username;
            usernameStatus.textContent = '';

            if (newUsername.toLowerCase() === (oldUsername || '').toLowerCase()) {
                usernameStatus.textContent = "This is already your username.";
                return;
            }

            if (!newUsername || newUsername.length < 3 || newUsername.length > 15 || /\s/.test(newUsername)) {
                usernameStatus.textContent = "Username must be 3-15 characters with no spaces.";
                return;
            }

            const newUsernameRef = db.collection('usernames').doc(newUsername.toLowerCase());
            
            try {
                const usernameDoc = await newUsernameRef.get();
                if (usernameDoc.exists) {
                    throw new Error("This username is already taken.");
                }

                const batch = db.batch();
                const userRef = db.collection('users').doc(user.uid);
                batch.update(userRef, { username: newUsername });
                batch.set(newUsernameRef, { uid: user.uid });

                if (oldUsername) {
                    const oldUsernameRef = db.collection('usernames').doc(oldUsername.toLowerCase());
                    batch.delete(oldUsernameRef);
                }

                await batch.commit();
                usernameStatus.style.color = '#27ff47';
                usernameStatus.textContent = 'Username updated successfully!';
                
                // Refresh public data if enabled
                if(userData.isPublic) {
                    updatePublicData(user);
                }

            } catch (error) {
                usernameStatus.style.color = '#ff0000';
                usernameStatus.textContent = error.message;
            }
        }
        
        async function updatePublicData(user) {
            if (!user || !userData.username) {
                console.log("Cannot update public data: User not logged in or no username set.");
                return;
            }
            const publicProfileRef = db.collection('publicProfiles').doc(user.uid);

            const activeStreak = userLogs.find(doc => doc.data() && !doc.data().endDate);
            const currentStreakStartDate = activeStreak ? activeStreak.data().startDate : null;
            
            const longestDuration = formatDurationFromMs(
                Math.max(...userLogs.map(doc => calculateDuration(doc.data().startDate, doc.data().endDate).totalMilliseconds), 0)
            );
            
            const completedStreaks = userLogs.filter(doc => doc.data().endDate);
            let avgDurationStatValue = "0 days";
            if (completedStreaks.length > 0) {
                 const totalMs = completedStreaks.reduce((acc, doc) => acc + calculateDuration(doc.data().startDate, doc.data().endDate).totalMilliseconds, 0);
                 const avgMs = totalMs / completedStreaks.length;
                 const roundedDays = Math.round(avgMs / (1000 * 60 * 60 * 24));
                 avgDurationStatValue = `${roundedDays} days`;
            }

            const currentXp = activeStreak ? calculateXpForStreak(activeStreak, allJournalEntries) : 0;
            const levelData = calculateLevelFromXp(currentXp);
            
            const highestRankData = userLogs.reduce((highest, doc) => {
                 const finalXp = doc.data().endDate ? (doc.data().finalXp || calculateXpForStreak(doc, allJournalEntries)) : currentXp;
                 const rank = calculateLevelFromXp(finalXp);
                 return rank.level > highest.level ? rank : highest;
            }, {level: 1, title: 'NOVICE'});

            // Correctly filter all badge types for the public profile
            const allBadges = [...ACHIEVEMENTS_CONFIG, ...LEVEL_BADGES_CONFIG];
            const unlockedAchievements = allBadges.filter(badge => {
                if (badge.days !== undefined) {
                    return activeStreak && calculateDuration(currentStreakStartDate, null).days >= badge.days;
                } else if (badge.level !== undefined) {
                    return levelData.level >= badge.level;
                }
                return false;
            });


            const publicData = {
                displayName: userData.username,
                currentStreakStartDate: currentStreakStartDate,
                goal: userData.goal || null,
                goalDate: userData.goalDate || null,
                longestStreakDays: longestDuration.days,
                averageStreakDuration: avgDurationStatValue,
                totalDaysThisYear: calculateTotalDaysThisYear(userLogs),
                level: levelData.level,
                title: levelData.title,
                highestRankEver: highestRankData,
                logs: userLogs.map(doc => doc.data()),
                publicSettings: userData.publicSettings || {},
                unlockedAchievements: unlockedAchievements
            };

            try {
                await publicProfileRef.set(publicData);
                console.log("Public profile updated.");
            } catch (error) {
                console.error("Error updating public profile:", error);
            }
        }

        function downloadCsv(csvContent, fileName) {
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            link.setAttribute("download", fileName);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function exportLogsToCsv() {
            if (userLogs.length === 0) return;
            const headers = '"Start Date","End Date","Duration (Formatted)"';
            const rows = userLogs.map(doc => {
                const log = doc.data();
                const start = formatFullDate(parseDate(log.startDate));
                const end = log.endDate ? formatFullDate(parseDate(log.endDate)) : 'Ongoing';
                const duration = calculateDuration(log.startDate, log.endDate).formatted;
                return `"${start}","${end}","${duration}"`;
            });
            const csv = [headers, ...rows].join('\n');
            downloadCsv(csv, 'streaker_logs.csv');
        }

        function exportJournalToCsv() {
            if (allJournalEntries.length === 0) return;
            const headers = '"Date","Entry Text"';
            const rows = allJournalEntries.map(doc => {
                const entry = doc.data();
                const date = formatFullDate(parseDate(entry.date));
                const text = entry.text.replace(/"/g, '""'); // Escape double quotes
                return `"${date}","${text}"`;
            });
            const csv = [headers, ...rows].join('\n');
            downloadCsv(csv, 'streaker_journal.csv');
        }

        // --- END: ADDED MISSING FUNCTIONS ---

        toggleAuthModeBtn.addEventListener('click', () => setAuthMode(!isSignupMode));

        authForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const email = emailInput.value;
            const password = passwordInput.value;
            const username = usernameInput.value.trim();
            authError.textContent = '';

            try {
                if (isSignupMode) {
                    if (!username || username.length < 3 || username.length > 15 || /\s/.test(username)) {
                        throw new Error("Username must be 3-15 characters with no spaces.");
                    }
                    const usernameDoc = await db.collection('usernames').doc(username.toLowerCase()).get();
                    if (usernameDoc.exists) throw new Error("This username is already taken.");

                    const userCredential = await auth.createUserWithEmailAndPassword(email, password);
                    const user = userCredential.user;

                    const userRef = db.collection('users').doc(user.uid);
                    const usernameRef = db.collection('usernames').doc(username.toLowerCase());
                    
                    const batch = db.batch();
                    batch.set(userRef, { username, email: user.email, createdAt: firebase.firestore.FieldValue.serverTimestamp() });
                    batch.set(usernameRef, { uid: user.uid });
                    await batch.commit();
                } else {
                    await auth.signInWithEmailAndPassword(email, password);
                }
            } catch (error) {
                authError.textContent = error.message;
            }
        });


        function addMainAppEventListeners() {
            if (mainAppListenersAdded) return;

            document.querySelectorAll('.sidebar-nav, .mobile-nav').forEach(nav => {
                nav.addEventListener('click', (e) => {
                    const navLink = e.target.closest('.nav-link');
                    if(navLink) {
                        setActiveTab(navLink.dataset.tab);
                    }
                });
            });
            
            newLogoutBtn.addEventListener('click', () => auth.signOut());

            // NEW: Event listeners for export buttons
            exportLogsBtn.addEventListener('click', exportLogsToCsv);
            exportJournalBtn.addEventListener('click', exportJournalToCsv);


            publicProfileToggle.addEventListener('change', async (e) => {
                const isPublic = e.target.checked;
                const user = auth.currentUser;
                if (!user) return;
                try {
                    await db.collection('users').doc(user.uid).update({ isPublic });
                    publicLinkContainer.classList.toggle('hidden', !isPublic);
                    publicCardsSelection.classList.toggle('hidden', !isPublic); // UPDATED
                    if (isPublic) {
                        updatePublicData(user);
                    }
                } catch (error) {
                    console.error("Error updating public profile status:", error);
                }
            });

            // UPDATED: New listener for card visibility toggles
            publicCardsSelection.addEventListener('change', async (e) => {
                if (e.target.type !== 'checkbox') return;

                const user = auth.currentUser;
                if (!user) return;

                const publicSettingToggles = document.querySelectorAll('#public-cards-selection input[type="checkbox"]');
                const newSettings = {};
                publicSettingToggles.forEach(toggle => {
                    newSettings[toggle.dataset.setting] = toggle.checked;
                });

                try {
                    // UPDATED: Use set with merge to ensure the settings field is created if it doesn't exist
                    await db.collection('users').doc(user.uid).set({ publicSettings: newSettings }, { merge: true });
                    updatePublicData(user); // Refresh public data immediately after a change
                } catch (error) {
                    console.error("Error updating public settings:", error);
                }
            });
            
            copyPublicLinkBtn.addEventListener('click', () => {
                publicLinkDisplay.select();
                document.execCommand('copy');
                copyPublicLinkBtn.textContent = 'Copied!';
                setTimeout(() => {
                    copyPublicLinkBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>`;
                }, 2000);
            });

            saveUsernameBtn.addEventListener('click', handleUpdateUsername);

            goalInput.addEventListener('input', () => {
                if (isUpdatingGoal) return;
                isUpdatingGoal = true;

                const goalDays = parseInt(goalInput.value, 10);
                
                if (goalDays > 0) {
                    updateGoalProgress(goalDays); // Update progress bar
                    const currentStreak = userLogs.find(doc => !doc.data().endDate);
                    if (currentStreak) {
                        const projectedDate = parseDate(currentStreak.data().startDate);
                        projectedDate.setDate(projectedDate.getDate() + goalDays);
                        const formattedDate = projectedDate.toISOString().split('T')[0];
                        
                        goalDateInput.value = formattedDate; 

                        goalDate.textContent = `Goal of ${goalDays} days reached on: ${formatDate(formattedDate)}`;
                        renderCondensedCalendar(displayedYear, userLogs, formattedDate, '#condensed-calendar-container', '#current-year-label', calendarMonthsToShow);
                    } else {
                        goalDateInput.value = ''; // Clear date if no active streak
                        goalDate.textContent = 'Start a streak to see goal date.';
                        renderCondensedCalendar(displayedYear, userLogs, null, '#condensed-calendar-container', '#current-year-label', calendarMonthsToShow);
                    }
                } else {
                    // Clear everything if input is invalid
                    goalDateInput.value = '';
                    updateGoalProgress(null);
                    goalDate.textContent = '';
                    renderCondensedCalendar(displayedYear, userLogs, null, '#condensed-calendar-container', '#current-year-label', calendarMonthsToShow);
                }
                isUpdatingGoal = false;
            });

            goalDateInput.addEventListener('input', () => {
                if (isUpdatingGoal) return;
                isUpdatingGoal = true;

                const goalDateValue = goalDateInput.value;
                goalInput.value = ''; // Mutually exclusive

                if (goalDateValue) {
                    const currentStreak = userLogs.find(doc => !doc.data().endDate);
                    if (currentStreak) {
                        const startDate = parseDate(currentStreak.data().startDate);
                        const targetDate = parseDate(goalDateValue);
                        const totalGoalDays = calculateDuration(startDate, targetDate).days;

                        if (totalGoalDays > 0) {
                            goalInput.value = totalGoalDays; // Set the days input for consistency
                            updateGoalProgress(totalGoalDays);
                             goalDate.textContent = `Goal set for: ${formatDate(goalDateValue)}`;
                        } else {
                             updateGoalProgress(null);
                             goalDate.textContent = 'Date must be in the future.';
                        }
                    } else {
                        updateGoalProgress(null);
                        goalDate.textContent = 'Start a streak to set a goal date.';
                    }
                    renderCondensedCalendar(displayedYear, userLogs, goalDateValue, '#condensed-calendar-container', '#current-year-label', calendarMonthsToShow);
                } else {
                    // Clear everything if input is invalid
                    updateGoalProgress(null);
                    goalDate.textContent = '';
                    renderCondensedCalendar(displayedYear, userLogs, null, '#condensed-calendar-container', '#current-year-label', calendarMonthsToShow);
                }

                isUpdatingGoal = false;
            });
            
            document.getElementById('set-goal-btn').addEventListener('click', async () => {
                const user = auth.currentUser;
                if (!user) return;
                
                const goalDays = goalInput.value ? parseInt(goalInput.value, 10) : null;
                const goalDateValue = goalDateInput.value || null;

                const goalData = {
                    goal: goalDays,
                    goalDate: goalDateValue
                };
                
                await db.collection('users').doc(user.uid).set(goalData, { merge: true });
            });

            document.getElementById('prev-year-btn').addEventListener('click', () => {
                displayedYear--;
                renderCondensedCalendar(displayedYear, userLogs, userData.goalDate, '#condensed-calendar-container', '#current-year-label', calendarMonthsToShow);
            });
            document.getElementById('next-year-btn').addEventListener('click', () => {
                if (displayedYear < new Date().getFullYear()) {
                    displayedYear++;
                    renderCondensedCalendar(displayedYear, userLogs, userData.goalDate, '#condensed-calendar-container', '#current-year-label', calendarMonthsToShow);
                }
            });
            
            journalSearchInput.addEventListener('input', applyAndRenderJournalFilters);
            journalFilterStartDate.addEventListener('change', applyAndRenderJournalFilters);
            journalFilterEndDate.addEventListener('change', applyAndRenderJournalFilters);
            journalFilterClearBtn.addEventListener('click', () => {
                journalSearchInput.value = '';
                journalFilterStartDate.value = '';
                journalFilterEndDate.value = '';
                applyAndRenderJournalFilters();
            });

            checkinForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const user = auth.currentUser;
                if (!user) return;

                const todayString = getTodayDateString();
                
                const checkinData = {
                    locked: checkinLocked.checked,
                    sex: checkinSex.checked,
                    edged: checkinEdged.checked,
                    date: firebase.firestore.Timestamp.now() // Store timestamp for sorting
                };

                try {
                    await db.collection('users').doc(user.uid).collection('checkins').doc(todayString).set(checkinData, { merge: true });
                } catch (error) {
                    console.error("Error saving check-in: ", error);
                }
            });

            entryForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const startDateString = startDateInput.value;
                const endDateString = endDateInput.value;
                const user = auth.currentUser;
                
                const hasOngoing = userLogs.some(doc => !doc.data().endDate);
                if (hasOngoing && !endDateString) {
                    // Using a custom message or console log instead of alert()
                    console.warn("You can only have one ongoing streak at a time. End your current one first.");
                    authError.textContent = "You can only have one ongoing streak at a time.";
                    setTimeout(() => authError.textContent = '', 3000);
                    return;
                }
                if (endDateString && startDateString >= endDateString) {
                    console.warn("End date must be after start date.");
                    authError.textContent = "End date must be after start date.";
                    setTimeout(() => authError.textContent = '', 3000);
                    return;
                }

                if (user && startDateString) {
                    const startDate = new Date(startDateString);
                    const endDate = endDateString ? new Date(endDateString) : null;

                    await db.collection('users').doc(user.uid).collection('logs').add({ 
                        startDate: firebase.firestore.Timestamp.fromDate(startDate),
                        endDate: endDate ? firebase.firestore.Timestamp.fromDate(endDate) : null 
                    });
                    entryForm.reset();
                }
            });

            journalForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const text = journalInput.value.trim();
                const user = auth.currentUser;

                if (user && text) {
                    await db.collection('users').doc(user.uid).collection('journal').add({
                        text,
                        date: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    showXpToast(5, 'Journal Entry');
                    journalInput.value = '';
                }
            });
            
            journalEntriesContainer.addEventListener('click', async (e) => {
                const user = auth.currentUser;
                if (!user) return;
                const entryDiv = e.target.closest('.journal-entry');
                if (!entryDiv) return;
                const docId = entryDiv.dataset.id;
                const entryRef = db.collection('users').doc(user.uid).collection('journal').doc(docId);
                
                if (e.target.classList.contains('delete-btn')) {
                    // FIX: Removed the confirm() dialog which can be problematic.
                    await entryRef.delete();
                } else if (e.target.classList.contains('edit-btn')) {
                    const contentDiv = entryDiv.querySelector('.journal-entry-content');
                    const currentText = contentDiv.querySelector('p').textContent;
                    contentDiv.innerHTML = `<textarea class="journal-edit-area">${currentText}</textarea><button class="save-btn">Save</button>`;
                } else if (e.target.classList.contains('save-btn')) {
                    const newText = entryDiv.querySelector('.journal-edit-area').value.trim();
                    if (newText) await entryRef.update({ text: newText });
                } else if (e.target.classList.contains('pin-btn')) {
                    const docSnapshot = await entryRef.get();
                    if (docSnapshot.exists) {
                        const isCurrentlyPinned = !!docSnapshot.data().isPinned;
                        await entryRef.update({ isPinned: !isCurrentlyPinned });
                    }
                }
            });
            
             // --- Event listener for streak history accordion ---
            streakHistoryContainer.addEventListener('click', async (e) => {
                // Handle End & Restart button click first
                if (e.target.classList.contains('end-streak-btn')) {
                    const user = auth.currentUser;
                    if (!user) return;
                 const streakId = e.target.dataset.streakId;
                 const activeStreakDoc = userLogs.find(doc => doc.id === streakId);
                 if (activeStreakDoc) {
                      const now = firebase.firestore.Timestamp.now();
                         const finalXp = calculateXpForStreak(activeStreakDoc, allJournalEntries);

                         const batch = db.batch();
                         const logRef = db.collection('users').doc(user.uid).collection('logs').doc(streakId);
                         batch.update(logRef, { endDate: now, finalXp: finalXp });

                         const newLogRef = db.collection('users').doc(user.uid).collection('logs').doc(); // Auto-generate ID
                         batch.set(newLogRef, { startDate: now, endDate: null });
                         
                         // Reset the announced level tracker for the new streak
                         const userRef = db.collection('users').doc(user.uid);
                         batch.update(userRef, { highestAnnouncedLevelForCurrentStreak: 0 });

                         await batch.commit();
                    }
                    return; // Stop further execution for this button
                }

                const clickableArea = e.target.closest('.streak-history-item-clickable');
                if (!clickableArea) return;

                const item = clickableArea.parentElement;
                const detailView = item.querySelector('.streak-detail-view');
                const isOpen = detailView.classList.contains('visible');

                // Close any other open items
                document.querySelectorAll('.streak-detail-view.visible').forEach(openDetail => {
                    if (openDetail !== detailView) {
                        openDetail.classList.remove('visible');
                        openDetail.parentElement.classList.remove('active');
                        openDetail.innerHTML = ''; // Clear content to save memory
                    }
                });

                // If the clicked item was already open, close it. Otherwise, open it.
                if (isOpen) {
                    detailView.classList.remove('visible');
                    item.classList.remove('active');
                    detailView.innerHTML = '';
                } else {
                    item.classList.add('active');
                    const streakId = item.dataset.streakId;
                    const selectedStreakDoc = userLogs.find(doc => doc.id === streakId);
                    
                    if (selectedStreakDoc) {
                        // Generate and inject content, then show
                        detailView.innerHTML = generateXpHistoryHtml(selectedStreakDoc);
                        detailView.classList.add('visible');
                    }
                }
            });

              // --- NEW: Event Listeners for levels modal ---
            document.getElementById('rank-header-stats').addEventListener('click', showLevelsModal);
            closeLevelsModalBtn.addEventListener('click', hideLevelsModal);
            levelsModal.addEventListener('click', (e) => {
                if (e.target === levelsModal) {
                    hideLevelsModal();
                }
            });

            populateRankSelector();
            rankProjectionSelect.addEventListener('change', updateRankProjection);

              // Calendar View Toggle
            calendarViewToggle.addEventListener('click', (e) => {
                if (e.target.tagName === 'BUTTON') {
                    calendarViewToggle.querySelector('.active').classList.remove('active');
                    e.target.classList.add('active');
                    calendarMonthsToShow = parseInt(e.target.dataset.view, 10);
                    renderCondensedCalendar(displayedYear, userLogs, userData.goalDate, '#condensed-calendar-container', '#current-year-label', calendarMonthsToShow);
                }
            });

            mainAppListenersAdded = true;
        }


        function initializeAppForUser(user) {
            authContainer.classList.add('hidden');
            appLayout.classList.remove('hidden');
            addMainAppEventListeners();

            const logsCollection = db.collection('users').doc(user.uid).collection('logs');
            const journalCollection = db.collection('users').doc(user.uid).collection('journal');
            const userDocRef = db.collection('users').doc(user.uid);


            logsCollection.orderBy('startDate', 'desc').onSnapshot(snapshot => {
                userLogs = snapshot.docs.filter(doc => doc.data().startDate);
                // This order is critical to prevent race conditions.
                // XP must be calculated before achievements are rendered.
                calculateAndSetCurrentStreakXp().then(() => {
                    calculateStats();
                    renderAchievements(); // FIX: This is the correct place to call this.
                    renderStreakHistory();
                    if (userData.isPublic) {
                        updatePublicData(user);
                    }
                });
            });
            
             // MODIFIED: No longer sorting by 'isPinned' in the query
            journalCollection.orderBy('date', 'desc').onSnapshot(snapshot => {
                allJournalEntries = snapshot.docs;
                // Client-side sort for pinning
                allJournalEntries.sort((a, b) => {
                    // FIX: Added checks to prevent errors on malformed data.
                    const aData = a.data() || {};
                    const bData = b.data() || {};
                    const aPinned = aData.isPinned || false;
                    const bPinned = bData.isPinned || false;
                    
                    // Use a default old date if timestamp is missing to prevent crash
                    const aDate = aData.date && aData.date.toMillis ? aData.date.toMillis() : 0;
                    const bDate = bData.date && bData.date.toMillis ? bData.date.toMillis() : 0;


                    if (aPinned && !bPinned) return -1;
                    if (!aPinned && bPinned) return 1;
                    return bDate - aDate; // If both are same pinned status, sort by date
                });
                applyAndRenderJournalFilters(); 
                calculateAndSetCurrentStreakXp().then(() => {
                    if (userData.isPublic) {
                        updatePublicData(user);
                    }
                });
            });

            const checkinsCollection = db.collection('users').doc(user.uid).collection('checkins');
            checkinsCollection.onSnapshot(snapshot => {
                userCheckins = snapshot.docs;
                renderDailyCheckin();
                // We need to re-render history if check-ins change, as they appear in the log
                renderStreakHistory();
            });

            userDocRef.onSnapshot((doc) => {
                if (doc.exists) {
                    const dbData = doc.data();
                    // Merge data from DB without overwriting client-side calculated XP.
                    userData = { ...dbData, xp: userData.xp };
                    
                    // Sync client-side tracker with Firestore
                    highestAnnouncedLevelClient = userData.highestAnnouncedLevelForCurrentStreak || 0;
                    
                    userProfileDisplay.textContent = userData.username || user.email;
                    
                    const isPublic = !!userData.isPublic;
                    publicProfileToggle.checked = isPublic;
                    publicLinkContainer.classList.toggle('hidden', !isPublic);
                    publicCardsSelection.classList.toggle('hidden', !isPublic); // UPDATED

                    // UPDATED: Set checked state for card visibility toggles
                    const publicSettingToggles = document.querySelectorAll('#public-cards-selection input[type="checkbox"]');
                    const defaultSettings = {
                        showCurrentStreak: true,
                        showGoalProgress: true,
                        showLongestStreak: true,
                        showAverageStreak: true,
                        showTotalDaysYear: true,
                        showHighestRank: true,
                        showAchievements: true,
                        showHistory: true,
                        showCalendar: true
                    };
                    const settings = { ...defaultSettings, ...(userData.publicSettings || {}) };

                    publicSettingToggles.forEach(toggle => {
                        const settingKey = toggle.dataset.setting;
                        toggle.checked = settings[settingKey];
                    });


                    if(isPublic && userData.username) {
                        const baseUrl = window.location.href.split(/[?#]/)[0]; // Get base URL without params or hash
                        publicLinkDisplay.value = `${baseUrl}#${userData.username}`;
                    } else {
                        publicLinkDisplay.value = '';
                    }

                    if (!isUpdatingGoal) {
                        goalInput.value = userData.goal || '';
                        goalDateInput.value = userData.goalDate || '';
                        
                        if (userData.goal) {
                            updateGoalProgress(userData.goal);
                            const currentStreak = userLogs.find(doc => !doc.data().endDate);
                            if (currentStreak) {
                                const projectedDate = parseDate(currentStreak.data().startDate);
                                projectedDate.setDate(projectedDate.getDate() + userData.goal);
                                const formattedDate = projectedDate.toISOString().split('T')[0];
                                goalDate.textContent = `Goal of ${userData.goal} days reached on: ${formatDate(formattedDate)}`;
                                renderCondensedCalendar(displayedYear, userLogs, formattedDate, '#condensed-calendar-container', '#current-year-label', calendarMonthsToShow);
                            } else { 
                                goalDate.textContent = 'Start a streak to see goal date.';
                                renderCondensedCalendar(displayedYear, userLogs, null, '#condensed-calendar-container', '#current-year-label', calendarMonthsToShow);
                            } 
                        } else if (userData.goalDate) {
                            const currentStreak = userLogs.find(doc => !doc.data().endDate);
                            if(currentStreak){
                                const startDate = parseDate(currentStreak.data().startDate);
                                const targetDate = parseDate(userData.goalDate);
                                const totalGoalDays = calculateDuration(startDate, targetDate).days;
                                if (totalGoalDays > 0) {
                                    updateGoalProgress(totalGoalDays);
                                }
                            }
                            goalDate.textContent = `Goal set for: ${formatDate(userData.goalDate)}`;
                            renderCondensedCalendar(displayedYear, userLogs, userData.goalDate, '#condensed-calendar-container', '#current-year-label', calendarMonthsToShow);
                        } else {
                            updateGoalProgress(null);
                            goalDate.textContent = '';
                            renderCondensedCalendar(displayedYear, userLogs, null, '#condensed-calendar-container', '#current-year-label', calendarMonthsToShow);
                        }
                    }
                }
            });
            
            setActiveTab('dashboard');
        }

        function showLoginScreen() {
            [appLayout, publicViewContainer].forEach(c => c.classList.add('hidden'));
            authContainer.classList.remove('hidden');
            setAuthMode(false);
        }
        
        function updatePublicDynamicElements(data) {
            const daysEl = document.getElementById('public-streak-days');
            if (!daysEl) return; 

            const currentDuration = calculateDuration(data.currentStreakStartDate, null);

            daysEl.textContent = currentDuration.days;
            document.getElementById('public-streak-hours').textContent = String(currentDuration.hours).padStart(2, '0');
            document.getElementById('public-streak-minutes').textContent = String(currentDuration.minutes).padStart(2, '0');
            document.getElementById('public-streak-seconds').textContent = String(currentDuration.seconds).padStart(2, '0');

            const now = new Date();
            const secondsToday = now.getSeconds() + (now.getMinutes() * 60) + (now.getHours() * 3600);
            const progressPercentDaily = (secondsToday / 86400);
            const barWidth = 20;
            const filledChars = Math.round(barWidth * progressPercentDaily);
            const emptyChars = barWidth - filledChars;
            const progressBarEl = document.getElementById('public-daily-progress-bar');
            if(progressBarEl) progressBarEl.textContent = `[${'â–ˆ'.repeat(filledChars)}${'â–‘'.repeat(emptyChars)}]`;
            
            const goalContainer = document.getElementById('public-goal-progress-container');
            if (goalContainer) {
                if (data.goal || data.goalDate) {
                    goalContainer.classList.remove('hidden');
                    const currentStreakDays = data.currentStreakStartDate ? currentDuration.days : 0;
                    let totalGoalDays = data.goal; // Default to goal in days if it exists
                    let goalDateText = '';

                    // If a goal date is set, it's the source of truth for total days
                    if (data.goalDate && data.currentStreakStartDate) {
                        const startDate = parseDate(data.currentStreakStartDate);
                        const targetDate = parseDate(data.goalDate);
                        if (startDate && targetDate && targetDate > startDate) {
                            totalGoalDays = calculateDuration(startDate, targetDate).days;
                        }
                    }

                    // Now, construct the display text
                    if (totalGoalDays) {
                        if (data.goalDate) {
                             goalDateText = `Goal: ${totalGoalDays} days (by ${formatDate(data.goalDate)})`;
                        } else if (data.currentStreakStartDate) {
                             const projectedDate = parseDate(data.currentStreakStartDate);
                             projectedDate.setDate(projectedDate.getDate() + totalGoalDays);
                             goalDateText = `Goal: ${totalGoalDays} days (ends approx. ${formatDate(projectedDate)})`;
                        } else {
                             goalDateText = `Goal: ${totalGoalDays} days`;
                        }
                    } else if (data.goalDate) {
                        // This case handles when a date is set but there's no active streak to calculate from.
                        goalDateText = `Goal set for: ${formatDate(data.goalDate)}`;
                    }

                    
                    const progressPercentage = totalGoalDays > 0 ? Math.min((currentStreakDays / totalGoalDays) * 100, 100) : 0;
                    const remainingDays = totalGoalDays > 0 ? Math.max(0, totalGoalDays - currentStreakDays) : 0;
                    const progressTextContent = remainingDays > 0 ? `${Math.round(progressPercentage)}% (${remainingDays} ${remainingDays === 1 ? 'day' : 'days'} remaining)` : `${Math.round(progressPercentage)}% (Goal reached!)`;

                    document.getElementById('public-progress-bar').style.width = `${progressPercentage}%`;
                    document.getElementById('public-progress-text').textContent = progressTextContent;
                    document.getElementById('public-goal-date').textContent = goalDateText;
                } else {
                    goalContainer.classList.add('hidden');
                }
            }
        }

        function renderPublicView(data) {
            if (publicInterval) clearInterval(publicInterval);

            const defaultSettings = {
                showCurrentStreak: true, showGoalProgress: true, showLongestStreak: true,
                showAverageStreak: true, showAchievements: true, showHistory: true, showCalendar: true,
                showTotalDaysYear: true, showHighestRank: true
            };
            const settings = { ...defaultSettings, ...(data.publicSettings || {}) };
            
            let viewHTML = `
                <div class="header">
                    <div class="logo-and-title">
                        <img src="https://raw.githubusercontent.com/rynwynk/streaker-app/main/logo%20only.png" alt="Streaker Logo" class="logo">
                        <div><h2>Streaker</h2><p class="subtitle">Satisfied Through Denial</p></div>
                    </div>
                </div>
                <h2 class="stats-section-header" style="margin-top:0; margin-bottom: 0;">Public Profile for ${data.displayName}</h2>
                <p class="clickable-level public-level-display" style="text-align: center; font-size: 1.1em; margin-top: 5px; margin-bottom: 20px;">LEVEL: ${data.level || 1} - ${data.title || 'NOVICE'}</p>
            `;

            if (settings.showCurrentStreak) {
                viewHTML += `
                    <div class="stat-card" style="margin-bottom: 30px;">
                        <h3>Current Streak</h3>
                        <div class="streak-counter-layout">
                            <div id="public-streak-digital-clock" class="digital-clock"><span id="public-streak-days">0</span><span class="unit-label">d</span><span id="public-streak-hours">00</span><span class="unit-label">h</span><span id="public-streak-minutes">00</span><span class="unit-label">m</span><span id="public-streak-seconds">00</span><span class="unit-label">s</span></div>
                            <pre id="public-daily-progress-bar" class="progress-bar-ascii"></pre>
                        </div>
                    </div>`;
            }

            if (settings.showGoalProgress) {
                viewHTML += `
                    <div id="public-goal-progress-container" class="stat-card hidden" style="margin-bottom: 30px;">
                        <h3 style="font-size: 1.5em;">Goal Progress</h3><p class="subtitle" style="text-align: center; margin-bottom: 15px; font-size: 0.7em;">Tomorrow Never Cums</p>
                        <div class="progress-bar-container"><div id="public-progress-bar" class="progress-bar" style="width: 0%;"></div></div>
                        <p id="public-progress-text" class="progress-text" style="font-size: 1.2em; margin-top: 5px;">0%</p>
                        <p id="public-goal-date" style="font-size: 0.8em; margin-top: 5px; min-height: 1em;"></p>
                    </div>`;
            }
            
            let statsGridHTML = '';
            if (settings.showLongestStreak) {
                 statsGridHTML += `<div class="stat-card"><h3>Longest Streak</h3><p>${data.longestStreakDays} days</p></div>`;
            }
            if (settings.showAverageStreak) {
                 statsGridHTML += `<div class="stat-card"><h3>Average Streak</h3><p>${data.averageStreakDuration || '0 days'}</p></div>`;
            }
            if (settings.showTotalDaysYear) {
                 statsGridHTML += `<div class="stat-card"><h3>Total Days This Year</h3><p>${data.totalDaysThisYear || 0} days</p></div>`;
            }
            if (settings.showHighestRank && data.highestRankEver) {
                 statsGridHTML += `<div class="stat-card"><h3>Highest Rank Ever</h3><p>Lvl ${data.highestRankEver.level} - ${data.highestRankEver.title}</p></div>`;
            }
            if (statsGridHTML) {
                viewHTML += `<div class="stats-grid">${statsGridHTML}</div>`;
            }

            if (settings.showAchievements) {
                 const achievementsHTML = data.unlockedAchievements && data.unlockedAchievements.length > 0
                ? data.unlockedAchievements.map(ach => `<div class="badge-card"><div class="badge-icon unlocked">${ach.icon}</div><div class="badge-name">${ach.name}</div></div>`).join('')
                : '<p style="text-align:center; font-style: italic; color: #aaa; grid-column: 1 / -1;">No achievements on current streak.</p>';
                viewHTML += `
                    <h2 class="stats-section-header">Achievements</h2><div class="achievements-grid">${achievementsHTML}</div>`;
            }
            
            if (settings.showHistory) {
                const streakHistoryLogs = (data.logs || []).filter(log => log.endDate).sort((a, b) => parseDate(b.startDate) - parseDate(a.startDate));
                const streakHistoryHTML = streakHistoryLogs.length > 0
                ? `<table><thead><tr><th>Start Date</th><th>End Date</th><th>Duration</th></tr></thead><tbody>
                    ${streakHistoryLogs.map(log => `<tr><td data-label="Start Date">${formatFullDate(parseDate(log.startDate))}</td><td data-label="End Date">${formatFullDate(parseDate(log.endDate))}</td><td data-label="Duration">${calculateDuration(log.startDate, log.endDate).formatted}</td></tr>`).join('')}
                    </tbody></table>`
                : '<p style="text-align:center; font-style: italic; color: #aaa;">No completed streaks in history.</p>';
                viewHTML += `<h2 class="stats-section-header">Streak History</h2><div id="public-streak-history-container">${streakHistoryHTML}</div>`;
            }

            if (settings.showCalendar) {
                viewHTML += `
                    <div class="stats-section-header year-nav">
                        <button id="public-prev-year-btn" title="Previous Year">&lt;</button>
                        <h2 style="margin: 0;">Year in Review (<span id="public-current-year-label">${new Date().getFullYear()}</span>)</h2>
                        <button id="public-next-year-btn" title="Next Year">&gt;</button>
                    </div>
                    <div id="public-calendar-view-toggle" class="calendar-view-toggle button-group" style="justify-content: center; margin-top: 10px;">
                        <button data-view="1" class="view-toggle-btn">Month</button>
                        <button data-view="3" class="view-toggle-btn">3 Months</button>
                        <button data-view="6" class="view-toggle-btn">6 Months</button>
                        <button data-view="12" class="view-toggle-btn active">Year</button>
                    </div>
                    <div id="public-condensed-calendar-container"></div>
                    <p style="text-align: center; font-size: 0.8em; margin-top: 15px;">
                        <span style="display: inline-block; width: 12px; height: 12px; background-color: #27ff47;"></span> Active
                        <span style="display: inline-block; width: 12px; height: 12px; background-color: #ff8c00; margin-left: 15px;"></span> Ended
                        <span style="display: inline-block; width: 12px; height: 12px; background: linear-gradient(135deg, #ff8c00 49%, #27ff47 51%); margin-left: 15px;"></span> Ended & Restarted
                        <span style="margin-left: 15px;">ðŸŽ¯ Goal</span>
                    </p>`;
            }

            publicViewContainer.innerHTML = viewHTML;
            
            // Add listener for the new clickable level on the public page
            const publicLevelDisplay = publicViewContainer.querySelector('.public-level-display');
            if (publicLevelDisplay) {
                publicLevelDisplay.addEventListener('click', showLevelsModal);
            }
            
            // --- NEW: Logic for public calendar ---
            let publicDisplayedYear = new Date().getFullYear();
            let publicCalendarMonthsToShow = 12;

            const redrawPublicCalendar = () => {
                renderCondensedCalendar(
                    publicDisplayedYear,
                    data.logs || [],
                    data.goalDate,
                    '#public-condensed-calendar-container',
                    '#public-current-year-label',
                    publicCalendarMonthsToShow
                );
            };
            
            const publicPrevYearBtn = document.getElementById('public-prev-year-btn');
            const publicNextYearBtn = document.getElementById('public-next-year-btn');
            const publicCalendarViewToggle = document.getElementById('public-calendar-view-toggle');

            if (publicPrevYearBtn) {
                publicPrevYearBtn.addEventListener('click', () => {
                    publicDisplayedYear--;
                    redrawPublicCalendar();
                });
            }
            if (publicNextYearBtn) {
                publicNextYearBtn.addEventListener('click', () => {
                    if (publicDisplayedYear < new Date().getFullYear()) {
                        publicDisplayedYear++;
                        redrawPublicCalendar();
                    }
                });
            }
            if (publicCalendarViewToggle) {
                publicCalendarViewToggle.addEventListener('click', (e) => {
                    if (e.target.tagName === 'BUTTON') {
                        publicCalendarViewToggle.querySelector('.active').classList.remove('active');
                        e.target.classList.add('active');
                        publicCalendarMonthsToShow = parseInt(e.target.dataset.view, 10);
                        redrawPublicCalendar();
                    }
                });
            }

            // Initial render
            if (settings.showCalendar) {
                redrawPublicCalendar();
            }

            const updateElements = () => updatePublicDynamicElements(data);
            
            if (data.currentStreakStartDate) {
                updateElements();
                publicInterval = setInterval(updateElements, 1000);
            } else {
                updateElements();
            }
        }

        function populateRankSelector() {
            rankProjectionSelect.innerHTML = '';
            LEVEL_CONFIG.forEach(level => {
                // Start from the next level up from Novice
                if (level.level > 1) { 
                    const option = document.createElement('option');
                    option.value = level.level;
                    option.textContent = `Lvl ${level.level}: ${level.title}`;
                    rankProjectionSelect.appendChild(option);
                }
            });
             // Set a default selection
            if (rankProjectionSelect.options.length > 0) {
                rankProjectionSelect.selectedIndex = 0;
            }
        }

        function getTodayDateString() {
            const today = new Date();
            const year = today.getFullYear();
            const month = String(today.getMonth() + 1).padStart(2, '0');
            const day = String(today.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function renderDailyCheckin() {
            const todayString = getTodayDateString();
            const todayDate = new Date(todayString + 'T00:00:00');
            dailyCheckinHeader.textContent = `Daily Check-in for ${formatDate(todayDate)}`;

            const todaysCheckinDoc = userCheckins.find(doc => doc.id === todayString);
            
            if (todaysCheckinDoc) {
                const data = todaysCheckinDoc.data();
                checkinLocked.checked = data.locked || false;
                checkinSex.checked = data.sex || false;
                checkinEdged.checked = data.edged || false;
            } else {
                checkinLocked.checked = false;
                checkinSex.checked = false;
                checkinEdged.checked = false;
            }
        }

        function startApp() {
            // Check for public profile username in URL hash first
            let publicUsername = null;
            if (window.location.hash) {
                publicUsername = window.location.hash.substring(1); // Remove the '#'
            } else {
                // Fallback to old query parameter for backward compatibility
                const urlParams = new URLSearchParams(window.location.search);
                publicUsername = urlParams.get('username');
            }
            
            auth.onAuthStateChanged(user => {
                loadingContainer.classList.add('hidden');
                if (publicUsername) {
                    publicViewContainer.classList.remove('hidden');
                    db.collection('usernames').doc(publicUsername.toLowerCase()).get()
                        .then(usernameDoc => {
                            if (usernameDoc.exists) {
                                const uid = usernameDoc.data().uid;
                                db.collection('publicProfiles').doc(uid).onSnapshot(profileDoc => {
                                    if (profileDoc.exists) {
                                        renderPublicView(profileDoc.data());
                                    } else {
                                         publicViewContainer.innerHTML = `<p style="text-align:center;">Could not load profile for "${publicUsername}". The owner may need to refresh their public data from the Profile page.</p>`;
                                    }
                                }, error => {
                                    console.error("Error with public profile listener:", error);
                                    publicViewContainer.innerHTML = `<p style="text-align:center;">An error occurred while loading the profile.</p>`;
                                });
                            } else {
                                publicViewContainer.innerHTML = `<p style="text-align:center;">Could not load profile for "${publicUsername}". This user does not exist.</p>`;
                            }
                        })
                        .catch(error => {
                            console.error("Error loading public profile:", error);
                            publicViewContainer.innerHTML = `<p style="text-align:center;">Could not load profile for "${publicUsername}". It may not exist or may not be public.</p>`;
                        });
                } else if (user) {
                    initializeAppForUser(user);
                } else {
                    showLoginScreen();
                }
            });
        }
        
        startApp();
    });
    </script>
</body>
</html>
