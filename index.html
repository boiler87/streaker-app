<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Streaker</title>
    <!-- FAVICON LINK -->
    <link rel="icon" type="image/png" href="https://raw.githubusercontent.com/rynwynk/streaker-app/main/logo%20only.png">
    <!-- GOOGLE FONTS LINK -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
        }
        @font-face {
            font-family: 'AppleIIe';
            src: url('https://daniellopes.com.br/apple-ii/AppleIIe.ttf') format('truetype');
        }

        body {
            font-family: 'AppleIIe', monospace;
            background-color: #000;
            color: #27ff47;
            margin: 0;
            padding: 0;
        }
        
        /* --- Main App Layout --- */
        .app-layout {
            display: flex;
            width: 100%;
            height: 100vh;
        }

        .main-content {
            flex-grow: 1;
            padding: 20px;
            overflow-y: auto;
            margin-left: 65px; /* Space for the sidebar */
        }
        /* --- END: Main App Layout --- */

        .container {
            background-color: #000;
            padding: 30px;
            border: 2px solid #27ff47;
            box-shadow: 0 0 10px #27ff47;
            width: 100%;
            max-width: 900px;
            margin: 0 auto; /* Center the container */
        }
        .hidden {
            display: none !important; /* The definitive fix */
        }
        
        .logo-and-title {
            display: flex;
            align-items: center;
            gap: 15px; /* Increased gap */
        }
        .logo-and-title div {
           display: flex;
           flex-direction: column;
        }
        .logo-and-title h2 {
            font-family: 'Press Start 2P', cursive;
            margin-bottom: 5px; /* Space between title and subtitle */
        }
        .subtitle {
            font-size: 0.8em;
            color: #27ff47;
            margin: 0;
        }

        h2, h3, h4 {
            color: #27ff47;
            text-align: left;
            margin: 0;
            font-size: 2em;
        }
        h3 { font-size: 1.5em; margin-top: 25px; margin-bottom: 10px; }
        h4 { font-size: 1.2em; margin-top: 20px; margin-bottom: 10px; }
        #about-container ul { padding-left: 20px; }
        #about-container li { margin-bottom: 10px; }


        .logo {
            height: 60px; /* Adjusted height */
            width: auto;
            image-rendering: pixelated;
        }
        .header-container {
            margin-bottom: 20px;
        }
        form {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        input[type="email"],
        input[type="password"],
        input[type="date"],
        input[type="datetime-local"],
        input[type="number"],
        input[type="search"],
        input[type="text"] {
            padding: 12px;
            border: 2px solid #27ff47;
            background-color: #000;
            color: #27ff47;
            flex-grow: 1;
            font-size: 16px;
            font-family: 'AppleIIe', monospace;
        }
        textarea {
            padding: 12px;
            border: 2px solid #27ff47;
            background-color: #000;
            color: #27ff47;
            flex-basis: 100%;
            min-height: 120px;
            resize: vertical;
            font-family: 'AppleIIe', monospace;
            font-size: 16px;
        }
        button {
            padding: 12px 20px;
            border: 2px solid #27ff47;
            background-color: #27ff47;
            color: #000;
            font-size: 16px;
            cursor: pointer;
            transition: background-color: 0.3s ease;
        }
        button:hover {
            background-color: #1aff32;
        }
        button:disabled {
            background-color: #111;
            color: #444;
            border-color: #444;
            cursor: not-allowed;
        }
        .button-group {
            display: flex;
            gap: 10px;
        }

        /* --- START LOGIN PAGE REDESIGN --- */
        #auth-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%; /* Make auth container full width */
            padding: 20px;
        }

        #auth-container .logo-and-title {
            justify-content: center;
            margin-bottom: 40px;
        }
        
        .terminal-window {
            width: 100%;
            max-width: 450px;
            border: 2px solid #27ff47;
            background-color: #080808;
            padding: 0;
            box-shadow: 0 0 15px rgba(39, 255, 71, 0.5);
        }

        .terminal-header {
            background-color: #27ff47;
            color: #000;
            padding: 5px 10px;
            font-weight: bold;
            text-align: center;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8em;
        }
        
        #auth-form {
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: flex-start;
        }
        
        #auth-form .form-row {
             width: 100%;
        }

        #auth-form label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        
        #auth-form input {
            width: 100%;
        }
        
        #auth-form .button-group {
            width: 100%;
            justify-content: space-between;
        }

        #auth-form .button-group button {
            flex-grow: 1;
            flex-basis: 0;
        }
        
        .blinking-cursor {
            font-weight: bold;
            animation: blink 1s step-end infinite;
        }

        @keyframes blink {
            from, to { color: transparent; }
            50% { color: #27ff47; }
        }
        /* --- END LOGIN PAGE REDESIGN --- */


        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .error-message {
            color: #ff0000;
            text-align: center;
            margin-top: 10px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            border: 2px solid #27ff47;
            margin-top: 20px;
        }
        th, td {
            padding: 15px;
            text-align: left;
            border: 1px solid #27ff47;
        }
        th {
            background-color: #111;
            color: #27ff47;
            font-weight: 600;
            cursor: pointer;
        }
        th:hover {
            background-color: #333;
        }
        th .sort-icon {
            margin-left: 5px;
            font-size: 0.8em;
        }
        tr:hover {
            background-color: #001;
        }
        .delete-btn {
            background-color: #ff0000;
            color: #000;
        }
        .delete-btn:hover {
            background-color: #cc0000;
        }
        
        .edit-btn {
            background-color: #27ff47;
            color: #000;
            font-size: 14px;
            padding: 8px 12px;
            margin-right: 5px;
        }
        .edit-btn:hover {
            background-color: #1aff32;
        }

        .save-btn {
            background-color: #27ff47;
            color: #000;
        }
        .save-btn:hover {
            background-color: #1aff32;
        }
        .cancel-btn {
            background-color: #ff0000;
            color: #000;
        }
        .cancel-btn:hover {
            background-color: #cc0000;
        }

        .end-streak-btn {
            background-color: #27ff47;
            color: #000;
            font-size: 14px;
            padding: 8px 12px;
        }
        .end-streak-btn:hover {
            background-color: #1aff32;
        }

        #user-profile-display {
            word-break: break-all;
            text-align: center;
            font-weight: bold;
            font-size: 1.2em;
        }

        .username-change-section {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            align-items: center;
        }
        #new-username-input {
            flex-grow: 1;
            font-size: 0.9em;
            padding: 8px;
        }
        #save-username-btn {
            padding: 8px 12px;
            font-size: 0.9em;
        }
        #username-status {
            flex-basis: 100%;
            text-align: left;
            margin: 5px 0 0 0;
            font-size: 0.8em;
        }

        #new-logout-btn {
            padding: 8px 12px;
            font-size: 14px;
            background-color: transparent;
            color: #27ff47;
            border: 2px solid #27ff47;
        }
        #new-logout-btn:hover {
            background-color: #27ff47;
            color: #000;
        }

        .toggle-switch {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 10px;
        }
        .toggle-switch label {
            cursor: pointer;
            white-space: nowrap;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            width: 40px;
            height: 20px;
            background-color: #333;
            border: 1px solid #27ff47;
            cursor: pointer;
            position: relative;
            transition: background-color: 0.2s;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 2px;
            bottom: 2px;
            background-color: #27ff47;
            transition: .4s;
        }
        input:checked + .slider {
            background-color: #111;
        }
        input:checked + .slider:before {
            transform: translateX(20px);
        }
        #public-link-container {
            margin-top: 10px;
        }
        #public-link-display {
            flex-grow: 1;
        }
        

        .view-more-container {
            text-align: center;
            margin-top: 20px;
        }
        
        .stats-section-header {
            margin-top: 40px;
            text-align: center;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
            text-align: center;
        }
        
        .stat-card {
            background-color: #111;
            padding: 20px;
            border: 2px solid #27ff47;
        }
        
        .stat-card h3 {
            margin: 0 0 10px 0;
            color: #27ff47;
            text-align: center;
        }
        
        .stat-card p {
            font-size: clamp(1.4em, 4vw, 2em);
            font-weight: bold;
            color: #27ff47;
            line-height: 1.2;
            min-height: 2.4em;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* --- Dynamic Streak Counter Styles --- */
        .streak-counter-layout {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        .digital-clock {
            font-family: 'Press Start 2P', cursive;
            font-size: 1.6em; 
            display: flex;
            align-items: baseline;
            justify-content: center;
            gap: 5px;
            color: #27ff47;
            text-shadow: 0 0 5px #27ff47;
            flex-shrink: 0;
        }
        .digital-clock span {
            display: inline-block;
            min-width: 1.2em;
            text-align: right;
        }
        .digital-clock .unit-label {
            font-size: 0.5em;
            align-self: flex-end;
            margin-left: -5px;
            margin-right: 5px;
        }
        .progress-bar-ascii {
            font-family: 'AppleIIe', monospace;
            font-size: 1.2em;
            text-align: center;
            margin-top: 0; 
            white-space: pre-wrap;
            color: #27ff47;
        }
        /* --- END: Dynamic Streak Counter Styles --- */

        /* --- NEW: HUD Styles --- */
        #hud-container {
            background-color: #050505;
            border: 2px solid #27ff47;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px; /* Space between rows */
            margin-bottom: 20px;
        }
        .hud-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }
        .hud-label, .hud-value {
            font-family: 'AppleIIe', monospace;
            font-size: 1em;
            color: #27ff47;
        }
        .hud-value {
            text-align: right;
            font-weight: bold;
        }
        .hud-divider {
            border: none;
            border-top: 1px dashed #27ff47;
            opacity: 0.5;
            margin: 5px 0;
        }
        .hud-progress-bar-container {
            width: 100%;
            height: 12px;
            border: 1px solid #27ff47;
            background-color: #000;
        }
        .hud-progress-bar-fill {
            height: 100%;
            background-color: #27ff47;
            transition: width 0.5s ease-in-out;
        }
        .hud-button {
            cursor: pointer;
            text-decoration: underline;
        }
        .hud-goal-text {
            font-family: 'AppleIIe', monospace;
            font-size: 1em;
            color: #27ff47;
            margin: 0;
            text-align: left;
        }


        .progress-bar-container {
            width: 100%;
            height: 20px;
            border: 1px solid #27ff47;
            background-color: #000;
            margin-top: 10px;
        }
        .progress-bar {
            height: 100%;
            background-color: #27ff47;
            transition: width 0.5s ease-in-out;
        }
        .progress-text {
            font-size: 1.2em;
            margin-top: 10px;
        }
        
        .achievements-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 20px;
            margin-top: 20px;
            text-align: center;
        }
        .badge-card {
            background-color: #111;
            padding: 20px;
            border: 2px solid #27ff47;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative; /* Added for tooltip positioning */
        }
        .badge-icon {
            font-size: 3em;
            color: #444;
            transition: color 0.5s ease;
        }
        .badge-icon.unlocked {
            color: #27ff47;
            text-shadow: 0 0 10px #27ff47;
        }
        .badge-name {
            margin-top: 10px;
            font-weight: bold;
        }

        .badge-tooltip {
            visibility: hidden;
            opacity: 0;
            width: max-content;
            max-width: 150px;
            background-color: #27ff47;
            color: #000;
            text-align: center;
            padding: 8px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.6em;
            
            position: absolute;
            z-index: 1;
            bottom: 105%; /* Position above the badge */
            left: 50%;
            transform: translateX(-50%);
            transition: opacity 0.3s ease;
            
            pointer-events: none;
        }
        
        .badge-tooltip::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #27ff47 transparent transparent transparent;
        }

        .badge-card:hover .badge-tooltip {
            visibility: visible;
            opacity: 1;
        }

        .journal-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
            border: 2px solid #27ff47;
            padding: 15px;
        }
        .journal-entry {
            background-color: #111;
            border: 2px solid #27ff47;
            padding: 20px;
            margin-bottom: 20px;
        }
        .journal-entry.pinned {
            border-left: 4px solid #ffd700;
        }
        .pin-btn {
            background-color: transparent;
            color: #ffd700;
            border-color: #ffd700;
        }
        .pin-btn:hover {
            background-color: rgba(255, 215, 0, 0.1);
        }
        .journal-entry-date {
            font-weight: bold;
            margin-bottom: 10px;
        }
        .journal-entry-text {
            white-space: pre-wrap;
            line-height: 1.5;
        }
        .journal-entry-actions {
            margin-top: 15px;
            display: flex;
            gap: 10px;
        }

        .checkin-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .checkin-group input[type="checkbox"] {
            width: 20px;
            height: 20px;
            flex-shrink: 0;
        }
        .checkin-group label {
            font-size: 1.1em;
        }

        #condensed-calendar-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
            border: 2px solid #27ff47;
            padding: 15px;
        }
        #public-condensed-calendar-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 20px;
            border: 2px solid #27ff47;
            padding: 15px;
        }
        .month-grid-container {
            padding: 10px;
        }
        .month-grid-title {
            text-align: center;
            font-size: 1em;
            margin-bottom: 10px;
        }
        .month-grid-dow, .month-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 3px;
        }
        .month-grid-dow div {
            text-align: center;
            font-size: 0.7em;
        }
        .month-grid-day {
            width: 100%;
            padding-bottom: 100%;
            position: relative;
            background-color: #1a1a1a;
        }
        /* NEW: Make days with data interactive */
        .month-grid-day.has-data {
            cursor: pointer;
        }
        .month-grid-day.active {
            background-color: #27ff47;
        }
        .month-grid-day.end {
            background-color: #ff8c00;
        }
        .month-grid-day.end-and-start {
             background: linear-gradient(135deg, #ff8c00 49%, #27ff47 51%);
        }
        .month-grid-day.goal-day {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .month-grid-day.goal-day::after {
            content: '🎯';
            font-size: 0.8em;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .year-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .year-nav h2 {
            margin: 0;
        }
        .year-nav button {
            padding: 5px 10px;
            font-size: 1.2em;
            line-height: 1;
        }
        .calendar-view-toggle button {
            padding: 5px 10px;
            font-size: 0.8em;
            background-color: #111;
            color: #27ff47;
        }
        .calendar-view-toggle button.active {
            background-color: #27ff47;
            color: #000;
        }

        #goal-progress-container.stat-card {
             padding: 15px;
        }

        .goal-inputs {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 20px;
        }
        .goal-input-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .goal-inputs label {
            font-size: 0.9em;
        }
        .goal-inputs input {
            flex-grow: 1;
            min-width: 80px;
            padding: 8px;
        }
        .goal-inputs span {
            font-style: italic;
        }

        #rank-projection-select {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border: 2px solid #27ff47;
            background-color: #000;
            color: #27ff47;
            font-family: 'AppleIIe', monospace;
            font-size: 0.9em;
        }
        #rank-projection-select option {
            background-color: #000;
            color: #27ff47;
        }

        /* --- Sidebar Navigation (Desktop) --- */
        .sidebar-nav {
            position: fixed;
            top: 0;
            left: 0;
            height: 100vh;
            width: 65px;
            background-color: #000;
            border-right: 2px solid #27ff47;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 20px;
            gap: 15px;
            z-index: 1000;
        }
        .nav-link {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: none;
            border: none;
            color: #27ff47;
            cursor: pointer;
            padding: 10px 5px;
            width: 100%;
            text-align: center;
            transition: background-color: 0.2s;
        }
        .nav-link svg {
            width: 28px;
            height: 28px;
            fill: currentColor;
            margin-bottom: 5px;
        }
        .nav-link-label {
            font-size: 0.6em;
            font-family: 'Press Start 2P', cursive;
        }
        .nav-link:hover {
            background-color: #111;
        }
        .nav-link.active {
            background-color: #27ff47;
            color: #000;
        }
        /* --- END: Sidebar Navigation --- */

        /* --- Bottom Navigation (Mobile) --- */
        .mobile-nav {
            display: none; /* Hidden by default */
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: #000;
            border-top: 2px solid #27ff47;
            z-index: 1000;
            justify-content: space-around;
        }
        .mobile-nav .nav-link {
            padding: 8px;
            flex-grow: 1;
        }
        /* --- END: Bottom Navigation --- */
        
        /* --- Gamification Styles --- */
        #xp-toast {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #27ff47;
            color: #000;
            padding: 10px 20px;
            border: 2px solid #000;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8em;
            z-index: 2000;
            opacity: 0;
            transition: opacity 0.5s, bottom 0.5s;
        }
        #levels-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.9);
            z-index: 3000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 15px; /* Added for spacing on small screens */
        }
        
        #levels-modal .terminal-window {
            display: flex;
            flex-direction: column;
            max-height: 90vh; /* Prevent modal from exceeding viewport height */
            width: 100%;
            max-width: 500px;
        }

        #levels-modal #levels-modal-content {
            overflow-y: auto; /* Make content scrollable */
            flex-grow: 1;
            padding: 20px;
        }

        #levels-modal #close-levels-modal-btn {
            width: 100%;
            flex-shrink: 0;
        }

        .clickable-level {
            cursor: pointer;
            transition: color 0.2s;
        }
        .clickable-level:hover {
            color: #fff;
        }
        #levels-modal-content table {
            font-size: 0.9em;
            margin-top: 0;
        }
        @keyframes level-up-glow {
            from { text-shadow: 0 0 10px #27ff47; }
            to { text-shadow: 0 0 30px #1aff32; }
        }

        /* NEW: Goal Modal Style */
        #goal-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.9);
            z-index: 3000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 15px;
        }
        /* --- END: Gamification Styles --- */

        /* --- Streak History Styles --- */
        #streak-history-container {
            margin-top: 20px;
        }
        .streak-history-item {
            background-color: #111;
            border: 2px solid #27ff47;
            margin-bottom: 10px;
            transition: background-color: 0.2s;
        }
        .streak-history-item-clickable {
            padding: 15px;
            cursor: pointer;
        }
        .streak-history-item-clickable:hover {
            background-color: #1a1a1a;
        }
        .streak-history-item.active {
            border-color: #1aff32;
            background-color: #0a2a0a;
        }
        .streak-history-item-header {
            display: flex;
            justify-content: space-between;
            font-weight: bold;
            flex-wrap: wrap;
        }
        .streak-history-item-details {
            font-size: 0.9em;
            color: #aaa;
        }

        /* Accordion Detail View */
        .streak-detail-view {
            max-height: 0;
            overflow: hidden;
            opacity: 0;
            transition: max-height 0.4s ease-out, padding 0.4s ease-out, opacity 0.3s ease-out;
            padding: 0 15px;
            background-color: #080808;
            border-top: 1px dashed #222;
        }

        .streak-detail-view.visible {
            max-height: 400px; /* Allow for scrolling */
            opacity: 1;
            padding: 15px;
            overflow-y: auto;
        }
        
        .xp-log-list {
            list-style: none;
            padding: 0;
            margin: 0;
            font-size: 0.9em;
        }
        .xp-log-list li {
            padding: 8px 0;
            border-bottom: 1px dashed #222;
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
        }
        .xp-log-list li:last-child {
            border-bottom: none;
        }
        .xp-log-date {
            color: #aaa;
            flex-basis: 100px;
        }
        .xp-log-reason {
            flex-grow: 1;
        }
        .xp-log-points {
            font-weight: bold;
        }
        /* --- END: Streak History Styles --- */

        /* NEW STYLE: This contains the absolutely positioned tooltip */
        #logbook-container {
            position: relative;
        }

        /* --- NEW: Calendar Tooltip Styles --- */
        #calendar-tooltip {
            position: absolute;
            width: 250px;
            background-color: #080808;
            border: 2px solid #27ff47;
            padding: 10px;
            z-index: 100;
            pointer-events: none; /* Allow clicks to pass through */
            line-height: 1.6;
            font-size: 0.9em;
        }
        #calendar-tooltip .tooltip-header {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8em;
            text-align: center;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px dashed #27ff47;
        }
        #calendar-tooltip .tooltip-body ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        #calendar-tooltip .tooltip-body li {
            margin-bottom: 5px;
        }
        #calendar-tooltip .tooltip-body .journal-snippet {
            font-style: italic;
            color: #aaa;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: block;
        }

        /* --- NEW: Data Export Styles --- */
        .export-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 15px;
        }


        @media (max-width: 768px) {
            .sidebar-nav {
                display: none;
            }
            .mobile-nav {
                display: flex;
            }
            .main-content {
                margin-left: 0;
            }
        }
        
        @media (max-width: 700px) { 
            #public-condensed-calendar-container {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 600px) {
            .header {
                flex-wrap: wrap;
                justify-content: center;
                gap: 15px;
            }

            body {
                padding: 0;
            }
            .main-content {
                padding: 10px;
                padding-bottom: 80px; /* Space for bottom nav */
            }
            .container {
                padding: 20px;
            }
            form {
                flex-direction: column;
            }
            /* Ensure inputs inside column forms take full width */
            form input[type="datetime-local"],
            form input[type="date"],
            form input[type="search"] {
                width: 100%;
            }
            .button-group {
                flex-direction: column;
            }
            /* Responsive table styles */
            table, thead, tbody, th, td, tr {
                display: block;
            }
            thead tr {
                position: absolute;
                top: -9999px;
                left: -9999px;
            }
            tr {
                border: 1px solid #27ff47;
                margin-bottom: 15px;
            }
            td {
                border: none;
                border-bottom: 1px solid #27ff47;
                position: relative;
                padding-left: 50%;
                text-align: right;
            }
            td:before {
                position: absolute;
                top: 0;
                left: 6px;
                width: 45%;
                padding-right: 10px;
                white-space: nowrap;
                content: attr(data-label);
                text-align: left;
                font-weight: bold;
                color: #27ff47;
            }
            td:last-child {
                border-bottom: 0;
            }
            .delete-btn {
                width: 100%;
                margin-top: 10px;
            }

            #public-condensed-calendar-container {
                grid-template-columns: 1fr;
            }
            
            /* Responsive form updates */
            .journal-controls {
                flex-direction: column;
                gap: 15px;
            }
            .journal-entry-actions {
                flex-direction: column;
            }
            .journal-entry-actions button {
                width: 100%;
            }
            #checkin-form {
                flex-direction: column;
                align-items: flex-start;
                gap: 15px;
            }
            #save-checkin-btn {
                width: 100%;
            }
        }

        /* --- NEW: Further mobile optimizations for smaller screens --- */
        @media (max-width: 480px) {
            h2 { font-size: 1.5em; }
            h3 { font-size: 1.2em; }

            .main-content {
                padding: 5px;
                padding-bottom: 80px; /* Keep space for nav */
            }
            .container {
                padding: 15px;
            }

            .logo-and-title {
                flex-direction: column;
                align-items: center;
                gap: 10px;
            }
            
            .stats-grid {
                gap: 10px;
            }

            .goal-inputs {
                flex-direction: column;
                align-items: stretch;
            }
        }
    </style>
</head>
<body>

    <!-- NEW: Loading Screen -->
    <div id="loading-container" class="container" style="text-align: center; padding: 50px;">
        <p>LOADING STREAKER...</p>
    </div>
    
    <!-- NEW: Public View Container -->
    <div id="public-view-container" class="container hidden">
        <!-- Public, read-only content will be rendered here by JavaScript -->
    </div>


    <!-- Login/Signup Section -->
    <div id="auth-container" class="container hidden">
        <div class="logo-and-title" style="margin-bottom: 20px;">
            <img src="https://raw.githubusercontent.com/rynwynk/streaker-app/main/logo%20only.png" alt="Streaker Logo" class="logo">
            <div>
                <h2>Streaker</h2>
                <p class="subtitle">Satisfied Through Denial</p>
            </div>
        </div>
        <div class="terminal-window">
            <div class="terminal-header">USER AUTHENTICATION</div>
            <form id="auth-form">
                <div class="form-row hidden">
                    <label for="username-input">USERNAME:</label>
                    <input type="text" id="username-input" placeholder="ENTER USERNAME" autocomplete="username">
                </div>
                 <div class="form-row">
                    <label for="email-input">EMAIL:</label>
                    <input type="email" id="email-input" placeholder="ENTER EMAIL" required autocomplete="email">
                 </div>
                 <div class="form-row">
                    <label for="password-input">PASSWORD:</label>
                    <input type="password" id="password-input" placeholder="ENTER PASSWORD" required autocomplete="current-password">
                 </div>
                 <div style="width: 100%; text-align: left;">
                    > <span class="blinking-cursor">_</span>
                 </div>
                <div class="button-group">
                    <button type="submit" id="main-auth-btn">Log In</button>
                </div>
            </form>
        </div>
        <p id="auth-error" class="error-message"></p>
    </div>

    <!-- Main App Section with New Layout -->
    <div id="app-layout" class="app-layout hidden">
        
        <!-- Sidebar Nav -->
        <nav class="sidebar-nav">
             <!-- Dashboard -->
            <button class="nav-link active" data-tab="dashboard">
                <svg viewBox="0 0 24 24"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg>
                <span class="nav-link-label">DASH</span>
            </button>
            <!-- Stats -->
            <button class="nav-link" data-tab="stats">
                <svg viewBox="0 0 24 24"><path d="M10 20h4V4h-4v16zm-6 0h4v-8H4v8zM16 9v11h4V9h-4z"/></svg>
                <span class="nav-link-label">STATS</span>
            </button>
            <!-- Achievements -->
             <button class="nav-link" data-tab="achievements">
                <svg viewBox="0 0 24 24"><path d="M19 5h-2V3H7v2H5c-1.1 0-2 .9-2 2v1c0 2.55 1.92 4.63 4.39 4.94.63 1.5 1.74 2.77 3.11 3.5V19H7v2h10v-2h-3.5v-3.56c1.37-.73 2.48-2 3.11-3.5.07-.16.12-.33.18-.5.1-.3.15-.61.15-.93V7c0-1.1-.9-2-2-2zm-7 10c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3z"/></svg>
                <span class="nav-link-label">AWARDS</span>
            </button>
            <!-- Journal -->
            <button class="nav-link" data-tab="journal">
                <svg viewBox="0 0 24 24"><path d="M18 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM6 4h5v8l-2.5-1.5L6 12V4z"/></svg>
                <span class="nav-link-label">JOURNAL</span>
            </button>
            <!-- About -->
            <button class="nav-link" data-tab="about">
                <svg viewBox="0 0 24 24"><path d="M11 18h2v-2h-2v2zm1-16C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm0-14c-2.21 0-4 1.79-4 4h2c0-1.1.9-2 2-2s2 .9 2 2c0 2-3 1.75-3 5h2c0-2.25 3-2.5 3-5 0-2.21-1.79-4-4-4z"/></svg>
                <span class="nav-link-label">ABOUT</span>
            </button>
            <!-- Profile -->
            <button class="nav-link" data-tab="profile">
                <svg viewBox="0 0 24 24"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>
                <span class="nav-link-label">PROFILE</span>
            </button>
        </nav>

        <div class="main-content">
            <div id="main-app-container" class="container">
                <div class="header">
                    <div class="logo-and-title">
                        <img src="https://raw.githubusercontent.com/rynwynk/streaker-app/main/logo%20only.png" alt="Streaker Logo" class="logo">
                        <div>
                            <h2>Streaker</h2>
                            <p class="subtitle">Satisfied Through Denial</p>
                        </div>
                    </div>
                    <button id="new-logout-btn">Log Out</button>
                </div>

                <!-- Dashboard Container -->
                <div id="dashboard-container">
                    
                    <!-- NEW: HUD Display Container -->
                    <div id="hud-container">
                        <!-- Content is generated by JavaScript -->
                    </div>

                    <!-- Hidden inputs for HUD editing -->
                    <div class="hidden">
                        <div class="goal-inputs">
                            <div class="goal-input-group">
                                <label for="goal-input">Days:</label>
                                <input type="number" id="goal-input" placeholder="e.g., 30">
                            </div>
                            <span>OR</span>
                            <div class="goal-input-group">
                                <label for="goal-date-input">Date:</label>
                                <input type="date" id="goal-date-input">
                            </div>
                        </div>
                        <div class="button-group" style="width: 100%; margin-top: 15px; justify-content: space-between;">
                            <button id="set-goal-btn" style="flex-grow: 2;">Set Objective</button>
                            <button id="random-goal-btn" style="flex-grow: 1;">Random Objective</button>
                        </div>
                    </div>


                    <!-- NEW: Dice Roll Card -->
                    <div class="stat-card" style="margin-bottom: 30px;">
                        <h3>Should I cum today?</h3>
                        <p id="dice-roll-result" style="font-size: 1.2em; min-height: 1.5em; text-align: center;">-</p>
                        <div class="button-group" style="width: 100%; margin-top: 15px; justify-content: center;">
                           <button id="roll-dice-btn">Roll the dice</button>
                        </div>
                    </div>


                    <h2 class="stats-section-header" style="text-align: left;">Log Book</h2>
                    <p class="subtitle" style="text-align: left; margin-top: -5px; margin-bottom: 20px;">Edge. Deny. Repeat.</p>
                    <div style="display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 20px; align-items: center;">
                        <form id="entry-form" style="flex-grow: 1; margin-bottom: 0; display: flex; flex-wrap: wrap; gap: 10px;">
                            <input type="datetime-local" id="start-date-input" required style="flex-grow: 1;">
                            <input type="datetime-local" id="end-date-input" style="flex-grow: 1;">
                            <button type="submit">Add Entry</button>
                        </form>
                    </div>
                    
                    <div id="streak-history-container"></div>
                </div>

                <!-- Stats Container (formerly Logbook) -->
                <div id="logbook-container" class="hidden">
                    <h2 class="stats-section-header">All-Time Stats</h2>
                    <div class="stat-card" style="margin-bottom: 20px;">
                        <h3 id="rank-header-stats" class="clickable-level">Current Rank</h3>
                        <pre id="xp-progress-bar-stats" class="progress-bar-ascii">[XP: 0/100]</pre>
                        <p id="next-rank-estimate" style="font-size: 0.8em; margin-top: 10px; min-height: 1em;"></p>
                    </div>
                    <div class="stats-grid">
                        <div class="stat-card">
                            <h3>Total Days This Year</h3>
                            <p id="total-days-year-stat">0 days</p>
                        </div>
                        <div class="stat-card">
                            <h3>Longest Streak</h3>
                            <p id="longest-streak-stat">0 days</p>
                        </div>
                        <div class="stat-card">
                            <h3>Highest Rank Ever</h3>
                            <p id="highest-rank-stat">-</p>
                        </div>
                        <div class="stat-card">
                            <h3>Average Duration</h3>
                            <p id="avg-duration-stat">0d 0h</p>
                        </div>
                        <div class="stat-card">
                            <h3>Rank Projection</h3>
                            <select id="rank-projection-select"></select>
                            <p id="rank-projection-days" style="font-size: 2em; margin-bottom: 5px;">-</p>
                            <p id="rank-projection-date" style="font-size: 0.8em; margin-top: 0;">Select a Rank</p>
                        </div>
                    </div>
                    <div class="stats-section-header year-nav">
                        <button id="prev-year-btn" title="Previous Year">&lt;</button>
                        <h2 style="margin: 0;">Year in Review (<span id="current-year-label"></span>)</h2>
                        <button id="next-year-btn" title="Next Year">&gt;</button>
                    </div>
                    <div class="calendar-view-toggle button-group" style="justify-content: center; margin-top: 10px;">
                        <button data-view="1" class="view-toggle-btn">Month</button>
                        <button data-view="3" class="view-toggle-btn active">3 Months</button>
                        <button data-view="6" class="view-toggle-btn">6 Months</button>
                        <button data-view="12" class="view-toggle-btn">Year</button>
                    </div>
                    <div id="condensed-calendar-container"></div>
                       <p style="text-align: center; font-size: 0.8em; margin-top: 15px;">
                            <span style="display: inline-block; width: 12px; height: 12px; background-color: #27ff47;"></span> Active
                            <span style="display: inline-block; width: 12px; height: 12px; background-color: #ff8c00; margin-left: 15px;"></span> Ended
                            <span style="display: inline-block; width: 12px; height: 12px; background: linear-gradient(135deg, #ff8c00 49%, #27ff47 51%); margin-left: 15px;"></span> Ended & Restarted
                             <span style="margin-left: 15px;">🎯 Goal</span>
                       </p>
                    
                    <!-- NEW: Calendar Tooltip element -->
                    <div id="calendar-tooltip" class="hidden">
                        <div class="tooltip-header"></div>
                        <div class="tooltip-body"></div>
                    </div>
                </div>

                <!-- Achievements Container -->
                <div id="achievements-container" class="hidden">
                    <h2 class="stats-section-header">My Achievements</h2>
                    <div id="my-achievements-grid" class="achievements-grid"></div>
                    <h2 class="stats-section-header">Available Badges</h2>
                    <div id="available-badges-grid" class="achievements-grid"></div>
                </div>

                <!-- Journal Container -->
                <div id="journal-container" class="hidden">
                    <h2 class="stats-section-header" style="text-align: left;">Journal</h2>

                    <!-- NEW Daily Check-in Card -->
                    <div class="stat-card" style="margin-bottom: 20px;">
                        <h3 id="daily-checkin-header">Daily Check-in</h3>
                        <form id="checkin-form" style="margin-top: 15px; margin-bottom: 0; justify-content: space-around;">
                            <div class="checkin-group">
                                <input type="checkbox" id="checkin-locked" name="locked">
                                <label for="checkin-locked">Locked</label>
                            </div>
                            <div class="checkin-group">
                                <input type="checkbox" id="checkin-sex" name="sex">
                                <label for="checkin-sex">Sex</label>
                            </div>
                            <div class="checkin-group">
                                <input type="checkbox" id="checkin-edged" name="edged">
                                <label for="checkin-edged">Edged</label>
                            </div>
                            <button type="submit" id="save-checkin-btn" style="flex-basis: 100%; margin-top: 10px;">Save Check-in</button>
                        </form>
                    </div>

                    <form id="journal-form">
                        <textarea id="journal-input" placeholder="Write your journal entry here..."></textarea>
                        <button type="submit">Submit Entry</button>
                    </form>

                    <div class="journal-controls">
                        <input type="search" id="journal-search-input" placeholder="Search entries...">
                        <input type="date" id="journal-filter-start-date" title="Filter start date">
                        <input type="date" id="journal-filter-end-date" title="Filter end date">
                        <button id="journal-filter-clear-btn">Clear</button>
                    </div>

                    <div id="journal-entries-container">
                    </div>
                </div>

                <!-- NEW: About Container -->
                <div id="about-container" class="hidden" style="line-height: 1.8;">
                    <h2 class="stats-section-header" style="text-align: left;">About Streaker</h2>
                    <p>
                        Welcome to Streaker, your digital companion for building unbreakable habits. This app is built on a simple philosophy: consistency is the key to achieving any goal. The retro interface is designed to be simple and distraction-free, helping you focus on what truly matters: showing up every single day.
                    </p>

                    <h3>Getting Started: The Dashboard</h3>
                    <ul>
                        <li><strong>Log Your First Streak:</strong> In the "Log Book" section, use the date and time inputs to select a start time for your new streak. Leave the end time blank and click "Add Entry." Your "Current Streak" will begin counting up immediately.</li>
                        <li><strong>End a Streak:</strong> To end your current streak, simply find it in the Log Book table on the Dashboard and click the "End & Restart" button. This automatically logs the end time and starts a new streak from that moment.</li>
                        <li><strong>Set a Goal:</strong> Use the "Goal Progress" card to set a target for your current streak, either by a number of days or a specific calendar date. Your progress will be visualized in the progress bar.</li>
                    </ul>

                    <h3>Analyze Your Progress: The Stats Page</h3>
                    <p>The <strong>STATS</strong> tab gives you a high-level view of your journey:</p>
                    <ul>
                        <li><strong>All-Time Stats:</strong> Here you'll find key metrics like your longest-ever streak, your average streak duration, and your progress towards the "Demigod" rank.</li>
                        <li><strong>Year in Review:</strong> This interactive calendar visualizes your streaks throughout the year, helping you see your consistency at a glance. You can navigate between years and change the view to focus on 1, 3, or 6 months.</li>
                        <li><strong>Streak History:</strong> This section provides a detailed, expandable list of every streak you've completed. Click on any past streak to see a full log of all the Experience Points (XP) you earned during that period.</li>
                    </ul>
                    
                    <h3>Gamified Journey: Achievements & Journal</h3>
                     <ul>
                        <li><strong>Achievements:</strong> On the <strong>AWARDS</strong> tab, you can view all the badges you've unlocked for your current streak, as well as all the badges that are still available to earn.</li>
                        <li><strong>Journal:</strong> The <strong>JOURNAL</strong> tab is your space for reflection. Write down your thoughts, challenges, and victories. You can search your entries by keyword, filter by date, and "pin" important entries to the top of the list.</li>
                    </ul>


                    <h3>Your Account: The Profile Page</h3>
                    <p>The <strong>PROFILE</strong> tab is where you manage your account and data:</p>
                    <ul>
                         <li><strong>Public Profile:</strong> Enable this feature to share a public, read-only version of your profile. Once enabled, you can customize exactly which cards (like your Current Streak, Stats, and Calendar) are visible to others.</li>
                         <li><strong>Username:</strong> Set or change your public username here. This is required to generate your unique public profile link.</li>
                         <li><strong>Data Export:</strong> You own your data. Export your streak logs or journal entries to a CSV file at any time.</li>
                    </ul>


                    <h3>The Gamification System: XP & Levels</h3>
                    <p>
                        To make your journey more engaging, Streaker includes a leveling system. Your level is a direct reflection of the effort you've put into your <strong>current, active streak.</strong>
                    </p>
                    <p>
                        You earn Experience Points (XP) in several ways:
                       </p>
                       <ul>
                            <li><strong>+5 XP</strong> for every full day you maintain your active streak.</li>
                            <li><strong>+5 XP</strong> for every journal entry you write during your active streak.</li>
                            <li><strong>+10 XP</strong> for every achievement badge you unlock during your active streak.</li>
                            <li><strong>+10 XP</strong> for each new Rank you achieve.</li>
                       </ul>
                       <p>
                        When a streak ends, your XP for that streak resets to zero for the next one. This system is designed to reward present consistency above all else. Your all-time stats, like your longest streak, are always saved.
                    </p>

                    <h4>Ranks & Levels</h4>
                    <p>As you accumulate XP within a streak, you will advance through the ranks:</p>
                    <table style="text-align: left; font-size: 0.9em;">
                        <thead>
                            <tr>
                                <th>Level</th>
                                <th>Title</th>
                                <th>XP Required</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr><td data-label="Level">1</td><td data-label="Title">NOVICE</td><td data-label="XP Required">0 XP</td></tr>
                            <tr><td data-label="Level">2</td><td data-label="Title">APPRENTICE</td><td data-label="XP Required">100 XP</td></tr>
                            <tr><td data-label="Level">3</td><td data-label="Title">JOURNEYMAN</td><td data-label="XP Required">250 XP</td></tr>
                            <tr><td data-label="Level">4</td><td data-label="Title">EXPERT</td><td data-label="XP Required">500 XP</td></tr>
                            <tr><td data-label="Level">5</td><td data-label="Title">MASTER</td><td data-label="XP Required">1000 XP</td></tr>
                            <tr><td data-label="Level">6</td><td data-label="Title">GRANDMASTER</td><td data-label="XP Required">2000 XP</td></tr>
                            <tr><td data-label="Level">7</td><td data-label="Title">LEGEND</td><td data-label="XP Required">4000 XP</td></tr>
                            <tr><td data-label="Level">8</td><td data-label="Title">DEMIGOD</td><td data-label="XP Required">8000 XP</td></tr>
                        </tbody>
                    </table>

                </div>
                
                <!-- NEW: Profile Container -->
                <div id="profile-container" class="hidden">
                    <h2 class="stats-section-header" style="text-align: left;">Profile Settings</h2>
                    <div class="stat-card" style="margin-top: 20px;">
                        <h3>User Account</h3>
                        <p id="user-profile-display" style="font-size: 1em; margin-bottom: 15px;"></p>
                        <div class="username-change-section">
                            <input type="text" id="new-username-input" placeholder="New username">
                            <button id="save-username-btn">Save</button>
                            <p id="username-status" class="error-message" style="margin: 10px 0 0 0;"></p>
                        </div>
                    </div>

                    <div class="stat-card" style="margin-top: 20px;">
                        <h3>Public Profile</h3>
                         <div class="sharing-section" style="border-top: none; padding: 0; margin-top: 10px;">
                              <div class="toggle-switch">
                                   <label for="public-profile-toggle">Enable Public Profile</label>
                                   <label class="slider-container">
                                       <input type="checkbox" id="public-profile-toggle">
                                       <span class="slider"></span>
                                   </label>
                              </div>
                              <div id="public-link-container" class="hidden">
                                   <div style="display:flex; gap: 10px; align-items:center; margin-bottom: 10px;">
                                       <input type="text" id="public-link-display" readonly>
                                       <button id="copy-public-link-btn" title="Copy Link" style="padding: 12px; line-height: 1;">
                                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
                                       </button>
                                   </div>
                                   <!-- UPDATED: Section for card visibility toggles -->
                                   <div id="public-cards-selection" class="hidden" style="margin-top: 20px; border-top: 1px dashed #27ff47; padding-top: 15px;">
                                       <h4 style="margin-top: 0; margin-bottom: 15px;">Public Card Visibility</h4>
                                       <div class="toggle-switch">
                                           <label for="public-toggle-current-streak">Show Current Streak</label>
                                           <label class="slider-container">
                                               <input type="checkbox" id="public-toggle-current-streak" data-setting="showCurrentStreak">
                                               <span class="slider"></span>
                                           </label>
                                       </div>
                                       <div class="toggle-switch">
                                           <label for="public-toggle-goal-progress">Show Goal Progress</label>
                                           <label class="slider-container">
                                               <input type="checkbox" id="public-toggle-goal-progress" data-setting="showGoalProgress">
                                               <span class="slider"></span>
                                           </label>
                                       </div>
                                       <div class="toggle-switch">
                                           <label for="public-toggle-longest-streak">Show Longest Streak</label>
                                           <label class="slider-container">
                                               <input type="checkbox" id="public-toggle-longest-streak" data-setting="showLongestStreak">
                                               <span class="slider"></span>
                                           </label>
                                       </div>
                                       <div class="toggle-switch">
                                           <label for="public-toggle-average-streak">Show Average Streak</label>
                                           <label class="slider-container">
                                               <input type="checkbox" id="public-toggle-average-streak" data-setting="showAverageStreak">
                                               <span class="slider"></span>
                                           </label>
                                       </div>
                                       <div class="toggle-switch">
                                           <label for="public-toggle-total-days-year">Show Total Days This Year</label>
                                           <label class="slider-container">
                                               <input type="checkbox" id="public-toggle-total-days-year" data-setting="showTotalDaysYear">
                                               <span class="slider"></span>
                                           </label>
                                       </div>
                                      <div class="toggle-switch">
                                           <label for="public-toggle-highest-rank">Show Highest Rank Ever</label>
                                           <label class="slider-container">
                                               <input type="checkbox" id="public-toggle-highest-rank" data-setting="showHighestRank">
                                               <span class="slider"></span>
                                           </label>
                                       </div>
                                       <div class="toggle-switch">
                                           <label for="public-toggle-achievements">Show Achievements</label>
                                           <label class="slider-container">
                                               <input type="checkbox" id="public-toggle-achievements" data-setting="showAchievements">
                                               <span class="slider"></span>
                                           </label>
                                       </div>
                                       <div class="toggle-switch">
                                           <label for="public-toggle-history">Show Streak History</label>
                                           <label class="slider-container">
                                               <input type="checkbox" id="public-toggle-history" data-setting="showHistory">
                                               <span class="slider"></span>
                                           </label>
                                       </div>
                                       <div class="toggle-switch">
                                           <label for="public-toggle-calendar">Show Calendar</label>
                                           <label class="slider-container">
                                               <input type="checkbox" id="public-toggle-calendar" data-setting="showCalendar">
                                               <span class="slider"></span>
                                           </label>
                                       </div>
                                   </div>
                              </div>
                         </div>
                    </div>
                    
                    <!-- NEW: Data Export Section -->
                    <div class="stat-card" style="margin-top: 20px;">
                        <h3>Data Export</h3>
                        <div class="export-buttons">
                            <button id="export-logs-btn">Export Streak Logs (CSV)</button>
                            <button id="export-journal-btn">Export Journal Entries (CSV)</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Mobile Nav -->
        <nav class="mobile-nav">
             <!-- Dashboard -->
            <button class="nav-link active" data-tab="dashboard">
                <svg viewBox="0 0 24 24"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg>
                <span class="nav-link-label">DASH</span>
            </button>
            <!-- Stats -->
            <button class="nav-link" data-tab="stats">
                <svg viewBox="0 0 24 24"><path d="M10 20h4V4h-4v16zm-6 0h4v-8H4v8zM16 9v11h4V9h-4z"/></svg>
                <span class="nav-link-label">STATS</span>
            </button>
            <!-- Achievements -->
             <button class="nav-link" data-tab="achievements">
                <svg viewBox="0 0 24 24"><path d="M19 5h-2V3H7v2H5c-1.1 0-2 .9-2 2v1c0 2.55 1.92 4.63 4.39 4.94.63 1.5 1.74 2.77 3.11 3.5V19H7v2h10v-2h-3.5v-3.56c1.37-.73 2.48-2 3.11-3.5.07-.16.12-.33.18-.5.1-.3.15-.61.15-.93V7c0-1.1-.9-2-2-2zm-7 10c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3z"/></svg>
                <span class="nav-link-label">AWARDS</span>
            </button>
            <!-- Journal -->
            <button class="nav-link" data-tab="journal">
                <svg viewBox="0 0 24 24"><path d="M18 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM6 4h5v8l-2.5-1.5L6 12V4z"/></svg>
                <span class="nav-link-label">JOURNAL</span>
            </button>
            <!-- Profile -->
            <button class="nav-link" data-tab="profile">
                <svg viewBox="0 0 24 24"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>
                <span class="nav-link-label">PROFILE</span>
            </button>
        </nav>
        
        
    </div>

    <!-- NEW Gamification Elements (Moved Outside App Layout) -->
    <div id="xp-toast" class="hidden"></div>
    <div id="levels-modal" class="hidden">
        <div class="terminal-window">
            <div class="terminal-header">RANKS & LEVELS</div>
            <div id="levels-modal-content">
                <!-- Table will be generated here -->
            </div>
            <button id="close-levels-modal-btn">Close</button>
        </div>
    </div>

    <!-- NEW: Goal Edit Modal -->
    <div id="goal-modal" class="hidden">
        <div class="terminal-window">
            <div class="terminal-header">EDIT OBJECTIVE</div>
            <div id="goal-modal-content" style="padding: 20px; display: flex; flex-direction: column; gap: 20px;">
                <div class="goal-inputs" style="flex-direction: column; align-items: stretch; gap: 15px; margin: 0;">
                    <div class="goal-input-group" style="flex-direction: column; align-items: stretch;">
                        <label for="modal-goal-input">Set Goal by Duration (days):</label>
                        <input type="number" id="modal-goal-input" placeholder="e.g., 30">
                    </div>
                    <span>OR</span>
                    <div class="goal-input-group" style="flex-direction: column; align-items: stretch;">
                        <label for="modal-goal-date-input">Set Goal by Date:</label>
                        <input type="date" id="modal-goal-date-input">
                    </div>
                </div>
                <div class="button-group" style="justify-content: space-between;">
                     <button id="modal-random-goal-btn" style="flex-basis: 30%;">Random</button>
                    <button id="modal-save-goal-btn" style="flex-grow: 1;">Save Objective</button>
                </div>
                 <button id="modal-cancel-goal-btn" class="cancel-btn" style="width: 100%;">Cancel</button>
            </div>
        </div>
    </div>

    <script type="module">
        // Firebase SDK modules (Updated to a more recent version)
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { 
            getAuth, 
            onAuthStateChanged, 
            createUserWithEmailAndPassword, 
            signInWithEmailAndPassword, 
            signOut 
        } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        import { 
            getFirestore, 
            collection, 
            doc, 
            addDoc, 
            setDoc, 
            updateDoc, 
            deleteDoc,
            onSnapshot, 
            query, 
            orderBy,
            serverTimestamp,
            Timestamp,
            writeBatch,
            getDoc,
            getDocs // <-- Added getDocs for migration
        } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";


        document.addEventListener('DOMContentLoaded', () => {
             // Use the __firebase_config global variable if it exists, otherwise use a default
            const firebaseConfig = {
                apiKey: "AIzaSyCxPG9RfxihL-Rfhu7fPSP95QDld6QMuik",
                authDomain: "streaker-1658d.firebaseapp.com",
                projectId: "streaker-1658d",
                storageBucket: "streaker-1658d.firebasestorage.app",
                messagingSenderId: "12701860115",
                appId: "1:12701860115:web:0d4dcba33fd234df97dae6",
                measurementId: "G-XKE790N7ZL"
            };
            
            // Initialize Firebase
            const app = initializeApp(firebaseConfig);
            const auth = getAuth(app);
            const db = getFirestore(app);

            // DOM elements
            const authContainer = document.getElementById('auth-container');
            const mainAppContainer = document.getElementById('main-app-container');
            const appLayout = document.getElementById('app-layout');
            const authForm = document.getElementById('auth-form');
            const mainAuthBtn = document.getElementById('main-auth-btn');
            const usernameInput = document.getElementById('username-input');
            const emailInput = document.getElementById('email-input');
            const passwordInput = document.getElementById('password-input');

            const newLogoutBtn = document.getElementById('new-logout-btn');
            
            // NEW: Export buttons
            const exportLogsBtn = document.getElementById('export-logs-btn');
            const exportJournalBtn = document.getElementById('export-journal-btn');
            
            const allNavLinkBtns = document.querySelectorAll('.nav-link');

            const dashboardContainer = document.getElementById('dashboard-container');
            const logbookContainer = document.getElementById('logbook-container');
            const achievementsContainer = document.getElementById('achievements-container');
            const journalContainer = document.getElementById('journal-container');
            const aboutContainer = document.getElementById('about-container');
            const profileContainer = document.getElementById('profile-container');

            // Logbook elements
            const entryForm = document.getElementById('entry-form');
            const authError = document.getElementById('auth-error');
            const startDateInput = document.getElementById('start-date-input');
            const endDateInput = document.getElementById('end-date-input');
            const longestStreakStat = document.getElementById('longest-streak-stat');
            const avgDurationStat = document.getElementById('avg-duration-stat');
            const highestRankStat = document.getElementById('highest-rank-stat');
            const totalDaysYearStat = document.getElementById('total-days-year-stat');
            const rankProjectionSelect = document.getElementById('rank-projection-select');
            const rankProjectionDays = document.getElementById('rank-projection-days');
            const rankProjectionDate = document.getElementById('rank-projection-date');
            
            // Goal elements
            const goalInput = document.getElementById('goal-input');
            const goalDateInput = document.getElementById('goal-date-input');
            const setGoalBtn = document.getElementById('set-goal-btn');
            const randomGoalBtn = document.getElementById('random-goal-btn');
            
            // Achievements elements
            const myAchievementsGrid = document.getElementById('my-achievements-grid');
            const availableBadgesGrid = document.getElementById('available-badges-grid');
            
            // NEW: HUD elements
            const hudContainer = document.getElementById('hud-container');

            // NEW: Calendar Tooltip element
            const calendarTooltip = document.getElementById('calendar-tooltip');

            // Journal elements
            const journalForm = document.getElementById('journal-form');
            const journalInput = document.getElementById('journal-input');
            const journalEntriesContainer = document.getElementById('journal-entries-container');
            const journalSearchInput = document.getElementById('journal-search-input');
            const journalFilterStartDate = document.getElementById('journal-filter-start-date');
            const journalFilterEndDate = document.getElementById('journal-filter-end-date');
            const journalFilterClearBtn = document.getElementById('journal-filter-clear-btn');
            const checkinForm = document.getElementById('checkin-form');
            const checkinLocked = document.getElementById('checkin-locked');
            const checkinSex = document.getElementById('checkin-sex');
            const checkinEdged = document.getElementById('checkin-edged');
            const dailyCheckinHeader = document.getElementById('daily-checkin-header');

            // NEW: Profile elements
            const userProfileDisplay = document.getElementById('user-profile-display');
            const publicProfileToggle = document.getElementById('public-profile-toggle');
            const publicLinkContainer = document.getElementById('public-link-container');
            const publicLinkDisplay = document.getElementById('public-link-display');
            const copyPublicLinkBtn = document.getElementById('copy-public-link-btn');
            // UPDATED: New elements for public card settings
            const publicCardsSelection = document.getElementById('public-cards-selection');
            
            // NEW: Username change elements
            const newUsernameInput = document.getElementById('new-username-input');
            const saveUsernameBtn = document.getElementById('save-username-btn');
            const usernameStatus = document.getElementById('username-status');
            
            // NEW: Streak History elements
            const streakHistoryContainer = document.getElementById('streak-history-container');
            
            // NEW: Modal elements
            const levelsModal = document.getElementById('levels-modal');
            const closeLevelsModalBtn = document.getElementById('close-levels-modal-btn');
            const calendarViewToggle = document.querySelector('.calendar-view-toggle');

            // NEW: Goal Modal elements
            const goalModal = document.getElementById('goal-modal');
            const modalGoalInput = document.getElementById('modal-goal-input');
            const modalGoalDateInput = document.getElementById('modal-goal-date-input');
            const modalSaveGoalBtn = document.getElementById('modal-save-goal-btn');
            const modalRandomGoalBtn = document.getElementById('modal-random-goal-btn');
            const modalCancelGoalBtn = document.getElementById('modal-cancel-goal-btn');

            // NEW: Dice roll elements
            const rollDiceBtn = document.getElementById('roll-dice-btn');
            const diceRollResult = document.getElementById('dice-roll-result');


            // NEW: Chart, Loading, and Public View containers
            const loadingContainer = document.getElementById('loading-container');
            const publicViewContainer = document.getElementById('public-view-container');
            
            let userLogs = [];
            let allJournalEntries = []; // Holds all journal entries for client-side filtering
            let userCheckins = [];
            let ongoingStreakInterval = null;
            let currentEditingLogId = null;
            let displayedYear = new Date().getFullYear(); // For year-in-review calendar
            let userData = {}; // To store user doc data like username, last check-in
            let mainAppListenersAdded = false; // Flag to ensure listeners are only added once
            let isUpdatingGoal = false; // Flag to prevent goal input loops
            let publicInterval = null; // To manage the public profile's update timer
            let calendarMonthsToShow = 3;
            let highestAnnouncedLevelClient = 0; // Client-side state for announced levels
            let isHudInEditMode = false; // NEW: State for HUD edit mode

            // --- START: GAMIFICATION LOGIC --- //
            
            async function migrateOldStreaks(user) {
                console.log("Checking if XP migration is needed...");
                // Use a new flag to avoid re-running this specific migration
                if (userData.hasMigratedXpSystemV5) { 
                    console.log("XP system is already up-to-date.");
                    return;
                }

                console.log("Starting XP migration for historical streaks...");
                const batch = writeBatch(db);
                const logsCollectionRef = collection(db, 'users', user.uid, 'logs');
                
                // Fetch all logs and journals once for a consistent calculation state
                const logsSnapshot = await getDocs(logsCollectionRef);
                const allLogsForCalc = logsSnapshot.docs.filter(doc => doc.data().startDate);

                const journalSnapshot = await getDocs(collection(db, 'users', user.uid, 'journal'));
                const allJournalEntriesForCalc = journalSnapshot.docs;

                const streaksToUpdate = allLogsForCalc.filter(doc => doc.data().endDate);

                if (streaksToUpdate.length === 0) {
                    console.log("No historical streaks to migrate.");
                } else {
                    streaksToUpdate.forEach(streakDoc => {
                        // Recalculate XP using the latest rules
                        const newFinalXp = calculateXpForStreak(streakDoc, allJournalEntriesForCalc);
                        const streakRef = doc(logsCollectionRef, streakDoc.id);
                        batch.update(streakRef, { finalXp: newFinalXp });
                    });
                }

                // Set the migration flag on the user's main document to prevent re-runs
                const userRef = doc(db, 'users', user.uid);
                batch.update(userRef, { hasMigratedXpSystemV5: true });

                try {
                    await batch.commit();
                    console.log(`Successfully migrated XP for ${streaksToUpdate.length} streaks.`);
                } catch (error) {
                    console.error("Error migrating old streaks:", error);
                }
            }


            // Configuration for levels based on XP (NEW VALUES)
            const LEVEL_CONFIG = [
                { level: 1, xp: 0, title: 'NOVICE' },
                { level: 2, xp: 150, title: 'APPRENTICE' },
                { level: 3, xp: 400, title: 'JOURNEYMAN' },
                { level: 4, xp: 900, title: 'EXPERT' },
                { level: 5, xp: 2500, title: 'MASTER' },
                { level: 6, xp: 4500, title: 'GRANDMASTER' },
                { level: 7, xp: 6500, title: 'LEGEND' },
                { level: 8, xp: 8000, title: 'DEMIGOD' },
            ];
            
            const LEVEL_BADGES_CONFIG = [
                { level: 1, name: 'Novice', icon: '🔰' },
                { level: 2, name: 'Apprentice', icon: '🎓' },
                { level: 3, name: 'Journeyman', icon: '🛠️' },
                { level: 4, name: 'Expert', icon: '🧐' },
                { level: 5, name: 'Master', icon: '🥋' },
                { level: 6, name: 'Grandmaster', icon: '👑' },
                { level: 7, name: 'Legend', icon: '🌟' },
                { level: 8, name: 'Demigod', icon: '🔱' },
            ];

            const ACHIEVEMENTS_CONFIG = [
                { name: "Goal Getter", icon: '🏁', type: 'goal', description: "Achieve your set goal in a streak.", xp: 10 },
                { name: "Gotta Start Somewhere", days: 1, icon: '🌱', xp: 10 },
                { name: "7-Day Streak", days: 7, icon: '⭐', xp: 25 },
                { name: "2-Week Streak", days: 14, icon: '📅', xp: 50 },
                { name: "30-Day Streak", days: 30, icon: '🏆', xp: 125 },
                { name: "Two-Month Trekker", days: 60, icon: '🚶‍♂️', xp: 200 },
                { name: "90-Day Streak", days: 90, icon: '🛡️', xp: 300 },
                { name: "100-Day Streak", days: 100, icon: '💯', xp: 100 },
                { name: "Six-Month Soarer", days: 180, icon: '🕊️', xp: 500 },
                { name: "Nine-Month Ninja", days: 270, icon: '🥷', xp: 500 },
                { name: "One-Year Victor", days: 365, icon: '🏅', xp: 1000 },
                { name: "Demi-God's Path", days: 547, icon: '🌌', xp: 1000 },
                { name: "Final Ascent", days: 730, icon: '🗻', xp: 1200 }
            ];
            
            function calculateLevelFromXp(xp = 0) {
                const currentLevelInfo = LEVEL_CONFIG.slice().reverse().find(l => xp >= l.xp) || LEVEL_CONFIG[0];
                const nextLevelInfo = LEVEL_CONFIG.find(l => l.level === currentLevelInfo.level + 1);

                const xpForCurrentLevel = currentLevelInfo.xp;
                const xpForNextLevel = nextLevelInfo ? nextLevelInfo.xp : Infinity;
                
                const xpInCurrentLevel = xp - xpForCurrentLevel;
                const xpNeededForNextLevel = xpForNextLevel - xpForCurrentLevel;

                let progress = 100;
                if (nextLevelInfo && xpNeededForNextLevel > 0) {
                     progress = Math.round((xpInCurrentLevel / xpNeededForNextLevel) * 100);
                }

                return {
                    level: currentLevelInfo.level,
                    title: currentLevelInfo.title,
                    xpForCurrentLevel,
                    xpForNextLevel,
                    progress,
                };
            }
            
            function calculateXpForStreak(streakDoc, journalEntries) {
                let totalXp = 0;
                if (!streakDoc || !streakDoc.data()) return 0;
                const streakData = streakDoc.data();
                if (!streakData.startDate) return 0;

                const streakStartDate = parseDate(streakData.startDate);
                const streakEndDate = streakData.endDate ? parseDate(streakData.endDate) : new Date();

                if (streakStartDate) {
                    const duration = calculateDuration(streakStartDate, streakEndDate);
                    
                    // Base XP sources (NEW VALUES)
                    let baseXp = duration.days * 2; // Was 5
                    const journalEntriesDuringStreak = journalEntries.filter(doc => {
                        const entryData = doc.data();
                        if (entryData && entryData.date && typeof entryData.date.toDate === 'function') {
                            const entryDate = entryData.date.toDate();
                            return entryDate >= streakStartDate && entryDate <= streakEndDate;
                        }
                        return false;
                    });
                    baseXp += journalEntriesDuringStreak.length * 3; // Was 5

                    // Day-based achievements XP (NEW VALUES)
                    ACHIEVEMENTS_CONFIG.forEach(achievement => {
                        if (achievement.days && duration.days >= achievement.days) {
                            baseXp += achievement.xp;
                        }
                    });

                    // Goal-based achievement XP
                    if (streakData.goalAchieved) {
                        const goalAchievement = ACHIEVEMENTS_CONFIG.find(a => a.type === 'goal');
                        if(goalAchievement) {
                            baseXp += goalAchievement.xp; 
                        }
                    }

                    // Iteratively calculate level-up XP to prevent infinite loops
                    let levelBadgeXp = 0;
                    let lastCalculatedLevel = 1;
                    let hasLeveledUp = true; // Start loop
                    
                    while(hasLeveledUp) {
                        const tempTotalXp = baseXp + levelBadgeXp;
                        const newLevelData = calculateLevelFromXp(tempTotalXp);

                        if (newLevelData.level > lastCalculatedLevel) {
                            levelBadgeXp += (newLevelData.level - lastCalculatedLevel) * 10;
                            lastCalculatedLevel = newLevelData.level;
                        } else {
                            hasLeveledUp = false; // No more level ups, exit loop
                        }
                    }
                    
                    totalXp = baseXp + levelBadgeXp;
                }
               return totalXp;
            }

            async function calculateAndSetCurrentStreakXp() {
                const oldXp = userData.xp || 0;
                let totalXp = 0;
                const activeStreakDoc = userLogs.find(doc => doc.data() && !doc.data().endDate);

                if (activeStreakDoc) {
                    totalXp = calculateXpForStreak(activeStreakDoc, allJournalEntries);
                }
                
                const oldLevelData = calculateLevelFromXp(oldXp);
                const newLevelData = calculateLevelFromXp(totalXp);

                // NEW ROBUST LOGIC: Check against a value on the main user document
                if (newLevelData.level > oldLevelData.level) {
                    const user = auth.currentUser;
                    // Check against the more reliable client-side variable
                    if (newLevelData.level > highestAnnouncedLevelClient && user) {
                        // showLevelUpModal(newLevelData.level, newLevelData.title);
                        
                        // Immediately update the client-side variable to prevent race conditions
                        highestAnnouncedLevelClient = newLevelData.level;

                        // Persist the new highest announced level to the main user doc
                        const userRef = doc(db, 'users', user.uid);
                        updateDoc(userRef, {
                            highestAnnouncedLevelForCurrentStreak: newLevelData.level
                        }).catch(err => console.error("Could not update highest announced level", err));
                    }
                }
                
                userData.xp = totalXp;
                updateGamificationUI(totalXp);
                updateRankProjection();
                updateNextRankEstimate();
            }
            
            function updateGamificationUI(currentXp = 0) {
                const levelData = calculateLevelFromXp(currentXp);

                // Update main stats page rank display
                const levelText = `: LEVEL ${levelData.level} - ${levelData.title}`;
                document.getElementById('rank-header-stats').textContent = "Current Rank" + levelText;

                const xpTextMain = isFinite(levelData.xpForNextLevel) ? `[XP: ${currentXp}/${levelData.xpForNextLevel}]` : `[XP: ${currentXp} / MAX]`;
                const barWidthMain = 20;
                const filledCharsMain = Math.round(barWidthMain * (levelData.progress / 100));
                const emptyCharsMain = barWidthMain - filledCharsMain;
                const asciiBarMain = `[${'█'.repeat(filledCharsMain)}${'░'.repeat(emptyCharsMain)}] ${levelData.progress}%`;
                const fullProgressBarText = `${xpTextMain}\n${asciiBarMain}`;
                document.getElementById('xp-progress-bar-stats').textContent = fullProgressBarText;

                // --- Data is now rendered in renderHud() ---
            }

            function renderCondensedCalendar(year, allLogs, goalDateString, containerSelector, yearLabelSelector, monthsToShow = 12) {
                const container = document.querySelector(containerSelector);
                const yearLabel = document.querySelector(yearLabelSelector);
                if(!container || !yearLabel) return;
                
                container.innerHTML = '';
                
                const activeDays = new Set();
                const endDays = new Set();
                const startDays = new Set();

                allLogs.forEach(doc => {
                    const log = doc.data ? doc.data() : doc;
                    const logStart = parseDate(log.startDate);
                    if (!logStart) return;

                    const logEnd = parseDate(log.endDate) || new Date();
                    
                    if (logStart.getFullYear() === year) {
                        startDays.add(logStart.toISOString().split('T')[0]);
                    }

                    if (log.endDate && logEnd.getFullYear() === year) {
                         endDays.add(logEnd.toISOString().split('T')[0]);
                    }

                    for (let d = new Date(logStart); d <= logEnd; d.setDate(d.getDate() + 1)) {
                        if (d.getFullYear() === year) {
                            activeDays.add(d.toISOString().split('T')[0]);
                        }
                    }
                });

                const monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
                
                const monthsToRender = [];
                const now = new Date();
                const centerDate = new Date(year, now.getMonth(), 1); 

                if (monthsToShow === 12) {
                    for (let i = 0; i < 12; i++) {
                        monthsToRender.push({ month: i, year: year });
                    }
                } else {
                    let startMonthOffset;
                    switch(monthsToShow) {
                        case 1:
                            startMonthOffset = 0; // Current month
                            break;
                        case 3:
                            startMonthOffset = -1; // One month before, current, one after
                            break;
                        case 6:
                            startMonthOffset = -3; // Three months before, current, two after
                            break;
                        default:
                            startMonthOffset = 0;
                    }

                    for (let i = 0; i < monthsToShow; i++) {
                        const monthDate = new Date(centerDate.getFullYear(), centerDate.getMonth() + startMonthOffset + i, 1);
                        monthsToRender.push({ month: monthDate.getMonth(), year: monthDate.getFullYear() });
                    }
                }
                
                const firstMonth = monthsToRender[0];
                const lastMonth = monthsToRender[monthsToRender.length - 1];
                if (firstMonth.year !== lastMonth.year) {
                    yearLabel.textContent = `${firstMonth.year} - ${lastMonth.year}`;
                } else {
                    yearLabel.textContent = year;
                }

                monthsToRender.forEach(dateInfo => {
                    const month = dateInfo.month;
                    const currentFullYear = dateInfo.year;
                    
                    const monthContainer = document.createElement('div');
                    monthContainer.className = 'month-grid-container';
                    monthContainer.innerHTML = `
                        <h3 class="month-grid-title">${monthNames[month]} ${currentFullYear}</h3>
                        <div class="month-grid-dow">
                            ${['S', 'M', 'T', 'W', 'T', 'F', 'S'].map(d => `<div>${d}</div>`).join('')}
                        </div>
                    `;
                    const monthGrid = document.createElement('div');
                    monthGrid.className = 'month-grid';

                    const firstDayOfMonth = new Date(currentFullYear, month, 1).getDay();
                    const daysInMonth = new Date(currentFullYear, month + 1, 0).getDate();

                    for(let i=0; i<firstDayOfMonth; i++) {
                        monthGrid.appendChild(document.createElement('div'));
                    }

                    for(let day = 1; day <= daysInMonth; day++) {
                        const dayCell = document.createElement('div');
                        dayCell.className = 'month-grid-day';
                        const dateString = `${currentFullYear}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                        dayCell.dataset.date = dateString; // For tooltip
                        dayCell.title = dateString;

                        const isEndDay = endDays.has(dateString);
                        const isActiveDay = activeDays.has(dateString);
                        const isStartDay = startDays.has(dateString);

                        if (isEndDay || isActiveDay || isStartDay || userCheckins.some(doc => doc.id === dateString)) {
                            dayCell.classList.add('has-data');
                        }

                        if (isEndDay && isStartDay) dayCell.classList.add('end-and-start');
                        else if (isEndDay) dayCell.classList.add('end');
                        else if (isActiveDay) dayCell.classList.add('active');
                        
                        if (dateString === goalDateString) dayCell.classList.add('goal-day');

                        monthGrid.appendChild(dayCell);
                    }
                    monthContainer.appendChild(monthGrid);
                    container.appendChild(monthContainer);
                });
            }

            function showXpToast(amount, reason) {
                const toast = document.getElementById('xp-toast');
                toast.textContent = `${amount >= 0 ? '+' : ''}${amount} XP (${reason})`;
                toast.classList.remove('hidden');
                toast.style.opacity = '1';
                toast.style.bottom = '100px';

                setTimeout(() => {
                    toast.style.opacity = '0';
                    toast.style.bottom = '80px';
                    setTimeout(() => toast.classList.add('hidden'), 500);
                }, 3000);
            }
            
            function showLevelsModal() {
                const modalContent = document.getElementById('levels-modal-content');
                let tableHTML = '<table><thead><tr><th>Level</th><th>Title</th><th>XP Required</th></tr></thead><tbody>';
                LEVEL_CONFIG.forEach(level => {
                    tableHTML += `<tr><td>${level.level}</td><td>${level.title}</td><td>${level.xp} XP</td></tr>`;
                });
                tableHTML += '</tbody></table>';
                modalContent.innerHTML = tableHTML;
                levelsModal.classList.remove('hidden');
            }

            function hideLevelsModal() {
                levelsModal.classList.add('hidden');
            }
            
            function updateRankProjection() {
                if (!rankProjectionSelect.value) {
                    rankProjectionDays.textContent = '-';
                    rankProjectionDate.textContent = 'Select a Rank';
                    return;
                }

                const targetLevel = parseInt(rankProjectionSelect.value, 10);
                const targetLevelData = LEVEL_CONFIG.find(l => l.level === targetLevel);
                if (!targetLevelData) return;

                const targetXp = targetLevelData.xp;
                const currentXp = userData.xp || 0;

                if (currentXp >= targetXp) {
                    rankProjectionDays.textContent = '0';
                    rankProjectionDate.textContent = 'Achieved!';
                    return;
                }

                const activeStreak = userLogs.find(doc => doc.data() && !doc.data().endDate);
                if (!activeStreak) {
                    rankProjectionDays.textContent = 'N/A';
                    rankProjectionDate.textContent = 'Start a streak';
                    return;
                }
                
                const streakDuration = calculateDuration(activeStreak.data().startDate, null).totalMilliseconds;
                const daysSoFar = Math.max(1, streakDuration / (1000 * 60 * 60 * 24));
                const xpPerDay = currentXp / daysSoFar;

                if (xpPerDay <= 0) {
                    rankProjectionDays.textContent = '∞';
                    rankProjectionDate.textContent = 'Earn some XP!';
                    return;
                }

                const xpNeeded = targetXp - currentXp;
                const daysRemaining = Math.ceil(xpNeeded / xpPerDay);
                
                const today = new Date();
                const estimatedDate = new Date();
                estimatedDate.setDate(today.getDate() + daysRemaining);
                const formattedDate = formatShortDate(estimatedDate);

                rankProjectionDays.textContent = `~${daysRemaining} days`;
                rankProjectionDate.textContent = formattedDate;
            }

            function updateNextRankEstimate() {
                const nextRankEstimateEl = document.getElementById('next-rank-estimate');
                if (!nextRankEstimateEl) return;

                const currentXp = userData.xp || 0;
                const levelData = calculateLevelFromXp(currentXp);
                const nextLevelXp = levelData.xpForNextLevel;

                if (!isFinite(nextLevelXp)) {
                    nextRankEstimateEl.textContent = 'Max Rank Achieved!';
                    return;
                }

                const activeStreak = userLogs.find(doc => doc.data() && !doc.data().endDate);
                if (!activeStreak) {
                    nextRankEstimateEl.textContent = 'Start a streak to estimate.';
                    return;
                }
                
                const streakDuration = calculateDuration(activeStreak.data().startDate, null).totalMilliseconds;
                const daysSoFar = Math.max(1, streakDuration / (1000 * 60 * 60 * 24));
                const xpPerDay = currentXp / daysSoFar;

                if (xpPerDay <= 0) {
                    nextRankEstimateEl.textContent = 'Next rank in ∞ days (Earn XP!)';
                    return;
                }

                const xpNeeded = nextLevelXp - currentXp;
                const daysRemaining = Math.ceil(xpNeeded / xpPerDay);
                
                const today = new Date();
                const estimatedDate = new Date();
                estimatedDate.setDate(today.getDate() + daysRemaining);
                const formattedDate = formatShortDate(estimatedDate);

                nextRankEstimateEl.textContent = `Next rank in ~${daysRemaining} days (${formattedDate})`;
            }

            function getFinalGoalDateString() {
                let finalGoalDateString = userData.goalDate || null;
                const activeStreakForGoal = userLogs.find(doc => doc.data() && !doc.data().endDate);
        
                if (userData.goal > 0 && activeStreakForGoal) {
                    const startDate = parseDate(activeStreakForGoal.data().startDate);
                    if (startDate) {
                        const goalDateObj = new Date(startDate);
                        goalDateObj.setDate(goalDateObj.getDate() + userData.goal);
                        
                        const year = goalDateObj.getFullYear();
                        const month = String(goalDateObj.getMonth() + 1).padStart(2, '0');
                        const day = String(goalDateObj.getDate()).padStart(2, '0');
                        finalGoalDateString = `${year}-${month}-${day}`;
                    }
                }
                return finalGoalDateString;
            }

            function parseDate(dateInput) {
                if (!dateInput) return null;
                if (dateInput && typeof dateInput.toDate === 'function') {
                    return dateInput.toDate();
                }
                if (dateInput instanceof Date) {
                    return dateInput;
                }
                if (typeof dateInput === 'string' && dateInput.match(/^\d{4}-\d{2}-\d{2}$/)) {
                    return new Date(dateInput + 'T00:00:00');
                }
                const date = new Date(dateInput); 
                return isNaN(date.getTime()) ? null : date;
            }
            
            function formatShortDate(dateInput) {
                const date = parseDate(dateInput);
                if (!date) return 'Invalid';
                const options = { year: 'numeric', month: 'short', day: 'numeric' };
                return date.toLocaleDateString('en-US', options);
            }

            function formatDate(dateInput) {
                const date = parseDate(dateInput);
                if (!date) return 'Invalid Date';
                const options = { year: 'numeric', month: 'long', day: 'numeric', timeZone: 'UTC' };
                return date.toLocaleDateString('en-US', options);
            }

            function formatDateForInput(date) {
                if (!date || !(date instanceof Date)) return '';
                const pad = (num) => num.toString().padStart(2, '0');
                const year = date.getFullYear();
                const month = pad(date.getMonth() + 1);
                const day = pad(date.getDate());
                const hours = pad(date.getHours());
                const minutes = pad(date.getMinutes());
                return `${year}-${month}-${day}T${hours}:${minutes}`;
            }
            
            function formatFullDate(date) {
                if (!date || !(date instanceof Date)) return 'N/A';
                const options = { year: 'numeric', month: 'long', day: 'numeric', hour: 'numeric', minute: 'numeric' };
                return date.toLocaleDateString('en-US', options);
            }

            function calculateDuration(startDateInput, endDateInput) {
                const start = parseDate(startDateInput);
                if (!start) return { totalMilliseconds: 0, formatted: "Invalid", days: 0, hours: 0, minutes: 0, seconds: 0 };

                const end = endDateInput ? parseDate(endDateInput) : new Date();
                if (!end) return { totalMilliseconds: 0, formatted: "Invalid", days: 0, hours: 0, minutes: 0, seconds: 0 };
            
                const diff = end - start;
                if (isNaN(diff) || diff < 0) return { totalMilliseconds: 0, formatted: "0d 0h 0m", days: 0, hours: 0, minutes: 0, seconds: 0 };

                const days = Math.floor(diff / (1000 * 60 * 60 * 24));
                const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((diff % (1000 * 60)) / 1000);

                const formatted = endDateInput 
                    ? `${days}d ${hours}h ${minutes}m`
                    : `${days}d ${hours}h ${minutes}m`;

                return { totalMilliseconds: diff, formatted, days, hours, minutes, seconds };
            }

            function calculateXpUpToDate(streakDoc, journalEntries, targetEndDate) {
                let totalXp = 0;
                if (!streakDoc || !streakDoc.data()) return 0;
                const streakData = streakDoc.data();
                if (!streakData.startDate) return 0;

                const streakStartDate = parseDate(streakData.startDate);
                const streakEndDate = targetEndDate; // Use the provided end date

                if (streakStartDate && streakEndDate >= streakStartDate) {
                    const duration = calculateDuration(streakStartDate, streakEndDate);
                    
                    // Base XP sources
                    let baseXp = duration.days * 5;
                    const journalEntriesDuringPeriod = journalEntries.filter(doc => {
                        const entryData = doc.data();
                        if (entryData && entryData.date && typeof entryData.date.toDate === 'function') {
                            const entryDate = entryData.date.toDate();
                            // Make sure to only include entries up to the target end date
                            return entryDate >= streakStartDate && entryDate <= streakEndDate;
                        }
                        return false;
                    });
                    baseXp += journalEntriesDuringPeriod.length * 5;

                    // Day-based achievements XP
                    ACHIEVEMENTS_CONFIG.forEach(achievement => {
                        if (achievement.days && duration.days >= achievement.days) {
                            baseXp += 10;
                        }
                    });

                    // Goal-based achievement XP (if it happened within the period)
                    if (streakData.goalAchieved && streakData.goal) {
                        let goalAchievedDate = new Date(streakStartDate);
                        goalAchievedDate.setDate(goalAchievedDate.getDate() + streakData.goal);
                        if(goalAchievedDate <= streakEndDate) {
                             baseXp += 10;
                        }
                    }

                    // Iteratively calculate level-up XP
                    let levelBadgeXp = 0;
                    let lastCalculatedLevel = 1;
                    let hasLeveledUp = true;
                    
                    while(hasLeveledUp) {
                        const tempTotalXp = baseXp + levelBadgeXp;
                        const newLevelData = calculateLevelFromXp(tempTotalXp);

                        if (newLevelData.level > lastCalculatedLevel) {
                            levelBadgeXp += (newLevelData.level - lastCalculatedLevel) * 10;
                            lastCalculatedLevel = newLevelData.level;
                        } else {
                            hasLeveledUp = false;
                        }
                    }
                    
                    totalXp = baseXp + levelBadgeXp;
                }
               return totalXp;
            }
            
            function formatDurationFromMs(ms) {
                if (isNaN(ms) || ms < 0) {
                    return { formatted: "0d 0h 0m", days: 0, hours: 0, minutes: 0 };
                }
                const days = Math.round(ms / (1000 * 60 * 60 * 24));
                return { formatted: `${days} days`, days };
            }
            
            function calculateTotalDaysThisYear(logsToCalculate) {
                const currentYear = new Date().getFullYear();
                let totalDays = 0;

                logsToCalculate.forEach(doc => {
                    const log = doc.data();
                    const startDate = parseDate(log.startDate);
                    const endDate = parseDate(log.endDate) || new Date();

                    if (!startDate) return;

                    if (startDate.getFullYear() > currentYear && endDate.getFullYear() > currentYear) return;

                    const startOfYear = new Date(currentYear, 0, 1);
                    const endOfYear = new Date(currentYear, 11, 31, 23, 59, 59);

                    const streakStart = startDate < startOfYear ? startOfYear : startDate;
                    const streakEnd = endDate > endOfYear ? endOfYear : endDate;
                    
                    if (streakEnd > streakStart) {
                        const diffTime = Math.abs(streakEnd - streakStart);
                        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                        totalDays += diffDays;
                    }
                });
                return totalDays;
            }

            function calculateStats() {
                let longestDurationMs = 0;
                let totalCompletedDurationMs = 0;
                let completedEntriesCount = 0;
                let ongoingEntry = null;

                userLogs.forEach(doc => {
                    const log = doc.data();
                    const duration = calculateDuration(log.startDate, log.endDate);
                    if (log.endDate) {
                        totalCompletedDurationMs += duration.totalMilliseconds;
                        completedEntriesCount++;
                    } else {
                        ongoingEntry = log;
                    }
                    
                    if (duration.totalMilliseconds > longestDurationMs) {
                        longestDurationMs = duration.totalMilliseconds;
                    }
                });

                const longestDuration = formatDurationFromMs(longestDurationMs);
                longestStreakStat.textContent = `${longestDuration.days} days`;
                
                if (completedEntriesCount > 0) {
                    const avgMs = totalCompletedDurationMs / completedEntriesCount;
                    const roundedDays = Math.round(avgMs / (1000 * 60 * 60 * 24));
                    avgDurationStat.textContent = `${roundedDays} days`;
                } else {
                    avgDurationStat.textContent = "0 days";
                }

                if (ongoingEntry) {
                    if (ongoingStreakInterval) clearInterval(ongoingStreakInterval);
                    const update = () => {
                        // All HUD rendering is now handled by renderHud()
                        renderHud();

                        // --- Goal Achievement Check ---
                        const activeStreakDoc = userLogs.find(doc => doc.data() && !doc.data().endDate);
                        const streakData = activeStreakDoc?.data();

                        if (streakData && !streakData.goalAchieved) {
                            // Goal is stored directly on the streak doc now
                            const goalInDays = streakData.goal; 
                            const currentDuration = calculateDuration(ongoingEntry.startDate, null);
                            if (goalInDays > 0 && currentDuration.days >= goalInDays) {
                                const user = auth.currentUser;
                                if(user){
                                    const streakRef = doc(db, 'users', user.uid, 'logs', activeStreakDoc.id);
                                    updateDoc(streakRef, { goalAchieved: true });
                                    showXpToast(10, 'Badge: Goal Getter');
                                }
                            }
                        }
                    };
                    update();
                    ongoingStreakInterval = setInterval(update, 1000);
                } else {
                    if (ongoingStreakInterval) clearInterval(ongoingStreakInterval);
                     // Render one last time to show standby status
                    renderHud();
                }
                
                totalDaysYearStat.textContent = `${calculateTotalDaysThisYear(userLogs)} days`;
                renderCondensedCalendar(displayedYear, userLogs, getFinalGoalDateString(), '#condensed-calendar-container', '#current-year-label', calendarMonthsToShow);
                calculateAndDisplayHighestRank();
            }

            function calculateAndDisplayHighestRank() {
                if (!highestRankStat) return;

                let highestLevel = 1;
                let highestTitle = 'NOVICE';

                // Check current streak first
                const activeStreak = userLogs.find(doc => doc.data() && !doc.data().endDate);
                if (activeStreak) {
                    const currentRankData = calculateLevelFromXp(userData.xp || 0);
                    highestLevel = currentRankData.level;
                    highestTitle = currentRankData.title;
                }

                // Then check completed streaks
                const completedStreaks = userLogs.filter(doc => doc.data() && doc.data().endDate);
                completedStreaks.forEach(streak => {
                    const data = streak.data();
                    let rankData;
                    if (typeof data.finalXp === 'number') {
                        rankData = calculateLevelFromXp(data.finalXp);
                    } else {
                        // Fallback for older data that didn't store finalXp
                        const xp = calculateXpForStreak(streak, allJournalEntries);
                        rankData = calculateLevelFromXp(xp);
                    }
                    
                    if (rankData.level > highestLevel) {
                        highestLevel = rankData.level;
                        highestTitle = rankData.title;
                    }
                });

                highestRankStat.innerHTML = `Lvl ${highestLevel} - ${highestTitle}`;
            }
            
            function renderAchievements() {
                myAchievementsGrid.innerHTML = '';
                availableBadgesGrid.innerHTML = '';
                
                const ongoingEntry = userLogs.find(doc => doc.data() && !doc.data().endDate);
                const currentStreakDays = ongoingEntry ? calculateDuration(ongoingEntry.data().startDate, null).days : 0;
                const currentXp = userData.xp || 0;
                const { level: currentLevel } = calculateLevelFromXp(currentXp);
                
                const allBadges = [].concat(ACHIEVEMENTS_CONFIG, LEVEL_BADGES_CONFIG);

                allBadges.forEach(badge => {
                    let unlocked = false;
                    let tooltipText = '';

                    if (badge.days !== undefined) {
                        unlocked = currentStreakDays >= badge.days;
                        tooltipText = `Maintain a streak for ${badge.days} day${badge.days > 1 ? 's' : ''}.`;
                    } else if (badge.level !== undefined) {
                        unlocked = currentLevel >= badge.level;
                        tooltipText = `Reach Level ${badge.level}: ${badge.name}.`;
                    } else if (badge.type === 'goal') {
                        const activeStreakDoc = userLogs.find(doc => doc.data() && !doc.data().endDate);
                        unlocked = !!(activeStreakDoc && activeStreakDoc.data().goalAchieved);
                        tooltipText = badge.description;
                    }

                    const grid = unlocked ? myAchievementsGrid : availableBadgesGrid;
                    const badgeEl = document.createElement('div');
                    badgeEl.className = 'badge-card';
                    let badgeName = badge.name;
                    if (badge.level) {
                        badgeName = `Lvl ${badge.level}: ${badge.name}`;
                    }
                    badgeEl.innerHTML = `
                        <span class="badge-tooltip">${tooltipText}</span>
                        <div class="badge-icon ${unlocked ? 'unlocked' : ''}">${badge.icon}</div>
                        <div class="badge-name">${badgeName}</div>
                    `;
                    grid.appendChild(badgeEl);
                });

                if (myAchievementsGrid.children.length === 0) {
                    myAchievementsGrid.innerHTML = '<p style="font-style: italic; color: #aaa;">Keep going! You haven\'t earned any badges yet on this streak.</p>';
                }

                if (availableBadgesGrid.children.length === 0 && ongoingEntry) {
                     availableBadgesGrid.innerHTML = '<p style="font-style: italic; color: #aaa;">Congratulations! You have collected all available badges!</p>';
                }
            }
            
            function applyAndRenderJournalFilters() {
                const searchTerm = journalSearchInput.value.toLowerCase();
                const startDate = journalFilterStartDate.value;
                const endDate = journalFilterEndDate.value;

                const filteredEntries = allJournalEntries.filter(doc => {
                    const entry = doc.data();
                    if (!entry.date || typeof entry.date.toDate !== 'function') return false;
                    
                    const entryDate = entry.date.toDate();
                    const textMatch = (entry.text || '').toLowerCase().includes(searchTerm);
                    const startDateMatch = !startDate || entryDate >= new Date(startDate);
                    const endDateMatch = !endDate || entryDate <= new Date(new Date(endDate).setHours(23, 59, 59));
                    
                    return textMatch && startDateMatch && endDateMatch;
                });
                
                renderJournalEntries(filteredEntries);
            }

            // NEW: Centralized function to build and render the HUD
            function renderHud() {
                if (!hudContainer) return;

                // --- Get Data ---
                const activeStreak = userLogs.find(doc => doc.data() && !doc.data().endDate);
                const levelData = calculateLevelFromXp(userData.xp || 0);
                
                let hudHTML = '';

                // --- Build all potential content lines with HTML ---
                const status = activeStreak ? '[ ACTIVE ]' : '[ STANDBY ]';
                const uptime = activeStreak ? `${calculateDuration(activeStreak.data().startDate, null).days}d ${String(calculateDuration(activeStreak.data().startDate, null).hours).padStart(2, '0')}h ${String(calculateDuration(activeStreak.data().startDate, null).minutes).padStart(2, '0')}m ${String(calculateDuration(activeStreak.data().startDate, null).seconds).padStart(2, '0')}s` : '0d 00h 00m 00s';
                
                hudHTML += `<div class="hud-row"><span class="hud-label">STREAK STATUS</span><span class="hud-value">${status}</span></div>`;
                hudHTML += `<div class="hud-row"><span class="hud-label">SESSION UPTIME</span><span class="hud-value">${uptime}</span></div>`;
                hudHTML += `<hr class="hud-divider">`;

                // --- Rank Section ---
                const xpText = isFinite(levelData.xpForNextLevel) ? `${userData.xp || 0} / ${levelData.xpForNextLevel}` : `${userData.xp || 0} / MAX`;
                hudHTML += `<div class="hud-row"><span class="hud-label">OPERATIVE RANK</span><span class="hud-value">LVL ${levelData.level} - ${levelData.title}</span></div>`;
                hudHTML += `<div class="hud-row"><span class="hud-label">EXPERIENCE</span><span class="hud-value">${xpText}</span></div>`;
                hudHTML += `<div class="hud-progress-bar-container"><div class="hud-progress-bar-fill" style="width: ${levelData.progress}%;"></div></div>`;
                hudHTML += `<hr class="hud-divider">`;


                // --- Goal Section ---
                const goalDaysToUse = activeStreak?.data().goal || userData.goal;
                const goalDateToUse = activeStreak?.data().goalDate || userData.goalDate;
                let totalGoalDays = goalDaysToUse;
                if (goalDateToUse && !totalGoalDays && activeStreak) {
                    const startDate = parseDate(activeStreak.data().startDate);
                    const targetDate = parseDate(goalDateToUse);
                    if (startDate && targetDate && targetDate > startDate) {
                        const startOfDay = new Date(startDate); startOfDay.setHours(0, 0, 0, 0);
                        const targetDay = new Date(targetDate); targetDay.setHours(0, 0, 0, 0);
                        totalGoalDays = Math.round((targetDay - startOfDay) / (1000 * 60 * 60 * 24));
                    }
                }

                let goalObjectiveText = 'NO OBJECTIVE SET';
                let goalProgressText = '-- / --';
                let progressPercentage = 0;
                let progressPercentageText = ''; // Add a variable for the percentage string
                
                if (totalGoalDays > 0) {
                    const currentDays = activeStreak ? calculateDuration(activeStreak.data().startDate, null).days : 0;
                    const finalGoalDate = getFinalGoalDateString();
                    goalObjectiveText = finalGoalDate ? `${totalGoalDays} DAY STREAK (BY ${formatDate(finalGoalDate)})` : `${totalGoalDays} DAY STREAK`;
                    goalProgressText = `${currentDays} / ${totalGoalDays} DAYS`;
                    progressPercentage = Math.min((currentDays / totalGoalDays) * 100, 100);
                    progressPercentageText = ` (${Math.round(progressPercentage)}%)`; // Create the percentage text
                }
                
                hudHTML += `<div class="hud-row"><span class="hud-label">CURRENT OBJECTIVE</span><span class="hud-value hud-button">[EDIT]</span></div>`;
                hudHTML += `<p class="hud-goal-text">${goalObjectiveText}</p>`;
                hudHTML += `<div class="hud-progress-bar-container"><div class="hud-progress-bar-fill" style="width: ${progressPercentage}%;"></div></div>`;
                hudHTML += `<div class="hud-row"><span class="hud-label">PROGRESS${progressPercentageText}</span><span class="hud-value">${goalProgressText}</span></div>`;

                hudContainer.innerHTML = hudHTML;
            }

            function renderJournalEntries(journalDocs) {
                journalEntriesContainer.innerHTML = '';
                if (journalDocs.length === 0) {
                    journalEntriesContainer.innerHTML = '<p style="text-align: center; margin-top: 20px;">No entries to display.</p>';
                    return;
                }
                // Separate pinned from unpinned entries
                const pinnedEntries = journalDocs.filter(doc => doc.data().isPinned);
                const unpinnedEntries = journalDocs.filter(doc => !doc.data().isPinned);

                const renderEntry = (doc) => {
                    const entry = doc.data();
                    const entryDiv = document.createElement('div');
                    entryDiv.className = 'journal-entry';
                    entryDiv.dataset.id = doc.id;
                    const isPinned = !!entry.isPinned;
                    if (isPinned) {
                        entryDiv.classList.add('pinned');
                    }

                    entryDiv.innerHTML = `
                        <div class="journal-entry-date">${formatFullDate(entry.date.toDate())} ${isPinned ? '📌' : ''}</div>
                        <div class="journal-entry-content"><p class="journal-entry-text">${entry.text}</p></div>
                        <div class="journal-entry-actions">
                            <button class="pin-btn">${isPinned ? 'Unpin' : 'Pin'}</button>
                            <button class="edit-btn">Edit</button>
                            <button class="delete-btn">Delete</button>
                        </div>
                    `;
                    journalEntriesContainer.appendChild(entryDiv);
                };

                // Render pinned entries first, then unpinned
                pinnedEntries.forEach(renderEntry);
                unpinnedEntries.forEach(renderEntry);
            }

            function setActiveTab(tabId) {
                // Hide all containers
                [dashboardContainer, logbookContainer, achievementsContainer, journalContainer, aboutContainer, profileContainer].forEach(container => {
                    container.classList.add('hidden');
                });

                // Show the selected container
                const containerToShow = document.getElementById(`${tabId}-container`);
                if (containerToShow) {
                    containerToShow.classList.remove('hidden');
                } else if (tabId === 'stats') { // 'stats' maps to 'logbook-container'
                    logbookContainer.classList.remove('hidden');
                }


                // Update active class on nav links
                allNavLinkBtns.forEach(btn => {
                    if (btn.dataset.tab === tabId) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                });
            }

            function renderStreakHistory() {
                streakHistoryContainer.innerHTML = '';
                
                // Render active streak first if it exists
                const activeStreakDoc = userLogs.find(doc => doc.data() && !doc.data().endDate);
                if (activeStreakDoc) {
                    const streak = activeStreakDoc.data();
                    const item = document.createElement('div');
                    item.className = 'streak-history-item active'; // Always active style
                    item.dataset.streakId = activeStreakDoc.id;

                    const currentDuration = calculateDuration(streak.startDate, null);
                    const currentRankData = calculateLevelFromXp(userData.xp || 0);

                    item.innerHTML = `
                        <div class="streak-history-item-clickable">
                            <div class="streak-history-item-header">
                                <span>${formatDate(streak.startDate)} - Present</span>
                                <span id="active-streak-duration-in-log">${currentDuration.formatted}</span>
                            </div>
                            <div class="streak-history-item-details">
                                Current Rank: Lvl ${currentRankData.level} - ${currentRankData.title} (${userData.xp || 0} XP)
                            </div>
                             <div class="journal-entry-actions" style="justify-content: flex-end;">
                                <button class="end-streak-btn" data-streak-id="${activeStreakDoc.id}">End & Restart</button>
                            </div>
                        </div>
                        <div class="streak-detail-view"></div>
                    `;
                    streakHistoryContainer.appendChild(item);
                }


                const completedStreaks = userLogs.filter(doc => doc.data() && doc.data().endDate);
                
                if (completedStreaks.length === 0 && !activeStreakDoc) {
                    streakHistoryContainer.innerHTML = '<p style="text-align:center; font-style: italic; color: #aaa;">No streaks logged yet. Add one above to get started!</p>';
                    return;
                }

                completedStreaks.forEach(doc => {
                    const streak = doc.data();
                    const duration = calculateDuration(streak.startDate, streak.endDate);
                    const item = document.createElement('div');
                    item.className = 'streak-history-item';
                    item.dataset.streakId = doc.id;

                    const finalXp = streak.finalXp || calculateXpForStreak(doc, allJournalEntries);
                    const rankData = calculateLevelFromXp(finalXp);

                    item.innerHTML = `
                        <div class="streak-history-item-clickable">
                            <div class="streak-history-item-header">
                                <span>${formatDate(streak.startDate)} - ${formatDate(streak.endDate)}</span>
                                <span>${duration.formatted}</span>
                            </div>
                            <div class="streak-history-item-details">
                                Final Rank: Lvl ${rankData.level} - ${rankData.title} (${finalXp} XP)
                            </div>
                        </div>
                        <div class="streak-detail-view"></div>
                    `;
                    streakHistoryContainer.appendChild(item);
                });
            }
            
            function generateXpHistoryHtml(streakDoc) {
                const streakData = streakDoc.data();
                const startDate = parseDate(streakData.startDate);
                const endDate = parseDate(streakData.endDate) || new Date(); 

                // 1. Gather all base events that can grant XP
                let xpEvents = [];
                const duration = calculateDuration(startDate, endDate);
                for (let d = 1; d <= duration.days; d++) {
                    let eventDate = new Date(startDate);
                    eventDate.setDate(eventDate.getDate() + d);
                    xpEvents.push({
                        date: eventDate,
                        points: 2, // UPDATED
                        reason: `Day ${d} maintained`
                    });
                }

                const journalEntriesDuringStreak = allJournalEntries.filter(doc => {
                    const entryDate = parseDate(doc.data().date);
                    return entryDate >= startDate && entryDate <= endDate;
                });
                journalEntriesDuringStreak.forEach(doc => {
                    xpEvents.push({
                        date: parseDate(doc.data().date),
                        points: 3, // UPDATED
                        reason: 'Journal Entry'
                    });
                });

                // Add Goal Getter Badge event if achieved
                if (streakData.goalAchieved) {
                    const goalAchievement = ACHIEVEMENTS_CONFIG.find(a => a.type === 'goal');
                    if (goalAchievement && streakData.goal) {
                        let eventDate = new Date(startDate);
                        eventDate.setDate(eventDate.getDate() + streakData.goal);
                         xpEvents.push({
                             date: eventDate,
                             points: goalAchievement.xp,
                             reason: `Badge: ${goalAchievement.name}`
                           });
                    }
                }

                ACHIEVEMENTS_CONFIG.forEach(achievement => {
                     if (achievement.days && duration.days >= achievement.days) {
                         let eventDate = new Date(startDate);
                         eventDate.setDate(eventDate.getDate() + achievement.days);
                         xpEvents.push({
                             date: eventDate,
                             points: achievement.xp,
                             reason: `Badge: ${achievement.name}`
                         });
                     }
                });

                // 2. Gather check-in events (they don't grant XP)
                const checkinEvents = userCheckins
                    .filter(doc => {
                        const checkinDate = parseDate(doc.data().date);
                        return checkinDate >= startDate && checkinDate <= endDate;
                    })
                    .map(doc => {
                        const data = doc.data();
                        const activities = [];
                        if (data.locked) activities.push('Locked');
                        if (data.sex) activities.push('Sex');
                        if (data.edged) activities.push('Edged');
                        
                        return {
                            date: parseDate(data.date),
                            type: 'checkin',
                            details: activities.length > 0 ? `Check-in: ${activities.join(', ')}` : 'Check-in: No activities'
                        };
                    });

                // 3. Combine and sort all events chronologically to process them
                const chronologicalEvents = [].concat(
                    xpEvents.map(e => Object.assign({}, e, {type: 'xp'})),
                    checkinEvents
                );
                chronologicalEvents.sort((a, b) => a.date - b.date);

                // 4. Create the final log, calculating running totals and level-ups as we go
                const finalEventsLog = [];
                let runningTotal = 0;
                let lastLevel = 1;

                chronologicalEvents.forEach(event => {
                    if (event.type === 'xp') {
                        runningTotal += event.points;
                        finalEventsLog.push(Object.assign({}, event, { totalAfterEvent: runningTotal }));
                        
                        const newLevelData = calculateLevelFromXp(runningTotal);
                        if (newLevelData.level > lastLevel) {
                            const levelUpPoints = (newLevelData.level - lastLevel) * 10;
                            runningTotal += levelUpPoints;
                            finalEventsLog.push({
                                date: event.date,
                                type: 'xp',
                                points: levelUpPoints,
                                reason: `Rank Up Bonus (Lvl ${newLevelData.level})`,
                                totalAfterEvent: runningTotal
                            });
                            lastLevel = newLevelData.level;
                        }
                    } else {
                        finalEventsLog.push(event); // Add check-ins directly to the log
                    }
                });
                
                // 5. Reverse for display (newest first) and build HTML
                const listItemsHtml = finalEventsLog.reverse().map(event => {
                    if (event.type === 'xp') {
                        return `
                            <li>
                                <span class="xp-log-date">${formatShortDate(event.date)}</span>
                                <span class="xp-log-reason">${event.reason}</span>
                                <span class="xp-log-points">+${event.points} XP (Total: ${event.totalAfterEvent})</span>
                            </li>
                        `;
                    } else { // 'checkin'
                        return `
                            <li>
                                <span class="xp-log-date">${formatShortDate(event.date)}</span>
                                <span class="xp-log-reason">${event.details}</span>
                                <span class="xp-log-points"></span>
                            </li>
                        `;
                    }
                }).join('');
                
                if (finalEventsLog.length === 0){
                     return '<ul class="xp-log-list"><li>No events recorded for this period.</li></ul>';
                }

                return `<ul class="xp-log-list">${listItemsHtml}</ul>`;
            }


            async function handleUpdateUsername() {
                const user = auth.currentUser;
                if (!user) return;

                const newUsername = newUsernameInput.value.trim();
                const oldUsername = userData.username;
                usernameStatus.textContent = '';

                if (newUsername.toLowerCase() === (oldUsername || '').toLowerCase()) {
                    usernameStatus.textContent = "This is already your username.";
                    return;
                }

                if (!newUsername || newUsername.length < 3 || newUsername.length > 15 || /\s/.test(newUsername)) {
                    usernameStatus.textContent = "Username must be 3-15 characters with no spaces.";
                    return;
                }

                const newUsernameRef = doc(db, 'usernames', newUsername.toLowerCase());
                
                try {
                    const usernameDoc = await getDoc(newUsernameRef);
                    if (usernameDoc.exists()) {
                        throw new Error("This username is already taken.");
                    }

                    const batch = writeBatch(db);
                    const userRef = doc(db, 'users', user.uid);
                    batch.update(userRef, { username: newUsername });
                    batch.set(newUsernameRef, { uid: user.uid });

                    if (oldUsername) {
                        const oldUsernameRef = doc(db, 'usernames', oldUsername.toLowerCase());
                        batch.delete(oldUsernameRef);
                    }

                    await batch.commit();
                    usernameStatus.style.color = '#27ff47';
                    usernameStatus.textContent = 'Username updated successfully!';
                    
                    // Refresh public data if enabled
                    if(userData.isPublic) {
                        updatePublicData(user);
                    }

                } catch (error) {
                    usernameStatus.style.color = '#ff0000';
                    usernameStatus.textContent = error.message;
                }
            }
            
            async function updatePublicData(user) {
                if (!user || !userData.username) {
                    console.log("Cannot update public data: User not logged in or no username set.");
                    return;
                }
                const publicProfileRef = doc(db, 'publicProfiles', user.uid);

                const activeStreak = userLogs.find(doc => doc.data() && !doc.data().endDate);
                const currentStreakStartDate = activeStreak ? activeStreak.data().startDate : null;
                
                const longestDuration = formatDurationFromMs(
                    Math.max.apply(null, userLogs.map(doc => calculateDuration(doc.data().startDate, doc.data().endDate).totalMilliseconds))
                );
                
                const completedStreaks = userLogs.filter(doc => doc.data().endDate);
                let avgDurationStatValue = "0 days";
                if (completedStreaks.length > 0) {
                     const totalMs = completedStreaks.reduce((acc, doc) => acc + calculateDuration(doc.data().startDate, doc.data().endDate).totalMilliseconds, 0);
                     const avgMs = totalMs / completedStreaks.length;
                     const roundedDays = Math.round(avgMs / (1000 * 60 * 60 * 24));
                     avgDurationStatValue = `${roundedDays} days`;
                }

                const currentXp = activeStreak ? calculateXpForStreak(activeStreak, allJournalEntries) : 0;
                const levelData = calculateLevelFromXp(currentXp);
                
                const highestRankData = userLogs.reduce((highest, doc) => {
                     const finalXp = doc.data().endDate ? (doc.data().finalXp || calculateXpForStreak(doc, allJournalEntries)) : currentXp;
                     const rank = calculateLevelFromXp(finalXp);
                     return rank.level > highest.level ? rank : highest;
                }, {level: 1, title: 'NOVICE'});

                // Correctly filter all badge types for the public profile
                const allBadges = [].concat(ACHIEVEMENTS_CONFIG, LEVEL_BADGES_CONFIG);
                const unlockedAchievements = allBadges.filter(badge => {
                    if (badge.days !== undefined) {
                        return activeStreak && calculateDuration(currentStreakStartDate, null).days >= badge.days;
                    } else if (badge.level !== undefined) {
                        return levelData.level >= badge.level;
                    }
                    return false;
                });


                const publicData = {
                    displayName: userData.username,
                    currentStreakStartDate: currentStreakStartDate,
                    goal: userData.goal || null,
                    goalDate: userData.goalDate || null,
                    longestStreakDays: longestDuration.days,
                    averageStreakDuration: avgDurationStatValue,
                    totalDaysThisYear: calculateTotalDaysThisYear(userLogs),
                    level: levelData.level,
                    title: levelData.title,
                    highestRankEver: highestRankData,
                    logs: userLogs.map(doc => doc.data()),
                    publicSettings: userData.publicSettings || {},
                    unlockedAchievements: unlockedAchievements
                };

                try {
                    await setDoc(publicProfileRef, publicData);
                    console.log("Public profile updated.");
                } catch (error) {
                    console.error("Error updating public profile:", error);
                }
            }

            function downloadCsv(csvContent, fileName) {
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement("a");
                const url = URL.createObjectURL(blob);
                link.setAttribute("href", url);
                link.setAttribute("download", fileName);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }

            function exportLogsToCsv() {
                if (userLogs.length === 0) return;
                const headers = '"Start Date","End Date","Duration (Formatted)"';
                const rows = userLogs.map(doc => {
                    const log = doc.data();
                    const start = formatFullDate(parseDate(log.startDate));
                    const end = log.endDate ? formatFullDate(parseDate(log.endDate)) : 'Ongoing';
                    const duration = calculateDuration(log.startDate, log.endDate).formatted;
                    return `"${start}","${end}","${duration}"`;
                });
                const csv = [headers, ...rows].join('\n');
                downloadCsv(csv, 'streaker_logs.csv');
            }

            function exportJournalToCsv() {
                if (allJournalEntries.length === 0) return;
                const headers = '"Date","Entry Text"';
                const rows = allJournalEntries.map(doc => {
                    const entry = doc.data();
                    const date = formatFullDate(parseDate(entry.date));
                    const text = entry.text.replace(/"/g, '""'); // Escape double quotes
                    return `"${date}","${text}"`;
                });
                const csv = [headers, ...rows].join('\n');
                downloadCsv(csv, 'streaker_journal.csv');
            }

            // --- GLOBAL EVENT LISTENERS ---
            // These are set up immediately because they are needed for both public and private views.
            
            // Listeners for the ranks & levels modal
            closeLevelsModalBtn.addEventListener('click', hideLevelsModal);
            levelsModal.addEventListener('click', (e) => {
                if (e.target === levelsModal) {
                    hideLevelsModal();
                }
            });


            authForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const email = emailInput.value;
                const password = passwordInput.value;
                authError.textContent = '';

                try {
                    await signInWithEmailAndPassword(auth, email, password);
                } catch (error) {
                    authError.textContent = error.message;
                }
            });


            function addMainAppEventListeners() {
                if (mainAppListenersAdded) return;

                document.querySelectorAll('.sidebar-nav, .mobile-nav').forEach(nav => {
                    nav.addEventListener('click', (e) => {
                        const navLink = e.target.closest('.nav-link');
                        if(navLink) {
                            setActiveTab(navLink.dataset.tab);
                        }
                    });
                });
                
                newLogoutBtn.addEventListener('click', () => signOut(auth));

                // NEW: Event listener for HUD clicks
                hudContainer.addEventListener('click', (e) => {
                    const text = e.target.textContent;
                    if (text.includes('[EDIT]')) {
                         // Populate modal with current values before showing
                        const activeStreakDoc = userLogs.find(doc => doc.data() && !doc.data().endDate);
                        const streakData = activeStreakDoc?.data();
                        modalGoalInput.value = streakData?.goal || userData.goal || '';
                        modalGoalDateInput.value = streakData?.goalDate || userData.goalDate || '';
                        
                        goalModal.classList.remove('hidden');
                    }
                });
                
                // --- Goal Modal Listeners ---
                function closeGoalModal() {
                    goalModal.classList.add('hidden');
                }

                modalCancelGoalBtn.addEventListener('click', closeGoalModal);
                goalModal.addEventListener('click', (e) => {
                    if (e.target === goalModal) {
                        closeGoalModal();
                    }
                });

                modalRandomGoalBtn.addEventListener('click', () => {
                    const randomDays = Math.floor(Math.random() * (100 - 7 + 1)) + 7;
                    modalGoalInput.value = randomDays;
                    modalGoalDateInput.value = ''; // Clear the other input
                });

                modalSaveGoalBtn.addEventListener('click', async () => {
                    const user = auth.currentUser;
                    if (!user) return;
                    
                    let finalGoalDays = parseInt(modalGoalInput.value, 10);
                    let finalGoalDate = modalGoalDateInput.value;

                    // Prioritize days input if both are filled
                    if (finalGoalDays > 0) {
                        finalGoalDate = ''; // Clear date if days are specified
                    } else if (finalGoalDate) {
                        finalGoalDays = 0; // Clear days if date is specified
                    } else {
                        // If both are empty, clear the goal
                        finalGoalDays = null;
                        finalGoalDate = null;
                    }
                    
                    try {
                        const userRef = doc(db, 'users', user.uid);
                        // Save to the main user doc for persistence
                        await updateDoc(userRef, { goal: finalGoalDays, goalDate: finalGoalDate });

                        // Also update the currently active streak
                        const activeStreakDoc = userLogs.find(doc => doc.data() && !doc.data().endDate);
                        if (activeStreakDoc) {
                            const streakRef = doc(db, 'users', user.uid, 'logs', activeStreakDoc.id);
                            await updateDoc(streakRef, {
                                goal: finalGoalDays,
                                goalDate: finalGoalDate,
                                goalAchieved: false // Reset on new goal
                            });
                        }
                        console.log("Goal saved!");
                        closeGoalModal();
                    } catch (error) {
                        console.error("Error saving goal:", error);
                    }
                });

                // Clear one input if the other is used in the modal
                modalGoalInput.addEventListener('input', () => {
                    if (modalGoalInput.value) modalGoalDateInput.value = '';
                });
                modalGoalDateInput.addEventListener('input', () => {
                    if (modalGoalDateInput.value) modalGoalInput.value = '';
                });


                // NEW: Event listeners for export buttons
                exportLogsBtn.addEventListener('click', exportLogsToCsv);
                exportJournalBtn.addEventListener('click', exportJournalToCsv);
                
                // DEBUG FIX: Added submit listener for journal form
                journalForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    const user = auth.currentUser;
                    const text = journalInput.value.trim();
                    if (!user || !text) return;
                    
                    try {
                        const journalCollectionRef = collection(db, 'users', user.uid, 'journal');
                        await addDoc(journalCollectionRef, {
                            text: text,
                            date: serverTimestamp(),
                            isPinned: false
                        });
                        journalInput.value = '';
                        showXpToast(5, 'Journal Entry');
                    } catch (error) {
                        console.error("Error adding journal entry:", error);
                        alert("Could not save your journal entry. Please try again.");
                    }
                });

                // DEBUG FIX: Added submit listener for checkin form
                checkinForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    const user = auth.currentUser;
                    if (!user) return;

                    const todayString = getTodayDateString();
                    const checkinDocRef = doc(db, 'users', user.uid, 'checkins', todayString);

                    const checkinData = {
                        date: serverTimestamp(),
                        locked: checkinLocked.checked,
                        sex: checkinSex.checked,
                        edged: checkinEdged.checked,
                    };

                    try {
                        await setDoc(checkinDocRef, checkinData);
                        const saveBtn = document.getElementById('save-checkin-btn');
                        saveBtn.textContent = 'Saved!';
                        setTimeout(() => { saveBtn.textContent = 'Save Check-in'; }, 2000);
                    } catch (error) {
                        console.error("Error saving check-in:", error);
                        alert("Could not save your check-in. Please try again.");
                    }
                });


                publicProfileToggle.addEventListener('change', async (e) => {
                    const isPublic = e.target.checked;
                    const user = auth.currentUser;
                    if (!user) return;
                    try {
                        const userRef = doc(db, 'users', user.uid);
                        await updateDoc(userRef, { isPublic });
                        publicLinkContainer.classList.toggle('hidden', !isPublic);
                        publicCardsSelection.classList.toggle('hidden', !isPublic); // UPDATED
                        if (isPublic) {
                            updatePublicData(user);
                        }
                    } catch (error) {
                        console.error("Error updating public profile status:", error);
                    }
                });

                 // --- Event listener for streak history accordion ---
                 streakHistoryContainer.addEventListener('click', async (e) => {
                       // Handle End & Restart button click first
                       if (e.target.classList.contains('end-streak-btn')) {
                           const user = auth.currentUser;
                           if (!user) return;
                           const streakId = e.target.dataset.streakId;
                           const activeStreakDoc = userLogs.find(doc => doc.id === streakId);
                           if (activeStreakDoc) {
                               const now = Timestamp.now();
                               const finalXp = calculateXpForStreak(activeStreakDoc, allJournalEntries);

                               const batch = writeBatch(db);
                               const logRef = doc(db, 'users', user.uid, 'logs', streakId);
                               batch.update(logRef, { endDate: now, finalXp: finalXp });

                               const newLogRef = doc(collection(db, 'users', user.uid, 'logs')); // Auto-generate ID
                               batch.set(newLogRef, { startDate: now, endDate: null });
                               
                               // Reset the announced level tracker for the new streak
                               const userRef = doc(db, 'users', user.uid);
                               batch.update(userRef, { highestAnnouncedLevelForCurrentStreak: 0 });

                               await batch.commit();
                           }
                           return; // Stop further execution for this button
                       }

                       const clickableArea = e.target.closest('.streak-history-item-clickable');
                       if (!clickableArea) return;

                       const item = clickableArea.parentElement;
                       const detailView = item.querySelector('.streak-detail-view');
                       const isOpen = detailView.classList.contains('visible');

                       // Close any other open items
                       document.querySelectorAll('.streak-detail-view.visible').forEach(openDetail => {
                           if (openDetail !== detailView) {
                               openDetail.classList.remove('visible');
                               openDetail.parentElement.classList.remove('active');
                               openDetail.innerHTML = ''; // Clear content to save memory
                           }
                       });

                       // If the clicked item was already open, close it. Otherwise, open it.
                       if (isOpen) {
                           detailView.classList.remove('visible');
                           item.classList.remove('active');
                           detailView.innerHTML = '';
                       } else {
                           item.classList.add('active');
                           const streakId = item.dataset.streakId;
                           const selectedStreakDoc = userLogs.find(doc => doc.id === streakId);
                           
                           if (selectedStreakDoc) {
                               // Generate and inject content, then show
                               detailView.innerHTML = generateXpHistoryHtml(selectedStreakDoc);
                               detailView.classList.add('visible');
                           }
                       }
                 });

                 // --- Event Listeners for levels modal (private view) ---
                document.getElementById('rank-header-stats').addEventListener('click', showLevelsModal);
                
                 // --- Event Listener for Dice Roll ---
                rollDiceBtn.addEventListener('click', () => {
                    const options = [
                        "No",
                        "Not today",
                        "Definitely not",
                        "You don't really need to",
                        "Just one more day then roll again"
                    ];
                    const randomIndex = Math.floor(Math.random() * options.length);
                    diceRollResult.textContent = options[randomIndex];
                    rollDiceBtn.textContent = "Roll again";
                });


                populateRankSelector();
                rankProjectionSelect.addEventListener('change', updateRankProjection);

                 // Calendar View Toggle
                calendarViewToggle.addEventListener('click', (e) => {
                    if (e.target.tagName === 'BUTTON') {
                        calendarViewToggle.querySelector('.active').classList.remove('active');
                        e.target.classList.add('active');
                        calendarMonthsToShow = parseInt(e.target.dataset.view, 10);
                        renderCondensedCalendar(displayedYear, userLogs, getFinalGoalDateString(), '#condensed-calendar-container', '#current-year-label', calendarMonthsToShow);
                    }
                });

                mainAppListenersAdded = true;
            }


            function initializeAppForUser(user) {
                authContainer.classList.add('hidden');
                appLayout.classList.remove('hidden');
                addMainAppEventListeners();

                const logsCollectionRef = collection(db, 'users', user.uid, 'logs');
                const journalCollectionRef = collection(db, 'users', user.uid, 'journal');
                const userDocRef = doc(db, 'users', user.uid);


                const logsQuery = query(logsCollectionRef, orderBy('startDate', 'desc'));
                onSnapshot(logsQuery, snapshot => {
                    userLogs = snapshot.docs.filter(doc => doc.data().startDate);
                    // This order is critical to prevent race conditions.
                    // XP must be calculated before achievements are rendered.
                    calculateAndSetCurrentStreakXp().then(() => {
                        calculateStats();
                        renderAchievements(); // FIX: This is the correct place to call this.
                        renderStreakHistory();
                        if (userData.isPublic) {
                            updatePublicData(user);
                        }
                    });
                });
                
                 // MODIFIED: No longer sorting by 'isPinned' in the query
                const journalQuery = query(journalCollectionRef, orderBy('date', 'desc'));
                onSnapshot(journalQuery, snapshot => {
                    allJournalEntries = snapshot.docs;
                    // Client-side sort for pinning
                    allJournalEntries.sort((a, b) => {
                        // FIX: Added checks to prevent errors on malformed data.
                        const aData = a.data() || {};
                        const bData = b.data() || {};
                        const aPinned = aData.isPinned || false;
                        const bPinned = bData.isPinned || false;
                        
                        // Use a default old date if timestamp is missing to prevent crash
                        const aDate = aData.date && aData.date.toMillis ? aData.date.toMillis() : 0;
                        const bDate = bData.date && bData.date.toMillis ? bData.date.toMillis() : 0;


                        if (aPinned && !bPinned) return -1;
                        if (!aPinned && bPinned) return 1;
                        return bDate - aDate; // If both are same pinned status, sort by date
                    });
                    applyAndRenderJournalFilters(); 
                    calculateAndSetCurrentStreakXp().then(() => {
                        if (userData.isPublic) {
                            updatePublicData(user);
                        }
                    });
                });

                const checkinsCollectionRef = collection(db, 'users', user.uid, 'checkins');
                onSnapshot(checkinsCollectionRef, snapshot => {
                    userCheckins = snapshot.docs;
                    renderDailyCheckin();
                    // We need to re-render history if check-ins change, as they appear in the log
                    renderStreakHistory();
                });

                onSnapshot(userDocRef, (doc) => {
                    if (doc.exists()) {
                        const dbData = doc.data();
                        // Merge data from DB without overwriting client-side calculated XP.
                        userData = Object.assign({}, dbData, { xp: userData.xp });
                        
                        // --- NEW MIGRATION TRIGGER ---
                        // Check for the flag before running the migration
                        if (!userData.hasMigratedXpSystemV5) {
                            migrateOldStreaks(user);
                        }
                        // --- END MIGRATION TRIGGER ---

                        // Sync client-side tracker with Firestore
                        highestAnnouncedLevelClient = userData.highestAnnouncedLevelForCurrentStreak || 0;
                        
                        userProfileDisplay.textContent = userData.username || user.email;
                        
                        const isPublic = !!userData.isPublic;
                        publicProfileToggle.checked = isPublic;
                        publicLinkContainer.classList.toggle('hidden', !isPublic);
                        publicCardsSelection.classList.toggle('hidden', !isPublic); // UPDATED

                        // UPDATED: Set checked state for card visibility toggles
                        const publicSettingToggles = document.querySelectorAll('#public-cards-selection input[type="checkbox"]');
                        const defaultSettings = {
                            showCurrentStreak: true,
                            showGoalProgress: true,
                            showLongestStreak: true,
                            showAverageStreak: true,
                            showTotalDaysYear: true,
                            showHighestRank: true,
                            showAchievements: true,
                            showHistory: true,
                            showCalendar: true
                        };
                        const settings = Object.assign({}, defaultSettings, userData.publicSettings || {});

                        publicSettingToggles.forEach(toggle => {
                            const settingKey = toggle.dataset.setting;
                            toggle.checked = settings[settingKey];
                        });


                        if(isPublic && userData.username) {
                            const baseUrl = window.location.href.split(/[?#]/)[0]; // Get base URL without params or hash
                            publicLinkDisplay.value = `${baseUrl}#${userData.username}`;
                        } else {
                            publicLinkDisplay.value = '';
                        }

                        if (!isUpdatingGoal) {
                            const activeStreakDoc = userLogs.find(doc => !doc.data().endDate);
                            const streakData = activeStreakDoc?.data();

                            goalInput.value = streakData?.goal || userData.goal || '';
                            goalDateInput.value = streakData?.goalDate || userData.goalDate || '';
                        }
                        
                        // Recalculate stats to update calendar if goal changed
                        if(userLogs.length > 0) calculateStats(); 
                    }
                });
                
                copyPublicLinkBtn.addEventListener('click', () => {
                    const textToCopy = publicLinkDisplay.value;
                    if (!textToCopy) return;

                    // Create a temporary textarea element to hold the text
                    const textArea = document.createElement('textarea');
                    textArea.value = textToCopy;
                    
                    // Style the textarea to be invisible and off-screen
                    textArea.style.position = 'fixed';
                    textArea.style.top = '-9999px';
                    textArea.style.left = '-9999px';
                    
                    document.body.appendChild(textArea);
                    
                    // Select the text and copy it
                    textArea.focus();
                    textArea.select();

                    try {
                        // Use the legacy execCommand for broader compatibility, especially in iframes
                        document.execCommand('copy');
                        copyPublicLinkBtn.textContent = 'Copied!';
                    } catch (err) {
                        console.error('Failed to copy text: ', err);
                        copyPublicLinkBtn.textContent = 'Failed!';
                    }

                    // Remove the temporary textarea from the DOM
                    document.body.removeChild(textArea);

                    // Reset the button text after a short delay
                    setTimeout(() => {
                        copyPublicLinkBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>`;
                    }, 2000);
                });

                saveUsernameBtn.addEventListener('click', handleUpdateUsername);

                goalInput.addEventListener('input', () => {
                    if (isUpdatingGoal) return;
                    isUpdatingGoal = true;
                    goalDateInput.value = ''; // Clear other input
                    isUpdatingGoal = false;
                    if(isHudInEditMode) renderHud(); // Refresh HUD when typing
                });

                goalDateInput.addEventListener('input', () => {
                    if (isUpdatingGoal) return;
                    isUpdatingGoal = true;
                    goalInput.value = ''; // Clear other input
                    isUpdatingGoal = false;
                    if(isHudInEditMode) renderHud(); // Refresh HUD when typing
                });
                setActiveTab('dashboard');
            }

            function showLoginScreen() {
                [appLayout, publicViewContainer].forEach(c => c.classList.add('hidden'));
                authContainer.classList.remove('hidden');
            }
            
            function updatePublicDynamicElements(data) {
                const daysEl = document.getElementById('public-streak-days');
                if (!daysEl) return; 

                const currentDuration = calculateDuration(data.currentStreakStartDate, null);

                daysEl.textContent = currentDuration.days;
                document.getElementById('public-streak-hours').textContent = String(currentDuration.hours).padStart(2, '0');
                document.getElementById('public-streak-minutes').textContent = String(currentDuration.minutes).padStart(2, '0');
                document.getElementById('public-streak-seconds').textContent = String(currentDuration.seconds).padStart(2, '0');

                const now = new Date();
                const secondsToday = now.getSeconds() + (now.getMinutes() * 60) + (now.getHours() * 3600);
                const progressPercentDaily = (secondsToday / 86400);
                const barWidth = 20;
                const filledChars = Math.round(barWidth * progressPercentDaily);
                const emptyChars = barWidth - filledChars;
                const progressBarEl = document.getElementById('public-daily-progress-bar');
                if(progressBarEl) progressBarEl.textContent = `[${'█'.repeat(filledChars)}${'░'.repeat(emptyChars)}]`;
                
                const goalContainer = document.getElementById('public-goal-progress-container');
                if (goalContainer) {
                    if (data.goal || data.goalDate) {
                        goalContainer.classList.remove('hidden');
                        const currentStreakDays = data.currentStreakStartDate ? currentDuration.days : 0;
                        let totalGoalDays = data.goal; // Default to goal in days if it exists
                        let goalDateText = '';

                        // If a goal date is set, it's the source of truth for total days
                        if (data.goalDate && data.currentStreakStartDate) {
                            const startDate = parseDate(data.currentStreakStartDate);
                            const targetDate = parseDate(data.goalDate);
                            if (startDate && targetDate && targetDate > startDate) {
                                // Create copies of dates and zero out the time to count calendar days accurately.
                                const startOfDay = new Date(startDate);
                                startOfDay.setHours(0, 0, 0, 0);

                                const targetDay = new Date(targetDate);
                                targetDay.setHours(0, 0, 0, 0);
                                
                                const diffMs = targetDay - startOfDay;
                                totalGoalDays = Math.round(diffMs / (1000 * 60 * 60 * 24));
                            }
                        }

                        // Now, construct the display text
                        if (totalGoalDays) {
                            if (data.goalDate) {
                                 goalDateText = `Goal: ${totalGoalDays} days (by ${formatDate(data.goalDate)})`;
                            } else if (data.currentStreakStartDate) {
                                 const projectedDate = parseDate(data.currentStreakStartDate);
                                 projectedDate.setDate(projectedDate.getDate() + totalGoalDays);
                                 goalDateText = `Goal: ${totalGoalDays} days (ends approx. ${formatDate(projectedDate)})`;
                            } else {
                                 goalDateText = `Goal: ${totalGoalDays} days`;
                            }
                        } else if (data.goalDate) {
                            // This case handles when a date is set but there's no active streak to calculate from.
                            goalDateText = `Goal set for: ${formatDate(data.goalDate)}`;
                        }

                        
                        const progressPercentage = totalGoalDays > 0 ? Math.min((currentStreakDays / totalGoalDays) * 100, 100) : 0;
                        const remainingDays = totalGoalDays > 0 ? Math.max(0, totalGoalDays - currentStreakDays) : 0;
                        const progressTextContent = remainingDays > 0 ? `${Math.round(progressPercentage)}% (${remainingDays} ${remainingDays === 1 ? 'day' : 'days'} remaining)` : `${Math.round(progressPercentage)}% (Goal reached!)`;

                        document.getElementById('public-progress-bar').style.width = `${progressPercentage}%`;
                        document.getElementById('public-progress-text').textContent = progressTextContent;
                        document.getElementById('public-goal-date').textContent = goalDateText;
                    } else {
                        goalContainer.classList.add('hidden');
                    }
                }
            }

            function renderPublicView(data) {
                if (publicInterval) clearInterval(publicInterval);

                const defaultSettings = {
                    showCurrentStreak: true, showGoalProgress: true, showLongestStreak: true,
                    showAverageStreak: true, showAchievements: true, showHistory: true, showCalendar: true,
                    showTotalDaysYear: true, showHighestRank: true
                };
                const settings = Object.assign({}, defaultSettings, data.publicSettings || {});
                
                let viewHTML = `
                    <div class="header">
                        <div class="logo-and-title">
                            <img src="https://raw.githubusercontent.com/rynwynk/streaker-app/main/logo%20only.png" alt="Streaker Logo" class="logo">
                            <div><h2>Streaker</h2><p class="subtitle">Satisfied Through Denial</p></div>
                        </div>
                    </div>
                    <h2 class="stats-section-header" style="margin-top:0; margin-bottom: 0;">Public Profile for ${data.displayName}</h2>
                    <p class="public-level-display" style="text-align: center; font-size: 1.1em; margin-top: 5px; margin-bottom: 20px;">LEVEL: ${data.level || 1} - ${data.title || 'NOVICE'}</p>
                `;

                if (settings.showCurrentStreak) {
                    viewHTML += `
                        <div class="stat-card" style="margin-bottom: 30px;">
                            <h3>Current Streak</h3>
                            <div class="streak-counter-layout">
                                <div id="public-streak-digital-clock" class="digital-clock"><span id="public-streak-days">0</span><span class="unit-label">d</span><span id="public-streak-hours">00</span><span class="unit-label">h</span><span id="public-streak-minutes">00</span><span class="unit-label">m</span><span id="public-streak-seconds">00</span><span class="unit-label">s</span></div>
                                <pre id="public-daily-progress-bar" class="progress-bar-ascii"></pre>
                            </div>
                        </div>`;
                }

                if (settings.showGoalProgress) {
                    viewHTML += `
                        <div id="public-goal-progress-container" class="stat-card hidden" style="margin-bottom: 30px;">
                            <h3 style="font-size: 1.5em;">Goal Progress</h3><p class="subtitle" style="text-align: center; margin-bottom: 15px; font-size: 0.7em;">Tomorrow Never Cums</p>
                            <div class="progress-bar-container"><div id="public-progress-bar" class="progress-bar" style="width: 0%;"></div></div>
                            <p id="public-progress-text" class="progress-text" style="font-size: 1.2em; margin-top: 5px;">0%</p>
                            <p id="public-goal-date" style="font-size: 0.8em; margin-top: 5px; min-height: 1em;"></p>
                        </div>`;
                }
                
                let statsGridHTML = '';
                if (settings.showLongestStreak) {
                     statsGridHTML += `<div class="stat-card"><h3>Longest Streak</h3><p>${data.longestStreakDays} days</p></div>`;
                }
                if (settings.showAverageStreak) {
                     statsGridHTML += `<div class="stat-card"><h3>Average Streak</h3><p>${data.averageStreakDuration || '0 days'}</p></div>`;
                }
                if (settings.showTotalDaysYear) {
                     statsGridHTML += `<div class="stat-card"><h3>Total Days This Year</h3><p>${data.totalDaysThisYear || 0} days</p></div>`;
                }
                if (settings.showHighestRank && data.highestRankEver) {
                     statsGridHTML += `<div class="stat-card"><h3>Highest Rank Ever</h3><p>Lvl ${data.highestRankEver.level} - ${data.highestRankEver.title}</p></div>`;
                }
                if (statsGridHTML) {
                    viewHTML += `<div class="stats-grid">${statsGridHTML}</div>`;
                }

                if (settings.showAchievements) {
                     const achievementsHTML = data.unlockedAchievements && data.unlockedAchievements.length > 0
                    ? data.unlockedAchievements.map(ach => `<div class="badge-card"><div class="badge-icon unlocked">${ach.icon}</div><div class="badge-name">${ach.name}</div></div>`).join('')
                    : '<p style="text-align:center; font-style: italic; color: #aaa; grid-column: 1 / -1;">No achievements on current streak.</p>';
                    viewHTML += `
                        <h2 class="stats-section-header">Achievements</h2><div class="achievements-grid">${achievementsHTML}</div>`;
                }
                
                if (settings.showHistory) {
                    const streakHistoryLogs = (data.logs || []).filter(log => log.endDate).sort((a, b) => parseDate(b.startDate) - parseDate(a.startDate));
                    const streakHistoryHTML = streakHistoryLogs.length > 0
                    ? `<table><thead><tr><th>Start Date</th><th>End Date</th><th>Duration</th></tr></thead><tbody>
                        ${streakHistoryLogs.map(log => `<tr><td data-label="Start Date">${formatFullDate(parseDate(log.startDate))}</td><td data-label="End Date">${formatFullDate(parseDate(log.endDate))}</td><td data-label="Duration">${calculateDuration(log.startDate, log.endDate).formatted}</td></tr>`).join('')}
                        </tbody></table>`
                    : '<p style="text-align:center; font-style: italic; color: #aaa;">No completed streaks in history.</p>';
                    viewHTML += `<h2 class="stats-section-header">Streak History</h2><div id="public-streak-history-container">${streakHistoryHTML}</div>`;
                }

                if (settings.showCalendar) {
                    viewHTML += `
                        <div class="stats-section-header year-nav">
                            <button id="public-prev-year-btn" title="Previous Year">&lt;</button>
                            <h2 style="margin: 0;">Year in Review (<span id="public-current-year-label">${new Date().getFullYear()}</span>)</h2>
                            <button id="public-next-year-btn" title="Next Year">&gt;</button>
                        </div>
                        <div id="public-calendar-view-toggle" class="calendar-view-toggle button-group" style="justify-content: center; margin-top: 10px;">
                            <button data-view="1" class="view-toggle-btn">Month</button>
                            <button data-view="3" class="view-toggle-btn active">3 Months</button>
                            <button data-view="6" class="view-toggle-btn">6 Months</button>
                            <button data-view="12" class="view-toggle-btn">Year</button>
                        </div>
                        <div id="public-condensed-calendar-container"></div>
                        <p style="text-align: center; font-size: 0.8em; margin-top: 15px;">
                            <span style="display: inline-block; width: 12px; height: 12px; background-color: #27ff47;"></span> Active
                            <span style="display: inline-block; width: 12px; height: 12px; background-color: #ff8c00; margin-left: 15px;"></span> Ended
                            <span style="display: inline-block; width: 12px; height: 12px; background: linear-gradient(135deg, #ff8c00 49%, #27ff47 51%); margin-left: 15px;"></span> Ended & Restarted
                            <span style="margin-left: 15px;">🎯 Goal</span>
                        </p>`;
                }

                publicViewContainer.innerHTML = viewHTML;
                
                
                // --- NEW: Logic for public calendar ---
                let publicDisplayedYear = new Date().getFullYear();
                let publicCalendarMonthsToShow = 3;

                const redrawPublicCalendar = () => {
                    renderCondensedCalendar(
                        publicDisplayedYear,
                        data.logs || [],
                        data.goalDate,
                        '#public-condensed-calendar-container',
                        '#public-current-year-label',
                        publicCalendarMonthsToShow
                    );
                };
                
                const publicPrevYearBtn = document.getElementById('public-prev-year-btn');
                const publicNextYearBtn = document.getElementById('public-next-year-btn');
                const publicCalendarViewToggle = document.getElementById('public-calendar-view-toggle');

                if (publicPrevYearBtn) {
                    publicPrevYearBtn.addEventListener('click', () => {
                        publicDisplayedYear--;
                        redrawPublicCalendar();
                    });
                }
                if (publicNextYearBtn) {
                    publicNextYearBtn.addEventListener('click', () => {
                        if (publicDisplayedYear < new Date().getFullYear()) {
                            publicDisplayedYear++;
                            redrawPublicCalendar();
                        }
                    });
                }
                if (publicCalendarViewToggle) {
                    publicCalendarViewToggle.addEventListener('click', (e) => {
                        if (e.target.tagName === 'BUTTON') {
                            publicCalendarViewToggle.querySelector('.active').classList.remove('active');
                            e.target.classList.add('active');
                            publicCalendarMonthsToShow = parseInt(e.target.dataset.view, 10);
                            redrawPublicCalendar();
                        }
                    });
                }

                // Initial render
                if (settings.showCalendar) {
                    redrawPublicCalendar();
                }

                const updateElements = () => updatePublicDynamicElements(data);
                
                if (data.currentStreakStartDate) {
                    updateElements();
                    publicInterval = setInterval(updateElements, 1000);
                } else {
                    updateElements();
                }
            }

            function populateRankSelector() {
                rankProjectionSelect.innerHTML = '';
                LEVEL_CONFIG.forEach(level => {
                    // Start from the next level up from Novice
                    if (level.level > 1) { 
                        const option = document.createElement('option');
                        option.value = level.level;
                        option.textContent = `Lvl ${level.level}: ${level.title}`;
                        rankProjectionSelect.appendChild(option);
                    }
                });
                // Set a default selection
                if (rankProjectionSelect.options.length > 0) {
                    rankProjectionSelect.selectedIndex = 0;
                }
            }

            function getTodayDateString() {
                const today = new Date();
                const year = today.getFullYear();
                const month = String(today.getMonth() + 1).padStart(2, '0');
                const day = String(today.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            }

            function renderDailyCheckin() {
                const todayString = getTodayDateString();
                const todayDate = new Date(todayString + 'T00:00:00');
                dailyCheckinHeader.textContent = `Daily Check-in for ${formatDate(todayDate)}`;

                const todaysCheckinDoc = userCheckins.find(doc => doc.id === todayString);
                
                if (todaysCheckinDoc) {
                    const data = todaysCheckinDoc.data();
                    checkinLocked.checked = data.locked || false;
                    checkinSex.checked = data.sex || false;
                    checkinEdged.checked = data.edged || false;
                } else {
                    checkinLocked.checked = false;
                    checkinSex.checked = false;
                    checkinEdged.checked = false;
                }
            }

            function startApp() {
                // Check for public profile username in URL hash first
                let publicUsername = null;
                if (window.location.hash) {
                    publicUsername = window.location.hash.substring(1); // Remove the '#'
                } else {
                    // Fallback to old query parameter for backward compatibility
                    const urlParams = new URLSearchParams(window.location.search);
                    publicUsername = urlParams.get('username');
                }
                
                onAuthStateChanged(auth, user => {
                    loadingContainer.classList.add('hidden');
                    if (publicUsername) {
                        publicViewContainer.classList.remove('hidden');
                        const usernameRef = doc(db, 'usernames', publicUsername.toLowerCase());
                        getDoc(usernameRef)
                            .then(usernameDoc => {
                                if (usernameDoc.exists()) {
                                    const uid = usernameDoc.data().uid;
                                    const profileRef = doc(db, 'publicProfiles', uid);
                                    onSnapshot(profileRef, profileDoc => {
                                        if (profileDoc.exists()) {
                                            renderPublicView(profileDoc.data());
                                        } else {
                                            publicViewContainer.innerHTML = `<p style="text-align:center;">Could not load profile for "${publicUsername}". The owner may need to refresh their public data from the Profile page.</p>`;
                                        }
                                    }, error => {
                                        console.error("Error with public profile listener:", error);
                                        publicViewContainer.innerHTML = `<p style="text-align:center;">An error occurred while loading the profile.</p>`;
                                    });
                                } else {
                                    publicViewContainer.innerHTML = `<p style="text-align:center;">Could not load profile for "${publicUsername}". This user does not exist.</p>`;
                                }
                            })
                            .catch(error => {
                                console.error("Error loading public profile:", error);
                                publicViewContainer.innerHTML = `<p style="text-align:center;">Could not load profile for "${publicUsername}". It may not exist or may not be public.</p>`;
                            });
                    } else if (user) {
                        initializeAppForUser(user);
                    } else {
                        showLoginScreen();
                    }
                });
            }
            
            // --- NEW: Calendar Tooltip Logic ---

            function showCalendarTooltip(targetElement, dateString) {
                const date = new Date(dateString + 'T00:00:00'); // Ensure it's treated as local time
                const dayStart = date;
                const dayEnd = new Date(dayStart);
                dayEnd.setHours(23, 59, 59, 999);

                // Calculate the start of the previous day for XP comparison
                const prevDayEnd = new Date(dayStart);
                prevDayEnd.setDate(prevDayEnd.getDate() - 1);
                prevDayEnd.setHours(23, 59, 59, 999);

                let content = '<ul>';
                let hasContent = false;

                // 1. Find streak status for the day
                const activeStreakOnDay = userLogs.find(doc => {
                    const log = doc.data();
                    const start = parseDate(log.startDate);
                    const end = log.endDate ? parseDate(log.endDate) : new Date(); // Treat ongoing as up to now
                    return dayStart >= start && dayStart <= end;
                });

                if (activeStreakOnDay) {
                    const duration = calculateDuration(activeStreakOnDay.data().startDate, dayStart);
                    content += `<li>> Streak Day: ${duration.days + 1}</li>`;
                    hasContent = true;
                }

                // 2. Check for start/end events
                if(userLogs.some(doc => parseDate(doc.data().startDate).toDateString() === dayStart.toDateString())) {
                    content += `<li>> Streak Started</li>`;
                    hasContent = true;
                }
                if(userLogs.some(doc => doc.data().endDate && parseDate(doc.data().endDate).toDateString() === dayStart.toDateString())) {
                    content += `<li>> Streak Ended</li>`;
                    hasContent = true;
                }

                // 3. Find achievements earned on this day
                if (activeStreakOnDay) {
                    const streakData = activeStreakOnDay.data();
                    const streakStart = parseDate(streakData.startDate);
                    // Duration from start TO the clicked day. +1 because day 1 is 0 days duration.
                    const durationOnDay = calculateDuration(streakStart, dayStart).days + 1; 

                    ACHIEVEMENTS_CONFIG.forEach(ach => {
                        // Check for day-based achievements
                        if (ach.days && durationOnDay === ach.days) {
                            content += `<li>> Unlocked: ${ach.name}</li>`;
                            hasContent = true;
                        }
                        // Check for goal-based achievement
                        if (ach.type === 'goal' && streakData.goal) {
                            const goalAchievedDate = new Date(streakStart);
                            goalAchievedDate.setDate(goalAchievedDate.getDate() + streakData.goal);
                            if (goalAchievedDate.toDateString() === dayStart.toDateString()) {
                               content += `<li>> Unlocked: ${ach.name}</li>`;
                               hasContent = true;
                            }
                        }
                    });
                    
                    // Find level-up achievements earned on this day
                    const xpAtDayStart = calculateXpUpToDate(activeStreakOnDay, allJournalEntries, prevDayEnd);
                    const xpAtDayEnd = calculateXpUpToDate(activeStreakOnDay, allJournalEntries, dayEnd);
                    
                    const levelDataStart = calculateLevelFromXp(xpAtDayStart);
                    const levelDataEnd = calculateLevelFromXp(xpAtDayEnd);

                    if (levelDataEnd.level > levelDataStart.level) {
                        for (let i = levelDataStart.level + 1; i <= levelDataEnd.level; i++) {
                            const levelBadge = LEVEL_BADGES_CONFIG.find(b => b.level === i);
                            if (levelBadge) {
                                content += `<li>> Unlocked: ${levelBadge.name}</li>`;
                                hasContent = true;
                            }
                        }
                    }
                }

                // 4. Find check-ins
                const checkinOnDay = userCheckins.find(doc => doc.id === dateString);
                if (checkinOnDay) {
                    const data = checkinOnDay.data();
                    const activities = [];
                    if (data.locked) activities.push('Locked');
                    if (data.sex) activities.push('Sex');
                    if (data.edged) activities.push('Edged');
                    if(activities.length > 0) {
                        content += `<li>> Check-in: ${activities.join(', ')}</li>`;
                        hasContent = true;
                    }
                }

                content += '</ul>';

                if (!hasContent) {
                    hideCalendarTooltip();
                    return;
                }

                calendarTooltip.querySelector('.tooltip-header').textContent = `LOG: ${formatDate(dayStart)}`;
                calendarTooltip.querySelector('.tooltip-body').innerHTML = content;

                const rect = targetElement.getBoundingClientRect();
                const containerRect = logbookContainer.getBoundingClientRect();

                // Position tooltip relative to the main container
                calendarTooltip.style.left = `${rect.left - containerRect.left + rect.width / 2}px`;
                calendarTooltip.style.top = `${rect.top - containerRect.top - 10}px`; // 10px above the cell
                calendarTooltip.style.transform = 'translateX(-50%) translateY(-100%)';

                calendarTooltip.classList.remove('hidden');
            }

            function hideCalendarTooltip() {
                calendarTooltip.classList.add('hidden');
            }
            
            // --- UPDATED: Main App Event Listeners to include tooltip logic ---

            if(logbookContainer) {
                 logbookContainer.addEventListener('click', (e) => {
                     const dayCell = e.target.closest('.month-grid-day.has-data');
                     if (dayCell) {
                          showCalendarTooltip(dayCell, dayCell.dataset.date);
                     } else if (!e.target.closest('#calendar-tooltip')) {
                          hideCalendarTooltip();
                     }
                 });
            }

            // Listen for window resize to redraw the HUD
            window.addEventListener('resize', () => {
                if (auth.currentUser) {
                    renderHud();
                }
            });

            startApp();
        });
    </script>
</body>
</html>

