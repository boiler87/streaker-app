<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Streaker</title>
    <!-- FAVICON LINK -->
    <link rel="icon" type="image/png" href="https://raw.githubusercontent.com/rynwynk/streaker-app/main/logo%20only.png">
    <!-- GOOGLE FONTS LINK -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        @font-face {
            font-family: 'AppleIIe';
            src: url('https://daniellopes.com.br/apple-ii/AppleIIe.ttf') format('truetype');
        }

        body {
            font-family: 'AppleIIe', monospace;
            background-color: #000;
            color: #27ff47;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
        }
        .container {
            background-color: #000;
            padding: 30px;
            border: 2px solid #27ff47;
            box-shadow: 0 0 10px #27ff47;
            max-width: 800px;
            width: 100%;
        }
        .hidden {
            display: none !important; /* The definitive fix */
        }
        
        .logo-and-title {
            display: flex;
            align-items: center;
            gap: 15px; /* Increased gap */
        }
        .logo-and-title div {
           display: flex;
           flex-direction: column;
        }
        .logo-and-title h2 {
            font-family: 'Press Start 2P', cursive;
            margin-bottom: 5px; /* Space between title and subtitle */
        }
        .subtitle {
            font-size: 0.8em;
            color: #27ff47;
            margin: 0;
        }

        h2 {
            color: #27ff47;
            text-align: left;
            margin: 0;
            font-size: 2em;
        }
        .logo {
            height: 60px; /* Adjusted height */
            width: auto;
            image-rendering: pixelated;
        }
        .header-container {
            margin-bottom: 20px;
        }
        form {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        input[type="email"],
        input[type="password"],
        input[type="date"],
        input[type="number"],
        input[type="search"],
        input[type="text"] {
            padding: 12px;
            border: 2px solid #27ff47;
            background-color: #000;
            color: #27ff47;
            flex-grow: 1;
            font-size: 16px;
            font-family: 'AppleIIe', monospace;
        }
        textarea {
            padding: 12px;
            border: 2px solid #27ff47;
            background-color: #000;
            color: #27ff47;
            flex-basis: 100%;
            min-height: 80px;
            resize: vertical;
            font-family: 'AppleIIe', monospace;
            font-size: 16px;
        }
        button {
            padding: 12px 20px;
            border: 2px solid #27ff47;
            background-color: #27ff47;
            color: #000;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        button:hover {
            background-color: #1aff32;
        }
        .button-group {
            display: flex;
            gap: 10px;
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .error-message {
            color: #ff0000;
            text-align: center;
            margin-top: 10px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            border: 2px solid #27ff47;
            margin-top: 20px;
        }
        th, td {
            padding: 15px;
            text-align: left;
            border: 1px solid #27ff47;
        }
        th {
            background-color: #111;
            color: #27ff47;
            font-weight: 600;
            cursor: pointer;
        }
        th:hover {
            background-color: #333;
        }
        th .sort-icon {
            margin-left: 5px;
            font-size: 0.8em;
        }
        tr:hover {
            background-color: #001;
        }
        .delete-btn {
            background-color: #ff0000;
            color: #000;
        }
        .delete-btn:hover {
            background-color: #cc0000;
        }
        
        .edit-btn {
            background-color: #27ff47;
            color: #000;
            font-size: 14px;
            padding: 8px 12px;
            margin-right: 5px;
        }
        .edit-btn:hover {
            background-color: #1aff32;
        }

        .save-btn {
            background-color: #27ff47;
            color: #000;
        }
        .save-btn:hover {
            background-color: #1aff32;
        }
        .cancel-btn {
            background-color: #ff0000;
            color: #000;
        }
        .cancel-btn:hover {
            background-color: #cc0000;
        }

        .end-streak-btn {
            background-color: #27ff47;
            color: #000;
            font-size: 14px;
            padding: 8px 12px;
        }
        .end-streak-btn:hover {
            background-color: #1aff32;
        }

        .nav-buttons {
            display: flex;
            gap: 10px;
        }
        .logout-btn {
            background-color: #ff0000;
            width: 100%;
            margin-top: 10px; /* Add margin for spacing */
        }
        .logout-btn:hover {
            background-color: #cc0000;
        }
        
        /* NEW: Profile Dropdown Styles */
        .profile-dropdown-container {
            position: relative;
        }
        .profile-btn {
            font-size: 1.5em;
            background: none;
            border: 2px solid #27ff47;
            color: #27ff47;
            padding: 5px 10px;
            cursor: pointer;
            line-height: 1;
        }
        .profile-btn:hover {
            background-color: #111;
        }
        .profile-dropdown {
            position: absolute;
            top: 120%;
            right: 0;
            background-color: #000;
            border: 2px solid #27ff47;
            box-shadow: 0 0 10px #27ff47;
            padding: 15px;
            z-index: 100;
            min-width: 250px;
        }
        #user-profile-display {
            margin: 0 0 10px 0;
            word-break: break-all;
            text-align: center;
            padding-bottom: 10px;
            border-bottom: 1px solid #27ff47;
            font-weight: bold;
            font-size: 1.2em;
        }

        /* NEW: Username Change Styles */
        .username-change-section {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #27ff47;
        }
        #new-username-input {
            flex-grow: 1;
            font-size: 0.9em;
            padding: 8px;
        }
        #save-username-btn {
            padding: 8px 12px;
            font-size: 0.9em;
        }
        #username-status {
            flex-basis: 100%;
            text-align: left;
            margin: 5px 0 0 0;
            font-size: 0.8em;
        }

        <!-- NEW: Public Sharing Styles -->
        .sharing-section {
            border-top: 1px solid #27ff47;
            padding-top: 15px;
            margin-top: 15px;
            padding-left: 5px;  /* Inset content slightly */
            padding-right: 5px; /* Inset content slightly */
        }
        .toggle-switch {
            display: flex;
            align-items: center;
            /* justify-content: space-between; */ /* REMOVED: This pushed the slider too far right */
            gap: 15px; /* ADDED: This groups the label and slider together on the left */
            margin-bottom: 10px;
        }
        .toggle-switch label {
            cursor: pointer;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            width: 40px;
            height: 20px;
            background-color: #333;
            border: 1px solid #27ff47;
            cursor: pointer;
            position: relative;
            transition: background-color 0.2s;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 2px;
            bottom: 2px;
            background-color: #27ff47;
            transition: .4s;
        }
        input:checked + .slider {
            background-color: #111;
        }
        input:checked + .slider:before {
            transform: translateX(20px);
        }
        #public-link-container {
            margin-top: 10px;
        }
        #public-link-display {
            width: 100%;
            padding: 5px;
            background: #111;
            border: 1px solid #27ff47;
            color: #27ff47;
            font-size: 0.8em;
            word-break: break-all;
        }
        #refresh-public-data-btn {
            width: 100%;
            margin-top: 10px;
            font-size: 0.9em;
            padding: 8px;
        }


        .view-more-container {
            text-align: center;
            margin-top: 20px;
        }
        
        .stats-section-header {
            margin-top: 40px;
            text-align: center;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
            text-align: center;
        }
        
        .stat-card {
            background-color: #111;
            padding: 20px;
            border: 2px solid #27ff47;
        }
        
        .stat-card h3 {
            margin: 0 0 10px 0;
            color: #27ff47;
        }
        
        .stat-card p {
            font-size: 2em;
            font-weight: bold;
            color: #27ff47;
        }

        /* Progress bar styles */
        .progress-bar-container {
            width: 100%;
            height: 20px;
            border: 1px solid #27ff47;
            background-color: #000;
            margin-top: 10px;
        }
        .progress-bar {
            height: 100%;
            background-color: #27ff47;
            transition: width 0.5s ease-in-out;
        }
        .progress-text {
            font-size: 1.5em;
            margin-top: 10px;
        }
        
        /* Tab navigation */
        .tab-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        .tab-buttons button {
            background-color: #111;
            color: #27ff47;
            border: 2px solid #27ff47;
        }
        .tab-buttons button.active {
            background-color: #27ff47;
            color: #000;
        }

        /* Achievements styles */
        .achievements-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin-top: 20px;
            text-align: center;
        }
        .badge-card {
            background-color: #111;
            padding: 20px;
            border: 2px solid #27ff47;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .badge-icon {
            font-size: 3em;
            color: #444; /* Locked color */
            transition: color 0.5s ease;
        }
        .badge-icon.unlocked {
            color: #27ff47;
            text-shadow: 0 0 10px #27ff47;
        }
        .badge-name {
            margin-top: 10px;
            font-weight: bold;
        }

        /* Journal styles */
        .journal-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
            border: 2px solid #27ff47;
            padding: 15px;
        }
        .journal-entry {
            background-color: #111;
            border: 2px solid #27ff47;
            padding: 20px;
            margin-bottom: 20px;
        }
        .journal-entry-date {
            font-weight: bold;
            margin-bottom: 10px;
        }
        .journal-entry-text {
            white-space: pre-wrap;
            line-height: 1.5;
        }
        .journal-entry-actions {
            margin-top: 15px;
            display: flex;
            gap: 10px;
        }

        /* 3-Month Calendar Styles */
        .calendar-container {
            margin-top: 40px;
            border: 2px solid #27ff47;
            padding: 20px;
        }
        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .calendar-header button {
            padding: 5px 10px;
            font-size: 1.2em;
        }
        #calendar-main-month-year {
            font-size: 1.5em;
            font-weight: bold;
        }
        .three-month-view {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
        }
        .calendar-month-year {
            text-align: center;
            font-size: 1.2em;
            margin-bottom: 15px;
        }
        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 5px;
        }
        .calendar-day-name {
            text-align: center;
            font-weight: bold;
            margin-bottom: 10px;
        }
        .calendar-day {
            border: 1px solid #27ff47;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #111;
            font-size: 0.9em;
            cursor: pointer;
            position: relative;
        }
        .journal-icon {
            position: absolute;
            top: 2px;
            right: 2px;
            font-size: 0.7em;
            line-height: 1;
        }
        .calendar-day:hover {
            background-color: #333;
        }
        .calendar-day.active {
            background-color: #27ff47;
            color: #000;
        }
        .calendar-day.end-day {
            background-color: #ff8c00; /* Orange for end of streak */
            color: #000;
        }
        .calendar-day.today {
            box-shadow: 0 0 10px #ffff00;
        }
        .calendar-day.goal-day {
            background-color: #ffd700; /* Gold for goal day */
            color: #000;
            border: 2px solid #ffff00;
            font-weight: bold;
        }
        .calendar-day.empty {
            background-color: transparent;
            border: 1px solid #111;
            cursor: default;
        }
        .calendar-day.empty:hover {
            background-color: transparent;
        }

        /* NEW: Today Check-in Styles */
        #today-checkin-container {
            border: 2px solid #27ff47;
            padding: 20px;
            text-align: center;
            margin-bottom: 40px;
        }
        #today-checkin-container button {
            margin-top: 10px;
            width: 80%;
            padding: 15px;
            font-size: 1.2em;
        }

        /* NEW: Journal Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: #000;
            border: 2px solid #27ff47;
            box-shadow: 0 0 15px #27ff47;
            padding: 30px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .modal-header h3 {
            margin: 0;
            font-size: 1.5em;
        }
        .modal-close-btn {
            background: none;
            border: none;
            color: #27ff47;
            font-size: 2em;
            cursor: pointer;
        }

        /* NEW: Streak Chart Styles */
        #streak-chart-container {
            margin-top: 40px;
            border: 2px solid #27ff47;
            padding: 20px;
            height: 300px;
            width: 100%;
            box-sizing: border-box;
        }
        #streak-chart-container svg {
            width: 100%;
            height: 100%;
        }
        .chart-bar {
            fill: #27ff47;
            transition: fill 0.2s;
        }
        .chart-bar:hover {
            fill: #1aff32;
        }
        .chart-label {
            fill: #27ff47;
            font-family: 'AppleIIe', monospace;
            text-anchor: middle;
        }
        
        #auth-form .form-row {
            flex-basis: 100%;
        }

        /* Responsive design for smaller screens */
        @media (max-width: 800px) { /* Changed breakpoint for 3-month view */
             .three-month-view {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 600px) {
            body {
                padding: 10px;
            }
            .container {
                padding: 20px;
            }
            form {
                flex-direction: column;
            }
            .button-group {
                flex-direction: column;
            }
            table, thead, tbody, th, td, tr {
                display: block;
            }
            thead tr {
                position: absolute;
                top: -9999px;
                left: -9999px;
            }
            tr {
                border: 1px solid #27ff47;
                margin-bottom: 15px;
            }
            td {
                border: none;
                border-bottom: 1px solid #27ff47;
                position: relative;
                padding-left: 50%;
                text-align: right;
            }
            td:before {
                position: absolute;
                top: 0;
                left: 6px;
                width: 45%;
                padding-right: 10px;
                white-space: nowrap;
                content: attr(data-label);
                text-align: left;
                font-weight: bold;
                color: #27ff47;
            }
            td:last-child {
                border-bottom: 0;
            }
            .delete-btn {
                width: 100%;
                margin-top: 10px;
            }
            /* Add data-label to table cells for mobile view */
            .start-date-cell:before { content: "Start Date"; }
            .end-date-cell:before { content: "End Date"; }
            .duration-cell:before { content: "Duration"; }
            .actions-cell:before { content: "Actions"; }

            .journal-controls {
                flex-direction: column;
            }
            .calendar-day {
                height: 40px;
                font-size: 0.8em;
            }
        }
    </style>
</head>
<body>

    <!-- NEW: Loading Screen -->
    <div id="loading-container" class="container" style="text-align: center; padding: 50px;">
        <p>LOADING STREAKER...</p>
    </div>
    
    <!-- NEW: Public View Container -->
    <div id="public-view-container" class="container hidden">
        <!-- Public, read-only content will be rendered here by JavaScript -->
    </div>


    <!-- Login/Signup Section -->
    <div id="auth-container" class="container hidden">
        <div class="logo-and-title" style="justify-content: center; margin-bottom: 20px;">
            <img src="https://raw.githubusercontent.com/rynwynk/streaker-app/main/logo%20only.png" alt="Streaker Logo" class="logo">
            <div>
                <h2>Streaker</h2>
                <p class="subtitle">Tomorrow Never Cums</p>
            </div>
        </div>
        <form id="auth-form">
            <div class="form-row hidden">
                <input type="text" id="username-input" placeholder="Username" autocomplete="username">
            </div>
             <div class="form-row">
                <input type="email" id="email-input" placeholder="Email" required autocomplete="email">
             </div>
             <div class="form-row">
                <input type="password" id="password-input" placeholder="Password" required autocomplete="current-password">
             </div>
            <div class="button-group">
                <button type="submit" id="main-auth-btn">Log In</button>
                <button type="button" id="toggle-auth-mode-btn">Sign Up</button>
            </div>
        </form>
        <p id="auth-error" class="error-message"></p>
    </div>

    <!-- Main App Section -->
    <div id="main-app-container" class="container hidden">
        <div class="header">
            <div class="logo-and-title">
                <img src="https://raw.githubusercontent.com/rynwynk/streaker-app/main/logo%20only.png" alt="Streaker Logo" class="logo">
                <div>
                    <h2>Streaker</h2>
                    <p class="subtitle">Tomorrow Never Cums</p>
                </div>
            </div>
            <div class="nav-buttons">
                <!-- NEW: Profile Dropdown -->
                <div class="profile-dropdown-container">
                    <button id="profile-btn" class="profile-btn">üë§</button>
                    <div id="profile-dropdown" class="profile-dropdown hidden">
                        <p id="user-profile-display"></p>

                        <!-- NEW: Username Change Section -->
                        <div class="username-change-section">
                            <input type="text" id="new-username-input" placeholder="New username">
                            <button id="save-username-btn">Save</button>
                            <p id="username-status" class="error-message"></p>
                        </div>
                        
                        <button id="new-logout-btn" class="logout-btn">Log Out</button>

                        <div class="sharing-section">
                            <div class="toggle-switch">
                                <label for="public-profile-toggle">Enable Public Profile</label>
                                <label class="slider-container">
                                    <input type="checkbox" id="public-profile-toggle">
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div id="public-link-container" class="hidden">
                                <input type="text" id="public-link-display" readonly>
                                <p style="font-size: 0.7em; text-align: center; margin: 5px 0 0 0;">(This link is permanent and will not change)</p>
                                <button id="refresh-public-data-btn">Refresh Public Data</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="tab-buttons">
            <button id="dashboard-tab-btn" class="active">Dashboard</button>
            <button id="logbook-tab-btn">Logbook</button>
            <button id="achievements-tab-btn">Achievements</button>
            <button id="journal-tab-btn">Journal</button>
            <button id="about-tab-btn">About</button>
        </div>

        <!-- Dashboard Container -->
        <div id="dashboard-container">
            <!-- NEW: Today Check-in -->
            <div id="today-checkin-container"></div>
            
            <div class="stats-grid">
                <div class="stat-card">
                    <h3>Current Streak Duration</h3>
                    <p id="current-streak-duration-stat">0d 0h 0m</p>
                </div>
            </div>

            <!-- Goal Progress Section -->
            <div id="goal-progress-container" style="margin-top: 40px;">
                <h2 class="stats-section-header">Goal Progress</h2>
                 <p id="goal-date" style="text-align: center; margin-top: 10px;"></p>
                <div style="display: flex; gap: 10px; align-items: center; justify-content: center; flex-wrap: wrap; margin-bottom: 20px;">
                    <label for="goal-input" style="white-space: nowrap;">Goal (Days):</label>
                    <input type="number" id="goal-input" placeholder="e.g., 30" style="flex-grow: 1; min-width: 80px;">
                    <span style="font-style: italic;">or</span>
                    <label for="goal-date-input" style="white-space: nowrap;">Goal Date:</label>
                    <input type="date" id="goal-date-input" style="flex-grow: 1; min-width: 120px;">
                </div>
                <div id="progress-bar-container" class="progress-bar-container">
                    <div id="progress-bar" class="progress-bar"></div>
                </div>
                <p id="progress-text" class="progress-text">0%</p>
            </div>
            
            <!-- 3-Month Calendar -->
            <h2 class="stats-section-header">Streak Calendar</h2>
            <div class="calendar-container">
                <div class="calendar-header">
                    <button id="prev-month-btn">&lt;</button>
                    <span id="calendar-main-month-year"></span>
                    <button id="next-month-btn">&gt;</button>
                </div>
                <div id="three-month-view" class="three-month-view">
                    <!-- Month 1 -->
                    <div class="single-month-container">
                        <h3 class="calendar-month-year" id="calendar-month-year-0"></h3>
                        <div class="calendar-grid" id="calendar-day-names-0"></div>
                        <div class="calendar-grid" id="calendar-grid-0"></div>
                    </div>
                    <!-- Month 2 (Current) -->
                    <div class="single-month-container">
                        <h3 class="calendar-month-year" id="calendar-month-year-1"></h3>
                        <div class="calendar-grid" id="calendar-day-names-1"></div>
                        <div class="calendar-grid" id="calendar-grid-1"></div>
                    </div>
                    <!-- Month 3 -->
                    <div class="single-month-container">
                        <h3 class="calendar-month-year" id="calendar-month-year-2"></h3>
                        <div class="calendar-grid" id="calendar-day-names-2"></div>
                        <div class="calendar-grid" id="calendar-grid-2"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Logbook Container -->
        <div id="logbook-container" class="hidden">
            <!-- Stats Section -->
            <div id="stats-container">
                <h2 class="stats-section-header">All-Time Stats</h2>
                <div class="stats-grid">
                    <div class="stat-card">
                        <h3>Total Days This Year</h3>
                        <p id="total-days-year-stat">0 days</p>
                    </div>
                    <div class="stat-card">
                        <h3>Longest Streak</h3>
                        <p id="longest-streak-stat">0 days</p>
                    </div>
                    <div class="stat-card">
                        <h3>Average Duration</h3>
                        <p id="avg-duration-stat">0d 0h</p>
                    </div>
                </div>
                 <!-- NEW: Streak Chart -->
                <h2 class="stats-section-header">Recent Streak History</h2>
                <div id="streak-chart-container"></div>
            </div>
            
            <h2 class="stats-section-header" style="margin-top: 40px; text-align: left;">Log Book</h2>
            <div style="display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 20px; align-items: center;">
                <form id="entry-form" style="flex-grow: 1; margin-bottom: 0; display: flex; flex-wrap: wrap; gap: 10px;">
                    <input type="date" id="start-date-input" required style="flex-grow: 1;">
                    <input type="date" id="end-date-input" style="flex-grow: 1;">
                    <button type="submit">Add Entry</button>
                </form>
                <button id="export-btn" style="height: fit-content;">Export to CSV</button>
            </div>
            
            <table id="log-table">
                <thead>
                    <tr>
                        <th data-sort-key="startDate">Start Date <span class="sort-icon"></span></th>
                        <th data-sort-key="endDate">End Date <span class="sort-icon"></span></th>
                        <th data-sort-key="duration">Duration <span class="sort-icon"></span></th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Log entries will be inserted here by JavaScript -->
                </tbody>
            </table>
            <div id="view-more-container" class="view-more-container hidden">
                <button id="view-more-btn">View More</button>
            </div>
        </div>

        <!-- Achievements Container -->
        <div id="achievements-container" class="hidden">
            <h2 class="stats-section-header">My Achievements</h2>
            <div id="my-achievements-grid" class="achievements-grid">
                <!-- Earned badges will be dynamically inserted here -->
            </div>

            <h2 class="stats-section-header">Available Badges</h2>
            <div id="available-badges-grid" class="achievements-grid">
                <!-- All badges will be dynamically inserted here -->
            </div>
        </div>

        <!-- Journal Container -->
        <div id="journal-container" class="hidden">
            <h2 class="stats-section-header" style="text-align: left;">Journal</h2>
            <form id="journal-form">
                <textarea id="journal-input" placeholder="Write your journal entry here..."></textarea>
                <button type="submit">Submit Entry</button>
            </form>

            <div class="journal-controls">
                <input type="search" id="journal-search-input" placeholder="Search entries...">
                <input type="date" id="journal-filter-start-date" title="Filter start date">
                <input type="date" id="journal-filter-end-date" title="Filter end date">
                <button id="journal-filter-clear-btn">Clear</button>
            </div>

            <div id="journal-entries-container">
                <!-- Journal entries will be inserted here -->
            </div>
        </div>

        <!-- NEW: About Container -->
        <div id="about-container" class="hidden" style="line-height: 1.8;">
            <h2 class="stats-section-header" style="text-align: left;">About Streaker</h2>
            <p>
                Welcome to Streaker, your digital companion for building unbreakable habits. This app is built on a simple philosophy: consistency is the key to achieving any goal. The retro interface is designed to be simple and distraction-free, helping you focus on what truly matters: showing up every single day.
            </p>
            <p>
                As the motto says, "Tomorrow Never Cums." The only time to act is now.
            </p>

            <h3 class="stats-section-header" style="text-align: left; margin-top: 30px;">How It Works</h3>
            
            <h4>The Dashboard</h4>
            <p>
                This is your command center. It gives you an at-a-glance view of your progress and motivation for the day.
            </p>
            <ul>
                <li><strong>Today's Check-in:</strong> The most important button in the app. Click it once a day to confirm you've maintained your streak.</li>
                <li><strong>Goal Progress:</strong> Set a goal by either a number of days or a target date. The progress bar will show you how close you are to achieving it.</li>
                <li><strong>Streak Calendar:</strong> This calendar visualizes your entire year. Green days are active streak days, orange days mark the end of a streak, and a yellow day with a target icon (üéØ) is your goal. Days with a memo icon (üìù) have journal entries‚Äîclick them to see what you wrote!</li>
            </ul>

            <h4>The Logbook</h4>
            <p>
                This is your official record. Here you can add, manage, and analyze your streaks.
            </p>
            <ul>
                <li><strong>Add an Entry:</strong> Select a start date and an optional end date to log a new streak. You can only have one active (no end date) streak at a time.</li>
                <li><strong>All-Time Stats:</strong> See your longest streak, average streak duration, and total days streaked this year.</li>
                <li><strong>Recent Streak History:</strong> The bar chart provides a quick visual of your last 10 completed streaks, helping you see patterns in your performance.</li>
                <li><strong>Export to CSV:</strong> Download all your log data for your personal records.</li>
            </ul>

            <h4>Achievements</h4>
            <p>
                Earn badges as your current streak grows longer. This page shows you the badges you've earned on this run and which ones are coming up next. Your achievements reset when a streak ends, giving you a fresh goal for the next one.
            </p>
            
            <h4>The Journal</h4>
            <p>
                Track your thoughts, feelings, and progress. Write down your successes and your struggles. You can search your entries by keyword or filter them by date to find exactly what you're looking for.
            </p>
        </div>
    </div>
    
    <!-- NEW: Journal Modal -->
    <div id="journal-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="modal-title"></h3>
                <button id="modal-close-btn" class="modal-close-btn">&times;</button>
            </div>
            <div id="modal-body"></div>
        </div>
    </div>


    <!-- Firebase SDK Scripts -->
    <script src="https://www.gstatic.com/firebasejs/8.6.8/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.6.8/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.6.8/firebase-firestore.js"></script>

    <script>
        // Your Firebase project's configuration object
        const firebaseConfig = {
          apiKey: "AIzaSyCxPG9RfxihL-Rfhu7fPSP95QDld6QMuik",
          authDomain: "streaker-1658d.firebaseapp.com",
          projectId: "streaker-1658d",
          storageBucket: "streaker-1658d.appspot.com",
          messagingSenderId: "12701860115",
          appId: "1:12701860115:web:0d4dcba33fd234df97dae6",
          measurementId: "G-XKE790N7ZL"
        };
        
        // This log is for debugging purposes.
        console.log("Firebase config:", firebaseConfig);

        // Initialize Firebase
        if (firebaseConfig.apiKey) {
            try {
                firebase.initializeApp(firebaseConfig);
                console.log("Firebase initialized successfully.");
            } catch (error)
                {
                console.error("Firebase initialization failed:", error.message);
                console.warn("This may be because you have not created a Firestore database for your project. Please follow the instructions in the Firebase console.");
            }
        } else {
            console.error("Firebase config is missing or invalid. Please ensure you have pasted your config correctly.");
        }
        
        const auth = firebase.auth();
        const db = firebase.firestore();

        // DOM elements
        const authContainer = document.getElementById('auth-container');
        const mainAppContainer = document.getElementById('main-app-container');
        const authForm = document.getElementById('auth-form');
        const toggleAuthModeBtn = document.getElementById('toggle-auth-mode-btn');
        const mainAuthBtn = document.getElementById('main-auth-btn');
        const usernameInput = document.getElementById('username-input');
        const emailInput = document.getElementById('email-input');
        const passwordInput = document.getElementById('password-input');

        const newLogoutBtn = document.getElementById('new-logout-btn');
        const exportBtn = document.getElementById('export-btn');
        
        const dashboardTabBtn = document.getElementById('dashboard-tab-btn');
        const logbookTabBtn = document.getElementById('logbook-tab-btn');
        const achievementsTabBtn = document.getElementById('achievements-tab-btn');
        const journalTabBtn = document.getElementById('journal-tab-btn');
        const aboutTabBtn = document.getElementById('about-tab-btn');

        const dashboardContainer = document.getElementById('dashboard-container');
        const logbookContainer = document.getElementById('logbook-container');
        const achievementsContainer = document.getElementById('achievements-container');
        const journalContainer = document.getElementById('journal-container');
        const aboutContainer = document.getElementById('about-container');
        
        // NEW: Today Check-in elements
        const todayCheckinContainer = document.getElementById('today-checkin-container');

        // Logbook elements
        const entryForm = document.getElementById('entry-form');
        const logTableBody = document.querySelector('#log-table tbody');
        const authError = document.getElementById('auth-error');
        const startDateInput = document.getElementById('start-date-input');
        const endDateInput = document.getElementById('end-date-input');
        const tableHeaders = document.querySelectorAll('#log-table th[data-sort-key]');
        const viewMoreBtn = document.getElementById('view-more-btn');
        const viewMoreContainer = document.getElementById('view-more-container');
        const longestStreakStat = document.getElementById('longest-streak-stat');
        const currentStreakDurationStat = document.getElementById('current-streak-duration-stat');
        const avgDurationStat = document.getElementById('avg-duration-stat');
        const totalDaysYearStat = document.getElementById('total-days-year-stat');
        
        // Goal elements
        const goalInput = document.getElementById('goal-input');
        const goalDateInput = document.getElementById('goal-date-input');
        const progressBar = document.getElementById('progress-bar');
        const progressText = document.getElementById('progress-text');
        const goalDate = document.getElementById('goal-date');

        // Calendar elements
        const calendarMainMonthYear = document.getElementById('calendar-main-month-year');
        const prevMonthBtn = document.getElementById('prev-month-btn');
        const nextMonthBtn = document.getElementById('next-month-btn');
        const threeMonthView = document.getElementById('three-month-view');

        // Achievements elements
        const myAchievementsGrid = document.getElementById('my-achievements-grid');
        const availableBadgesGrid = document.getElementById('available-badges-grid');

        // Journal elements
        const journalForm = document.getElementById('journal-form');
        const journalInput = document.getElementById('journal-input');
        const journalEntriesContainer = document.getElementById('journal-entries-container');
        const journalSearchInput = document.getElementById('journal-search-input');
        const journalFilterStartDate = document.getElementById('journal-filter-start-date');
        const journalFilterEndDate = document.getElementById('journal-filter-end-date');
        const journalFilterClearBtn = document.getElementById('journal-filter-clear-btn');

        // NEW: Profile Dropdown elements
        const profileBtn = document.getElementById('profile-btn');
        const profileDropdown = document.getElementById('profile-dropdown');
        const userProfileDisplay = document.getElementById('user-profile-display');
        const publicProfileToggle = document.getElementById('public-profile-toggle');
        const publicLinkContainer = document.getElementById('public-link-container');
        const publicLinkDisplay = document.getElementById('public-link-display');
        const refreshPublicDataBtn = document.getElementById('refresh-public-data-btn');
        
        // NEW: Username change elements
        const newUsernameInput = document.getElementById('new-username-input');
        const saveUsernameBtn = document.getElementById('save-username-btn');
        const usernameStatus = document.getElementById('username-status');


        // NEW: Journal Modal elements
        const journalModal = document.getElementById('journal-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalBody = document.getElementById('modal-body');
        const modalCloseBtn = document.getElementById('modal-close-btn');
        
        // NEW: Chart, Loading, and Public View containers
        const streakChartContainer = document.getElementById('streak-chart-container');
        const loadingContainer = document.getElementById('loading-container');
        const publicViewContainer = document.getElementById('public-view-container');
        
        let isSignupMode = false;
        let durationIntervals = {};
        let userLogs = [];
        let allJournalEntries = []; // Holds all journal entries for client-side filtering
        let sortState = {
            key: 'startDate',
            direction: 'desc'
        };
        let visibleLogEntriesCount = 5;
        let ongoingStreakInterval = null;
        let currentEditingLogId = null;
        let displayedDate = new Date(); // For 3-month calendar, represents the MIDDLE month
        let userData = {}; // To store user doc data like username, last check-in
        let mainAppListenersAdded = false; // Flag to ensure listeners are only added once

        // Helper function to format date
        function formatDate(dateString) {
            if (!dateString) return '';
            const [year, month, day] = dateString.split('-').map(Number);
            const date = new Date(year, month - 1, day);
            const options = { year: 'numeric', month: 'long', day: 'numeric' };
            return date.toLocaleDateString('en-US', options);
        }
        
        function formatFullDate(date) {
            const options = { year: 'numeric', month: 'long', day: 'numeric', hour: 'numeric', minute: 'numeric', second: 'numeric' };
            return date.toLocaleDateString('en-US', options);
        }

        // Function to calculate duration in minutes
        function calculateDurationInMinutes(startDate, endDate) {
            const start = new Date(startDate);
            const end = endDate ? new Date(endDate) : new Date();
            const diff = end - start;
            return Math.floor(diff / (1000 * 60));
        }

        // Function to calculate and format duration
        function calculateDuration(startDate, endDate) {
            const start = new Date(startDate);
            const end = endDate ? new Date(endDate) : new Date();
            const diff = end - start;

            const days = Math.floor(diff / (1000 * 60 * 60 * 24));
            const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));

            return { totalMilliseconds: diff, formatted: `${days}d ${hours}h ${minutes}m`, days: days, minutes: minutes, hours: hours };
        }

        // Function to update live duration
        function updateLiveDuration(docId, startDate) {
            if (durationIntervals[docId]) {
                clearInterval(durationIntervals[docId]);
            }
            const durationCell = document.querySelector(`tr[data-id="${docId}"] .duration-cell`);
            if (durationCell) {
                durationIntervals[docId] = setInterval(() => {
                    durationCell.textContent = calculateDuration(startDate, null).formatted;
                }, 60000); // Update every minute
            }
        }
        
        // Function to calculate total days in a streak for the current year
        function calculateTotalDaysThisYear() {
            const currentYear = new Date().getFullYear();
            let totalDays = 0;

            userLogs.forEach(doc => {
                const log = doc.data();
                const [s_year, s_month, s_day] = log.startDate.split('-').map(Number);
                const startDate = new Date(s_year, s_month - 1, s_day);

                let endDate;
                if (log.endDate) {
                    const [e_year, e_month, e_day] = log.endDate.split('-').map(Number);
                    endDate = new Date(e_year, e_month - 1, e_day);
                } else {
                    endDate = new Date();
                }

                if (startDate.getFullYear() > currentYear) return;

                const startOfYear = new Date(currentYear, 0, 1);
                const endOfYear = new Date(currentYear, 11, 31, 23, 59, 59);

                const streakStart = Math.max(startDate, startOfYear);
                const streakEnd = Math.min(endDate, endOfYear);
                
                if (streakEnd > streakStart) {
                    const diffTime = Math.abs(streakEnd - streakStart);
                    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                    totalDays += diffDays;
                }
            });
            return totalDays;
        }

        // Function to update goal progress bar
        function updateGoalProgress(goal) {
            const currentStreak = userLogs.find(doc => !doc.data().endDate);
            const currentDays = currentStreak ? calculateDuration(currentStreak.data().startDate, null).days : 0;
            const goalDays = goal || 0;

            if (!goalDays || goalDays <= 0) {
                progressBar.style.width = '0%';
                progressText.textContent = `0%`;
                goalDate.textContent = '';
                return;
            }

            const progressPercentage = Math.min((currentDays / goalDays) * 100, 100);
            progressBar.style.width = `${progressPercentage}%`;
            
            // Calculate and display projected goal date
            const remainingDays = Math.max(0, goalDays - currentDays);
            
            if (remainingDays > 0) {
                progressText.textContent = `${Math.round(progressPercentage)}% (${remainingDays} ${remainingDays === 1 ? 'day' : 'days'} remaining)`;
            } else {
                progressText.textContent = `${Math.round(progressPercentage)}% (Goal reached!)`;
            }

            const projectedDate = new Date();
            projectedDate.setDate(projectedDate.getDate() + remainingDays);

            const year = projectedDate.getFullYear();
            const month = String(projectedDate.getMonth() + 1).padStart(2, '0');
            const day = String(projectedDate.getDate()).padStart(2, '0');
            const formattedProjectedDate = `${year}-${month}-${day}`;

            goalDate.textContent = `Goal of ${goalDays} days reached on: ${formatDate(formattedProjectedDate)}`;
            if (progressPercentage >= 100) {
                goalDate.textContent = `Goal achieved!`;
            }
        }

        // Function to calculate and render stats
        function calculateStats() {
            let longestDurationMs = 0;
            let totalCompletedDurationMs = 0;
            let completedEntriesCount = 0;
            let ongoingEntry = null;

            userLogs.forEach(doc => {
                const log = doc.data();
                const duration = calculateDuration(log.startDate, log.endDate);
                if (log.endDate) {
                    totalCompletedDurationMs += duration.totalMilliseconds;
                    completedEntriesCount++;
                } else {
                    ongoingEntry = log;
                }
                
                if (duration.totalMilliseconds > longestDurationMs) {
                    longestDurationMs = duration.totalMilliseconds;
                }
            });

            // Update Longest Streak
            const longestDuration = calculateDuration(null, longestDurationMs);
            longestStreakStat.textContent = `${longestDuration.days} days`;
            
            // Update Average Duration
            if (completedEntriesCount > 0) {
                const avgMs = totalCompletedDurationMs / completedEntriesCount;
                const avgDuration = calculateDuration(null, avgMs);
                avgDurationStat.textContent = `${avgDuration.days}d ${avgDuration.hours}h`;
            } else {
                avgDurationStat.textContent = "0d 0h";
            }

            // Update Current Streak Duration
            if (ongoingEntry) {
                if (ongoingStreakInterval) clearInterval(ongoingStreakInterval);
                ongoingStreakInterval = setInterval(() => {
                    const currentDuration = calculateDuration(ongoingEntry.startDate, null);
                    currentStreakDurationStat.textContent = currentDuration.formatted;
                    updateGoalProgress(parseInt(goalInput.value, 10)); // Update progress bar with live duration
                }, 60000);
                
                const currentDuration = calculateDuration(ongoingEntry.startDate, null);
                currentStreakDurationStat.textContent = currentDuration.formatted;
            } else {
                if (ongoingStreakInterval) clearInterval(ongoingStreakInterval);
                currentStreakDurationStat.textContent = "0d 0h 0m";
            }
            
            // Update Total Days This Year
            totalDaysYearStat.textContent = `${calculateTotalDaysThisYear()} days`;
            
            updateGoalProgress(parseInt(goalInput.value, 10)); // Initial progress bar update
            renderThreeMonthCalendar();
            renderStreakChart();
            renderTodayCheckin();
        }

        // Display log entries
        function renderLogs() {
            logTableBody.innerHTML = '';
            Object.values(durationIntervals).forEach(clearInterval);
            durationIntervals = {};
            
            const sortedLogs = userLogs.slice().sort((a, b) => {
                const aData = a.data();
                const bData = b.data();
                let aVal, bVal;

                if (sortState.key === 'duration') {
                    aVal = calculateDurationInMinutes(aData.startDate, aData.endDate);
                    bVal = calculateDurationInMinutes(bData.startDate, bData.endDate);
                } else {
                    aVal = aData[sortState.key] ? new Date(aData[sortState.key]).getTime() : 0;
                    bVal = bData[sortState.key] ? new Date(bData[sortState.key]).getTime() : 0;
                }

                if (sortState.direction === 'asc') {
                    return aVal - bVal;
                } else {
                    return bVal - aVal;
                }
            });

            const visibleLogs = sortedLogs.slice(0, visibleLogEntriesCount);

            visibleLogs.forEach(doc => {
                const log = doc.data();
                const row = document.createElement('tr');
                row.dataset.id = doc.id;

                const startDateFormatted = formatDate(log.startDate);
                const endDateFormatted = log.endDate ? formatDate(log.endDate) : `<button class="end-streak-btn">End Streak</button>`;
                const duration = calculateDuration(log.startDate, log.endDate).formatted;
                
                if (doc.id === currentEditingLogId) {
                     const editInputHtml = `
                         <input type="date" value="${log.startDate}" data-field="startDate" class="edit-input" />
                     `;
                     const endDateInputHtml = log.endDate ?
                         `<input type="date" value="${log.endDate}" data-field="endDate" class="edit-input" />` :
                         `<input type="date" value="" data-field="endDate" class="edit-input" />`;
                     
                     row.innerHTML = `
                         <td class="start-date-cell" data-label="Start Date">${editInputHtml}</td>
                         <td class="end-date-cell" data-label="End Date">${endDateInputHtml}</td>
                         <td class="duration-cell" data-label="Duration">${duration}</td>
                         <td data-label="Actions" class="actions-cell">
                             <button class="save-btn">Save</button>
                             <button class="cancel-btn">Cancel</button>
                         </td>
                     `;
                } else {
                    row.innerHTML = `
                        <td class="start-date-cell" data-label="Start Date" data-date="${log.startDate}">${startDateFormatted}</td>
                        <td class="end-date-cell" data-label="End Date" data-date="${log.endDate}">${endDateFormatted}</td>
                        <td class="duration-cell" data-label="Duration">${duration}</td>
                        <td data-label="Actions" class="actions-cell">
                            <button class="edit-btn">Edit</button>
                            <button class="delete-btn">Delete</button>
                        </td>
                    `;
                }

                logTableBody.appendChild(row);

                if (!log.endDate) {
                    updateLiveDuration(doc.id, log.startDate);
                }
            });

            if (userLogs.length > visibleLogEntriesCount) {
                viewMoreContainer.classList.remove('hidden');
            } else {
                viewMoreContainer.classList.add('hidden');
            }

            tableHeaders.forEach(header => {
                const icon = header.querySelector('.sort-icon');
                if (header.dataset.sortKey === sortState.key) {
                    icon.textContent = sortState.direction === 'asc' ? '‚ñ≤' : '‚ñº';
                } else {
                    icon.textContent = '';
                }
            });
        }
        
        // Function to render achievements
        function renderAchievements() {
            myAchievementsGrid.innerHTML = '';
            availableBadgesGrid.innerHTML = '';
            
            const ongoingEntry = userLogs.find(doc => !doc.data().endDate);
            const currentStreakDays = ongoingEntry ? calculateDuration(ongoingEntry.data().startDate, null).days : 0;
            
            const achievements = [
                { name: "7-Day Streak", days: 7, icon: '‚≠ê' },
                { name: "2-Week Streak", days: 14, icon: 'üìÖ' },
                { name: "30-Day Streak", days: 30, icon: 'üèÜ' },
                { name: "90-Day Streak", days: 90, icon: 'üõ°Ô∏è' },
                { name: "100-Day Streak", days: 100, icon: 'üíØ' },
                { name: "One-Month Wonder", days: 30, icon: 'üåü' },
                { name: "Two-Month Trekker", days: 60, icon: 'üö∂‚Äç‚ôÇÔ∏è' },
                { name: "Three-Month Triumph", days: 90, icon: 'üéâ' },
                { name: "Four-Month Force", days: 120, icon: 'üí™' },
                { name: "Five-Month Fighter", days: 150, icon: 'ü•ä' },
                { name: "Six-Month Soarer", days: 180, icon: 'üïäÔ∏è' },
                { name: "Seven-Month Success", days: 210, icon: 'üéØ' },
                { name: "Eight-Month Effort", days: 240, icon: 'ü•á' },
                { name: "Nine-Month Ninja", days: 270, icon: 'ü•∑' },
                { name: "Ten-Month Titan", days: 300, icon: 'üëë' },
                { name: "Eleven-Month Emperor", days: 330, icon: 'üëë' },
                { name: "One-Year Victor", days: 365, icon: 'üèÖ' },
            ];
            
            achievements.sort((a, b) => a.days - b.days);

            let hasEarnedBadges = false;

            achievements.forEach(achievement => {
                const unlocked = currentStreakDays >= achievement.days;

                if (unlocked) {
                    hasEarnedBadges = true;
                    const myBadge = document.createElement('div');
                    myBadge.className = 'badge-card';
                    myBadge.innerHTML = `
                        <div class="badge-icon unlocked">${achievement.icon}</div>
                        <div class="badge-name">${achievement.name}</div>
                    `;
                    myAchievementsGrid.appendChild(myBadge);
                } else {
                    // Render in Available Badges section only if not unlocked
                    const availableBadge = document.createElement('div');
                    availableBadge.className = 'badge-card';
                    availableBadge.innerHTML = `
                        <div class="badge-icon">${achievement.icon}</div>
                        <div class="badge-name">${achievement.name}</div>
                    `;
                    availableBadgesGrid.appendChild(availableBadge);
                }
            });
            
            // If no badges have been earned, show a message
            if (!hasEarnedBadges) {
                myAchievementsGrid.innerHTML = '<p style="font-style: italic; color: #aaa; margin-top: 10px;">Keep going! You haven\'t earned any badges yet on this streak.</p>';
            }

            // Optional: If all badges are earned, show a message in available badges
            if (availableBadgesGrid.children.length === 0) {
                 availableBadgesGrid.innerHTML = '<p style="font-style: italic; color: #aaa; margin-top: 10px;">Congratulations! You have collected all available badges for this streak!</p>';
            }
        }
        
        // Renders the 3-Month calendar
        function renderThreeMonthCalendar(publicData = null) {
            const calendarEl = publicData ? document.getElementById('public-calendar-main-month-year') : calendarMainMonthYear;
            if (!calendarEl) return;

            // Set main header to middle month
            calendarEl.textContent = displayedDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });

            // Prepare data sets
            const today = new Date();
            const todayString = today.toISOString().split('T')[0];
            const goalDateString = publicData ? publicData.goalDate : goalDateInput.value;
            const activeDays = new Set(publicData ? publicData.activeDays : []);
            const endDays = new Set(publicData ? publicData.endDays : []);

            if (!publicData) {
                userLogs.forEach(doc => {
                    const log = doc.data();
                    const logStart = new Date(log.startDate + "T00:00:00");
                    const logEnd = log.endDate ? new Date(log.endDate + "T00:00:00") : new Date();

                    if (log.endDate) {
                        endDays.add(log.endDate);
                    }

                    for (let d = new Date(logStart); d <= logEnd; d.setDate(d.getDate() + 1)) {
                        activeDays.add(d.toISOString().split('T')[0]);
                    }
                });
            }
            
            const journalDays = publicData ? new Set() : new Set(allJournalEntries.map(doc => doc.data().date.toDate().toISOString().split('T')[0]));


            // Get the three months to display
            const monthsToRender = [-1, 0, 1].map(offset => {
                const d = new Date(displayedDate);
                d.setMonth(d.getMonth() + offset);
                return d;
            });

            monthsToRender.forEach((date, index) => {
                const prefix = publicData ? 'public-' : '';
                const calendarGrid = document.getElementById(`${prefix}calendar-grid-${index}`);
                const calendarDayNames = document.getElementById(`${prefix}calendar-day-names-${index}`);
                const calendarMonthYear = document.getElementById(`${prefix}calendar-month-year-${index}`);

                if(!calendarGrid) return;

                calendarGrid.innerHTML = '';
                calendarDayNames.innerHTML = '';
                
                const year = date.getFullYear();
                const month = date.getMonth();
                calendarMonthYear.textContent = date.toLocaleDateString('en-US', { month: 'long' });

                const daysInMonth = new Date(year, month + 1, 0).getDate();
                const firstDayOfMonth = new Date(year, month, 1).getDay();

                // Render day names
                const dayNames = ['S', 'M', 'T', 'W', 'T', 'F', 'S'];
                dayNames.forEach(name => {
                    const dayNameDiv = document.createElement('div');
                    dayNameDiv.className = 'calendar-day-name';
                    dayNameDiv.textContent = name;
                    calendarDayNames.appendChild(dayNameDiv);
                });
                
                // Add empty cells for padding
                for (let i = 0; i < firstDayOfMonth; i++) {
                    const emptyCell = document.createElement('div');
                    emptyCell.className = 'calendar-day empty';
                    calendarGrid.appendChild(emptyCell);
                }

                // Render day cells
                for (let day = 1; day <= daysInMonth; day++) {
                    const dayCell = document.createElement('div');
                    
                    const currentDate = new Date(year, month, day);
                    const dateString = currentDate.toISOString().split('T')[0];
                    dayCell.dataset.date = dateString;

                    dayCell.className = 'calendar-day';
                    dayCell.textContent = day;

                    if (activeDays.has(dateString)) dayCell.classList.add('active');
                    if (endDays.has(dateString)) dayCell.classList.add('end-day');
                    if (dateString === todayString) dayCell.classList.add('today');
                    
                    if (dateString === goalDateString) {
                        dayCell.classList.add('goal-day');
                        dayCell.textContent = day + ' üéØ';
                    }

                    if (journalDays.has(dateString)) {
                        dayCell.classList.add('has-journal');
                        const icon = document.createElement('span');
                        icon.className = 'journal-icon';
                        icon.textContent = 'üìù';
                        dayCell.appendChild(icon);
                    }
                    
                    calendarGrid.appendChild(dayCell);
                }
            });
        }

        // NEW: Renders the Today Check-in box
        function renderTodayCheckin() {
            const today = new Date().toISOString().split('T')[0];
            const lastCheckin = userData.lastCheckinDate;
            const ongoingStreak = userLogs.find(doc => !doc.data().endDate);

            let html = '';
            if (ongoingStreak) {
                if (lastCheckin === today) {
                    html = `<p>Great job today! See you tomorrow.</p>`;
                } else {
                    html = `<p>Did you maintain your streak today?</p><button id="today-checkin-btn">Yes, I did!</button>`;
                }
            } else {
                html = `<p>You don't have an active streak. Start one in the Logbook!</p>`;
            }
            todayCheckinContainer.innerHTML = html;

            const checkinBtn = document.getElementById('today-checkin-btn');
            if (checkinBtn) {
                checkinBtn.addEventListener('click', async () => {
                    const user = auth.currentUser;
                    if (user) {
                        await db.collection('users').doc(user.uid).set({ lastCheckinDate: today }, { merge: true });
                    }
                });
            }
        }
        
        // NEW: Renders the streak history bar chart
        function renderStreakChart() {
            streakChartContainer.innerHTML = '';
            const completedStreaks = userLogs
                .filter(doc => doc.data().endDate)
                .map(doc => {
                    const data = doc.data();
                    return { ...data, duration: calculateDuration(data.startDate, data.endDate).days };
                })
                .sort((a,b) => new Date(a.startDate) - new Date(b.startDate));
            
            const recentStreaks = completedStreaks.slice(-10); // Get last 10
            
            if (recentStreaks.length === 0) {
                streakChartContainer.innerHTML = `<p style="text-align:center; padding-top: 50px;">Complete some streaks to see your history here!</p>`;
                return;
            }

            const maxDuration = Math.max(...recentStreaks.map(s => s.duration), 1);
            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, "svg");
            
            const barWidth = 100 / (recentStreaks.length * 2);
            
            recentStreaks.forEach((streak, i) => {
                const barHeight = (streak.duration / maxDuration) * 90; // 90% of svg height
                const x = (i * 2 + 0.5) * barWidth;

                const rect = document.createElementNS(svgNS, "rect");
                rect.setAttribute('x', `${x}%`);
                rect.setAttribute('y', `${100 - barHeight}%`);
                rect.setAttribute('width', `${barWidth}%`);
                rect.setAttribute('height', `${barHeight}%`);
                rect.setAttribute('class', 'chart-bar');
                
                const text = document.createElementNS(svgNS, "text");
                text.setAttribute('x', `${x + barWidth / 2}%`);
                text.setAttribute('y', `${98 - barHeight}%`);
                text.setAttribute('class', 'chart-label');
                text.textContent = `${streak.duration}d`;

                svg.appendChild(rect);
                svg.appendChild(text);
            });
            streakChartContainer.appendChild(svg);
        }

        // Applies filters and search to journal entries and renders them
        function applyAndRenderJournalFilters() {
            let filteredEntries = [...allJournalEntries];
            
            // Apply search filter
            const searchTerm = journalSearchInput.value.toLowerCase();
            if (searchTerm) {
                filteredEntries = filteredEntries.filter(doc => doc.data().text.toLowerCase().includes(searchTerm));
            }

            // Apply date filters
            const startDate = journalFilterStartDate.value;
            const endDate = journalFilterEndDate.value;
            if (startDate) {
                const startDateTime = new Date(startDate).setHours(0, 0, 0, 0);
                filteredEntries = filteredEntries.filter(doc => doc.data().date.toDate().getTime() >= startDateTime);
            }
            if (endDate) {
                const endDateTime = new Date(endDate).setHours(23, 59, 59, 999);
                filteredEntries = filteredEntries.filter(doc => doc.data().date.toDate().getTime() <= endDateTime);
            }
            
            renderJournalEntries(filteredEntries);
        }

        // Renders a given array of journal entries to the DOM
        function renderJournalEntries(journalDocs) {
            journalEntriesContainer.innerHTML = '';
            if (journalDocs.length === 0) {
                journalEntriesContainer.innerHTML = '<p style="text-align: center; margin-top: 20px;">No entries match your search or filter.</p>';
                return;
            }

            journalDocs.forEach(doc => {
                const entry = doc.data();
                const entryDiv = document.createElement('div');
                entryDiv.className = 'journal-entry';
                entryDiv.dataset.id = doc.id;

                const entryDate = entry.date.toDate();
                
                entryDiv.innerHTML = `
                    <div class="journal-entry-date">${formatFullDate(entryDate)}</div>
                    <div class="journal-entry-content">
                        <p class="journal-entry-text">${entry.text}</p>
                    </div>
                    <div class="journal-entry-actions">
                        <button class="edit-btn">Edit</button>
                        <button class="delete-btn">Delete</button>
                    </div>
                `;
                journalEntriesContainer.appendChild(entryDiv);
            });
        }
        
        // Export to CSV function
        function exportToCsv() {
            if (userLogs.length === 0) {
                console.log("No data to export.");
                return;
            }

            let csvContent = "data:text/csv;charset=utf-8,";
            csvContent += "Start Date,End Date,Duration\n";

            userLogs.forEach(doc => {
                const log = doc.data();
                const startDate = log.startDate || '';
                const endDate = log.endDate || '';
                const duration = calculateDuration(log.startDate, log.endDate).formatted || '';
                csvContent += `${startDate},${endDate},${duration}\n`;
            });

            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "streaker_data.csv");
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        // NEW: Updates the public profile data in Firestore
        async function updatePublicData(user) {
            if (!user || !userData.username) {
                alert('Cannot update public data. User or username is missing.');
                return;
            };

            // FIX: Re-fetch the latest logs directly to ensure data is not stale.
            const logsSnapshot = await db.collection('users').doc(user.uid).collection('logs').get();
            const currentLogs = logsSnapshot.docs;
            
            // 1. Gather all "safe" data
            const ongoingEntry = currentLogs.find(doc => !doc.data().endDate);
            const currentStreakStartDate = ongoingEntry ? ongoingEntry.data().startDate : null;
            const currentStreakDays = ongoingEntry ? calculateDuration(ongoingEntry.data().startDate, null).days : 0;

            let longestDurationMs = 0;
            currentLogs.forEach(doc => {
                const duration = calculateDuration(doc.data().startDate, doc.data().endDate);
                if (duration.totalMilliseconds > longestDurationMs) {
                    longestDurationMs = duration.totalMilliseconds;
                }
            });
            const longestStreakDays = calculateDuration(null, longestDurationMs).days;

            const activeDays = new Set();
            const endDays = new Set();
            currentLogs.forEach(doc => {
                const log = doc.data();
                const logStart = new Date(log.startDate + "T00:00:00");
                const logEnd = log.endDate ? new Date(log.endDate + "T00:00:00") : new Date();
                if(log.endDate) endDays.add(log.endDate);
                for (let d = new Date(logStart); d <= logEnd; d.setDate(d.getDate() + 1)) {
                    activeDays.add(d.toISOString().split('T')[0]);
                }
            });

            const achievementsConfig = [
                { name: "7-Day Streak", days: 7, icon: '‚≠ê' },
                { name: "2-Week Streak", days: 14, icon: 'üìÖ' },
                { name: "30-Day Streak", days: 30, icon: 'üèÜ' },
                { name: "90-Day Streak", days: 90, icon: 'üõ°Ô∏è' },
                { name: "100-Day Streak", days: 100, icon: 'üíØ' },
                { name: "One-Month Wonder", days: 30, icon: 'üåü' },
                { name: "Two-Month Trekker", days: 60, icon: 'üö∂‚Äç‚ôÇÔ∏è' },
                { name: "Three-Month Triumph", days: 90, icon: 'üéâ' },
                { name: "Four-Month Force", days: 120, icon: 'üí™' },
                { name: "Five-Month Fighter", days: 150, icon: 'ü•ä' },
                { name: "Six-Month Soarer", days: 180, icon: 'üïäÔ∏è' },
                { name: "Seven-Month Success", days: 210, icon: 'üéØ' },
                { name: "Eight-Month Effort", days: 240, icon: 'ü•á' },
                { name: "Nine-Month Ninja", days: 270, icon: 'ü•∑' },
                { name: "Ten-Month Titan", days: 300, icon: 'üëë' },
                { name: "Eleven-Month Emperor", days: 330, icon: 'üëë' },
                { name: "One-Year Victor", days: 365, icon: 'üèÖ' },
            ];

            const unlockedAchievements = achievementsConfig
                .filter(achievement => currentStreakDays >= achievement.days)
                .map(({ name, icon }) => ({ name, icon }));


            const publicData = {
                displayName: userData.username, // Use the stored username
                currentStreakStartDate,
                longestStreakDays,
                goalDate: goalDateInput.value || null,
                activeDays: Array.from(activeDays),
                endDays: Array.from(endDays),
                unlockedAchievements,
                lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
            };

            // 2. Write to the publicProfiles collection
            try {
                await db.collection('publicProfiles').doc(user.uid).set(publicData);
                alert('Your public profile has been updated!'); // Using alert for simplicity, could be a custom modal
            } catch (error) {
                console.error("Error updating public profile:", error);
                alert('Could not update public profile. Check console for errors.');
            }
        }
        
        // NEW: Handle Username Update
        async function handleUpdateUsername() {
            const user = auth.currentUser;
            if (!user || !userData) return;

            const newUsername = newUsernameInput.value.trim();
            const oldUsername = userData.username;
            usernameStatus.textContent = ''; // Clear previous messages

            // --- Validation ---
            if (!newUsername) {
                usernameStatus.textContent = "Username cannot be empty.";
                return;
            }
            if (oldUsername && newUsername.toLowerCase() === oldUsername.toLowerCase()) {
                usernameStatus.textContent = "This is your current username.";
                return;
            }
            if (newUsername.length < 3 || newUsername.length > 15 || /\s/.test(newUsername)) {
                usernameStatus.textContent = "Must be 3-15 characters, no spaces.";
                return;
            }
            
            const newUsernameLower = newUsername.toLowerCase();

            // --- Firestore Transaction ---
            try {
                await db.runTransaction(async (transaction) => {
                    const newUsernameRef = db.collection('usernames').doc(newUsernameLower);
                    const newUsernameDoc = await transaction.get(newUsernameRef);

                    if (newUsernameDoc.exists) {
                        throw "This username is already taken.";
                    }
                    
                    const userRef = db.collection('users').doc(user.uid);

                    // If an old username exists, we need to delete its unique entry.
                    if (oldUsername) {
                        const oldUsernameLower = oldUsername.toLowerCase();
                        const oldUsernameRef = db.collection('usernames').doc(oldUsernameLower);
                        transaction.delete(oldUsernameRef);
                    }

                    // Perform the writes
                    transaction.set(newUsernameRef, { uid: user.uid });
                    transaction.update(userRef, { username: newUsername });
                });
                
                usernameStatus.style.color = '#27ff47';
                usernameStatus.textContent = "Username updated successfully!";
                newUsernameInput.value = '';

                // The onSnapshot listener on the user's document will automatically
                // update the UI and refresh public data if the profile is public.

            } catch (error) {
                console.error("Error updating username: ", error);
                usernameStatus.style.color = '#ff0000';
                usernameStatus.textContent = typeof error === 'string' ? error : "An error occurred.";
            } finally {
                 setTimeout(() => usernameStatus.textContent = '', 3000); // Clear status after 3 seconds
            }
        }


        // --- NEW AUTH UI LOGIC ---
        function setAuthMode(isSignup) {
            isSignupMode = isSignup;
            authError.textContent = '';
            if (isSignup) {
                usernameInput.parentElement.classList.remove('hidden');
                mainAuthBtn.textContent = 'Create Account';
                toggleAuthModeBtn.textContent = 'Back to Log In';
                passwordInput.setAttribute('autocomplete', 'new-password');
            } else {
                usernameInput.parentElement.classList.add('hidden');
                mainAuthBtn.textContent = 'Log In';
                toggleAuthModeBtn.textContent = 'Sign Up';
                passwordInput.setAttribute('autocomplete', 'current-password');
            }
        }
        
        toggleAuthModeBtn.addEventListener('click', () => setAuthMode(!isSignupMode));

        // Event listener for login, signup form submission
        authForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const email = emailInput.value;
            const password = passwordInput.value;
            const username = usernameInput.value.trim();

            if (isSignupMode) {
                // --- SIGNUP LOGIC ---
                if (!username) {
                    authError.textContent = "Please enter a username.";
                    return;
                }
                 // Basic username validation (e.g., length, no spaces)
                if (username.length < 3 || username.length > 15 || /\s/.test(username)) {
                    authError.textContent = "Username must be 3-15 characters with no spaces.";
                    return;
                }

                try {
                    // 1. Check if username is unique
                    const usernameDoc = await db.collection('usernames').doc(username.toLowerCase()).get();
                    if (usernameDoc.exists) {
                        authError.textContent = "This username is already taken.";
                        return;
                    }

                    // 2. Create the user in Firebase Auth
                    const userCredential = await auth.createUserWithEmailAndPassword(email, password);
                    const user = userCredential.user;

                    // NEW: Generate stable public ID
                    const publicId = await generateUniquePublicId(); 

                    // 3. Create user documents in Firestore within a batch for atomicity
                    const batch = db.batch();
                    
                    const userRef = db.collection('users').doc(user.uid);
                    batch.set(userRef, {
                        username: username,
                        email: user.email,
                        publicId: publicId, // Save the public ID
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });

                    const usernameRef = db.collection('usernames').doc(username.toLowerCase());
                    batch.set(usernameRef, { uid: user.uid });

                    const publicIdRef = db.collection('publicIds').doc(publicId); // Create the lookup doc
                    batch.set(publicIdRef, { uid: user.uid });

                    await batch.commit();
                    
                    // No need to call initializeAppForUser here, onAuthStateChanged will handle it.

                } catch (error) {
                    authError.textContent = error.message;
                }

            } else {
                // --- LOGIN LOGIC ---
                try {
                    await auth.signInWithEmailAndPassword(email, password);
                    // onAuthStateChanged will handle the UI transition
                } catch (error) {
                    authError.textContent = error.message;
                }
            }
        });

        exportBtn.addEventListener('click', exportToCsv);
        
        // Tab functionality
        function setActiveTab(activeTab) {
            [dashboardContainer, logbookContainer, achievementsContainer, journalContainer, aboutContainer].forEach(c => c.classList.add('hidden'));
            [dashboardTabBtn, logbookTabBtn, achievementsTabBtn, journalTabBtn, aboutTabBtn].forEach(b => b.classList.remove('active'));

            if (activeTab === 'dashboard') {
                dashboardContainer.classList.remove('hidden');
                dashboardTabBtn.classList.add('active');
            } else if (activeTab === 'logbook') {
                logbookContainer.classList.remove('hidden');
                logbookTabBtn.classList.add('active');
            } else if (activeTab === 'achievements') {
                achievementsContainer.classList.remove('hidden');
                achievementsTabBtn.classList.add('active');
                renderAchievements();
            } else if (activeTab === 'journal') {
                journalContainer.classList.remove('hidden');
                journalTabBtn.classList.add('active');
            } else if (activeTab === 'about') {
                aboutContainer.classList.remove('hidden');
                aboutTabBtn.classList.add('active');
            }
        }
        
        // Add sorting event listeners to table headers
        function addMainAppEventListeners() {
            if (mainAppListenersAdded) return;

            // --- TAB BUTTON LISTENERS ---
            dashboardTabBtn.addEventListener('click', () => setActiveTab('dashboard'));
            logbookTabBtn.addEventListener('click', () => setActiveTab('logbook'));
            achievementsTabBtn.addEventListener('click', () => setActiveTab('achievements'));
            journalTabBtn.addEventListener('click', () => setActiveTab('journal'));
            aboutTabBtn.addEventListener('click', () => setActiveTab('about'));
            
            // NEW: Logout and Profile Dropdown listeners
            newLogoutBtn.addEventListener('click', () => {
                auth.signOut().then(() => {
                    window.location.reload();
                });
            });

            profileBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                // Clear any old status messages when opening
                usernameStatus.textContent = '';
                newUsernameInput.value = '';
                profileDropdown.classList.toggle('hidden');
            });

            // NEW: Public sharing listeners
            publicProfileToggle.addEventListener('change', async (e) => {
                const isPublic = e.target.checked;
                const user = auth.currentUser;
                if (!user) return;
                
                await db.collection('users').doc(user.uid).set({ isPublic }, { merge: true });
                publicLinkContainer.classList.toggle('hidden', !isPublic);
                
                if (isPublic) {
                    // **FIX**: Ensure the publicId lookup document exists when a user goes public.
                    // This is critical for existing users who didn't have one created on signup.
                    if (userData && userData.publicId) {
                        try {
                            const publicIdRef = db.collection('publicIds').doc(userData.publicId);
                            const publicIdDoc = await publicIdRef.get();
                            if (!publicIdDoc.exists) {
                                // Create the lookup document if it's missing.
                                await publicIdRef.set({ uid: user.uid });
                            }
                            const publicLink = `${window.location.origin}${window.location.pathname}?id=${userData.publicId}`;
                            publicLinkDisplay.value = publicLink;
                        } catch (error) {
                            console.error("Error ensuring publicId lookup document exists:", error);
                            publicLinkDisplay.value = "Error creating link.";
                        }
                    } else {
                         // It might take a moment for the backfill to run, show a temp message.
                        publicLinkDisplay.value = "Generating link..."; 
                    }
                }
            });
            
            refreshPublicDataBtn.addEventListener('click', () => {
                updatePublicData(auth.currentUser);
            });
            
            // NEW: Username change listener
            saveUsernameBtn.addEventListener('click', handleUpdateUsername);


            window.addEventListener('click', (e) => {
                if (!profileDropdown.classList.contains('hidden') && !profileDropdown.contains(e.target) && e.target !== profileBtn) {
                    profileDropdown.classList.add('hidden');
                }
            });


            tableHeaders.forEach(header => {
                header.addEventListener('click', () => {
                    const key = header.dataset.sortKey;
                    if (sortState.key === key) {
                        sortState.direction = sortState.direction === 'asc' ? 'desc' : 'asc';
                    } else {
                        sortState.key = key;
                        sortState.direction = 'asc';
                    }
                    renderLogs();
                });
            });

            // Event listener for the "View More" button
            viewMoreBtn.addEventListener('click', () => {
                visibleLogEntriesCount += 10;
                renderLogs();
            });
            
            // Event listeners for goal inputs
            goalInput.addEventListener('input', async (e) => {
                const goalDays = parseInt(e.target.value, 10);
                const user = auth.currentUser;
                if (!user) return;

                if (!isNaN(goalDays) && goalDays > 0) {
                     await db.collection('users').doc(user.uid).set({ goal: goalDays }, { merge: true });
                } else {
                    await db.collection('users').doc(user.uid).set({ goal: null }, { merge: true });
                }
            });

            goalDateInput.addEventListener('input', async (e) => {
                const targetDateStr = e.target.value;
                const user = auth.currentUser;
                if (!user || !targetDateStr) return;
                
                const [year, month, day] = targetDateStr.split('-').map(Number);
                const targetDate = new Date(year, month - 1, day);
                
                const today = new Date();
                targetDate.setHours(0, 0, 0, 0);
                today.setHours(0, 0, 0, 0);

                if (targetDate >= today) {
                    const timeDiff = targetDate.getTime() - today.getTime();
                    const daysFromNow = Math.round(timeDiff / (1000 * 60 * 60 * 24));

                    const currentStreak = userLogs.find(doc => !doc.data().endDate);
                    const currentDays = currentStreak ? calculateDuration(currentStreak.data().startDate, null).days : 0;
                    
                    const totalGoalDays = currentDays + daysFromNow;

                    if (totalGoalDays > 0) {
                        await db.collection('users').doc(user.uid).set({ goal: totalGoalDays }, { merge: true });
                    }
                }
            });

            // Calendar navigation
            prevMonthBtn.addEventListener('click', () => {
                displayedDate.setMonth(displayedDate.getMonth() - 1);
                renderThreeMonthCalendar();
            });
            nextMonthBtn.addEventListener('click', () => {
                displayedDate.setMonth(displayedDate.getMonth() + 1);
                renderThreeMonthCalendar();
            });

            // Journal search and filter listeners
            journalSearchInput.addEventListener('input', applyAndRenderJournalFilters);
            journalFilterStartDate.addEventListener('change', applyAndRenderJournalFilters);
            journalFilterEndDate.addEventListener('change', applyAndRenderJournalFilters);
            journalFilterClearBtn.addEventListener('click', () => {
                journalSearchInput.value = '';
                journalFilterStartDate.value = '';
                journalFilterEndDate.value = '';
                applyAndRenderJournalFilters();
            });
            
            // NEW: Interactive Calendar listener
            threeMonthView.addEventListener('click', (e) => {
                const dayCell = e.target.closest('.calendar-day.has-journal');
                if (dayCell) {
                    const date = dayCell.dataset.date;
                    const entriesForDay = allJournalEntries.filter(doc => doc.data().date.toDate().toISOString().split('T')[0] === date);
                    
                    modalTitle.textContent = `Journal Entries for ${formatDate(date)}`;
                    modalBody.innerHTML = '';

                    if (entriesForDay.length > 0) {
                        entriesForDay.forEach(doc => {
                            const entry = doc.data();
                            const entryDiv = document.createElement('div');
                            entryDiv.className = 'journal-entry';
                            entryDiv.innerHTML = `<p>${entry.text}</p>`;
                            modalBody.appendChild(entryDiv);
                        });
                    } else {
                        modalBody.innerHTML = '<p>No journal entries for this day.</p>';
                    }

                    journalModal.style.display = 'flex';
                }
            });


            // NEW: Modal close listeners
            modalCloseBtn.addEventListener('click', () => journalModal.style.display = 'none');
            journalModal.addEventListener('click', (e) => {
                if (e.target === journalModal) {
                    journalModal.style.display = 'none';
                }
            });

            // Add new log entry
            entryForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const startDate = startDateInput.value;
                const endDate = endDateInput.value;
                const user = auth.currentUser;
                
                const ongoingEntries = userLogs.filter(doc => !doc.data().endDate);
                if (ongoingEntries.length > 0 && !endDate) {
                    authError.textContent = "You can only have one ongoing streak at a time.";
                    return;
                }

                if (user && startDate) {
                    await db.collection('users').doc(user.uid).collection('logs').add({
                        startDate,
                        endDate: endDate || null,
                    });
                    startDateInput.value = '';
                    endDateInput.value = '';
                    authError.textContent = '';
                }
            });

            // Add new journal entry
            journalForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const text = journalInput.value.trim();
                const user = auth.currentUser;

                if (user && text) {
                    await db.collection('users').doc(user.uid).collection('journal').add({
                        text,
                        date: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    journalInput.value = '';
                }
            });
            
            // Handle in-place editing and deletion for logbook
            logTableBody.addEventListener('click', async (e) => {
                const user = auth.currentUser;
                if (!user) return;
                const row = e.target.closest('tr');
                if (!row) return;
                const docId = row.dataset.id;

                if (e.target.classList.contains('delete-btn')) {
                    await db.collection('users').doc(user.uid).collection('logs').doc(docId).delete();
                }

                if (e.target.classList.contains('edit-btn')) {
                    currentEditingLogId = docId;
                    renderLogs();
                }

                if (e.target.classList.contains('save-btn')) {
                    const newStartDate = row.querySelector('td.start-date-cell input').value;
                    const newEndDate = row.querySelector('td.end-date-cell input').value;
                    
                    if (newStartDate) {
                        await db.collection('users').doc(user.uid).collection('logs').doc(docId).update({
                            startDate: newStartDate,
                            endDate: newEndDate || null
                        });
                    }
                    currentEditingLogId = null;
                }

                if (e.target.classList.contains('cancel-btn')) {
                    currentEditingLogId = null;
                    renderLogs();
                }

                if (e.target.classList.contains('end-streak-btn')) {
                    const currentDate = new Date().toISOString().split('T')[0];
                    await db.collection('users').doc(user.uid).collection('logs').doc(docId).update({
                        endDate: currentDate
                    });
                }
            });

            // Handle in-place editing and deletion for journal
            journalEntriesContainer.addEventListener('click', async (e) => {
                const user = auth.currentUser;
                if (!user) return;

                const entryDiv = e.target.closest('.journal-entry');
                if (!entryDiv) return;
                const docId = entryDiv.dataset.id;
                
                if (e.target.classList.contains('delete-btn')) {
                    await db.collection('users').doc(user.uid).collection('journal').doc(docId).delete();
                }

                if (e.target.classList.contains('edit-btn')) {
                    const contentDiv = entryDiv.querySelector('.journal-entry-content');
                    const currentText = contentDiv.querySelector('p').textContent;

                    contentDiv.innerHTML = `
                        <textarea class="journal-edit-area" style="width: 100%; min-height: 100px;">${currentText}</textarea>
                        <button class="save-btn">Save</button>
                    `;
                }

                if (e.target.classList.contains('save-btn')) {
                    const newText = entryDiv.querySelector('.journal-edit-area').value.trim();
                    if (newText) {
                        await db.collection('users').doc(user.uid).collection('journal').doc(docId).update({
                            text: newText
                        });
                    }
                }
            });
            
            mainAppListenersAdded = true;
        }

        // NEW: Helper to generate a unique public ID
        async function generateUniquePublicId() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            let publicId = '';
            let isUnique = false;
            while (!isUnique) {
                publicId = '';
                for (let i = 0; i < 7; i++) { // 7 characters should be enough
                    publicId += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                const docRef = db.collection('publicIds').doc(publicId);
                const docSnap = await docRef.get();
                if (!docSnap.exists) {
                    isUnique = true;
                }
            }
            return publicId;
        }


        function initializeAppForUser(user) {
            authContainer.classList.add('hidden');
            mainAppContainer.classList.remove('hidden');
            authError.textContent = '';
            
            addMainAppEventListeners();

            // Listen to Firestore for log updates
            db.collection('users').doc(user.uid).collection('logs')
                .orderBy('startDate', 'desc')
                .onSnapshot(snapshot => {
                    userLogs = snapshot.docs;
                    visibleLogEntriesCount = 5;
                    renderLogs();
                    calculateStats();
                    renderAchievements();
                });
            
            // Listen to Firestore for journal updates
            db.collection('users').doc(user.uid).collection('journal')
                .orderBy('date', 'desc')
                .onSnapshot(snapshot => {
                    allJournalEntries = snapshot.docs;
                    applyAndRenderJournalFilters(); // Apply any existing filters
                    renderThreeMonthCalendar(); // Re-render calendar to show journal indicators
                });

            // Listen to the user's document for username, goal and checkin updates
            db.collection('users').doc(user.uid)
                .onSnapshot(async (doc) => { // Make async for backfill
                    if (doc.exists) {
                        userData = doc.data();
                        
                        // NEW: Backfill publicId for existing users
                        if (!userData.publicId) {
                            // This existing user needs a publicId. Security rules seem to prevent
                            // existing users from writing to the global 'publicIds' collection,
                            // which causes a permissions error.
                            // To fix this, we will only generate the ID and save it to the user's
                            // own document, which they have permission to update.
                            // This prevents the app from crashing.
                            try {
                                const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
                                let publicId = '';
                                for (let i = 0; i < 7; i++) {
                                    publicId += chars.charAt(Math.floor(Math.random() * chars.length));
                                }

                                const userRef = db.collection('users').doc(user.uid);
                                await userRef.update({ publicId: publicId });
                                // The onSnapshot listener will fire again with the updated data.
                            } catch (e) {
                                // Log error if even this fails, but it should be permitted.
                                console.error("Critical error during publicId backfill:", e);
                            }
                        }
                        
                        // Set username in profile dropdown
                        userProfileDisplay.textContent = userData.username || user.email;


                        // Set Public Profile Toggle state
                        const isPublic = !!userData.isPublic;
                        publicProfileToggle.checked = isPublic;
                        publicLinkContainer.classList.toggle('hidden', !isPublic);
                        if(isPublic) {
                             if (userData && userData.publicId) {
                                const publicLink = `${window.location.origin}${window.location.pathname}?id=${userData.publicId}`;
                                publicLinkDisplay.value = publicLink;
                             } else {
                                publicLinkDisplay.value = "Generating public link...";
                             }
                        }


                        if (userData && userData.goal) {
                            const goalDays = userData.goal;
                            goalInput.value = goalDays;

                            const currentStreak = userLogs.find(logDoc => !logDoc.data().endDate);
                            const currentDays = currentStreak ? calculateDuration(currentStreak.data().startDate, null).days : 0;

                            if (goalDays > currentDays) {
                                const remainingDays = goalDays - currentDays;
                                const projectedDate = new Date();
                                projectedDate.setDate(projectedDate.getDate() + remainingDays);
                                
                                const year = projectedDate.getFullYear();
                                const month = String(projectedDate.getMonth() + 1).padStart(2, '0');
                                const day = String(projectedDate.getDate()).padStart(2, '0');
                                goalDateInput.value = `${year}-${month}-${day}`;
                            } else {
                                goalDateInput.value = ''; // Goal met or passed
                            }
                            updateGoalProgress(goalDays);
                        } else {
                            goalInput.value = '';
                            goalDateInput.value = '';
                            updateGoalProgress(0);
                        }
                    }
                    renderThreeMonthCalendar(); // Re-render calendar on goal change
                    renderTodayCheckin(); // Re-render checkin on user data change
                });
            
            setActiveTab('dashboard');
        }

        function showLoginScreen() {
            authContainer.classList.remove('hidden');
            mainAppContainer.classList.add('hidden');
            publicViewContainer.classList.add('hidden');
            journalModal.style.display = 'none'; 
            if(profileDropdown) profileDropdown.classList.add('hidden');
            Object.values(durationIntervals).forEach(clearInterval);
            durationIntervals = {};
            setAuthMode(false); // Default to login mode
        }

        // NEW: Renders the public-facing, read-only dashboard
        function renderPublicView(data) {
            // FIX: Calculate current streak duration on the fly from the start date.
            let currentStreakHTML = "N/A";
            if (data.currentStreakStartDate) {
                currentStreakHTML = calculateDuration(data.currentStreakStartDate, null).formatted;
            }

            const achievementsHTML = data.unlockedAchievements && data.unlockedAchievements.length > 0
                ? data.unlockedAchievements.map(ach => `
                    <div class="badge-card">
                        <div class="badge-icon unlocked">${ach.icon}</div>
                        <div class="badge-name">${ach.name}</div>
                    </div>
                `).join('')
                : '<p style="text-align:center; font-style: italic; color: #aaa; grid-column: 1 / -1;">No achievements earned on the current streak.</p>';

            publicViewContainer.innerHTML = `
                <div class="header">
                    <div class="logo-and-title">
                        <img src="https://raw.githubusercontent.com/rynwynk/streaker-app/main/logo%20only.png" alt="Streaker Logo" class="logo">
                        <div>
                            <h2>Streaker</h2>
                            <p class="subtitle">Tomorrow Never Cums</p>
                        </div>
                    </div>
                </div>
                <h2 class="stats-section-header" style="margin-top:0;">Public Profile for ${data.displayName || 'Anonymous User'}</h2>

                <div class="stats-grid">
                    <div class="stat-card">
                        <h3>Current Streak</h3>
                        <p id="public-current-streak">${currentStreakHTML}</p>
                    </div>
                    <div class="stat-card">
                        <h3>Longest Streak</h3>
                        <p>${data.longestStreakDays} days</p>
                    </div>
                </div>

                <h2 class="stats-section-header">Achievements</h2>
                <div class="achievements-grid">
                    ${achievementsHTML}
                </div>

                <h2 class="stats-section-header">Streak Calendar</h2>
                <div class="calendar-container">
                    <div class="calendar-header">
                        <span id="public-calendar-main-month-year"></span>
                    </div>
                    <div id="public-three-month-view" class="three-month-view">
                         <div class="single-month-container">
                             <h3 class="calendar-month-year" id="public-calendar-month-year-0"></h3>
                             <div class="calendar-grid" id="public-calendar-day-names-0"></div>
                             <div class="calendar-grid" id="public-calendar-grid-0"></div>
                         </div>
                        <div class="single-month-container">
                             <h3 class="calendar-month-year" id="public-calendar-month-year-1"></h3>
                             <div class="calendar-grid" id="public-calendar-day-names-1"></div>
                             <div class="calendar-grid" id="public-calendar-grid-1"></div>
                         </div>
                        <div class="single-month-container">
                             <h3 class="calendar-month-year" id="public-calendar-month-year-2"></h3>
                             <div class="calendar-grid" id="public-calendar-day-names-2"></div>
                             <div class="calendar-grid" id="public-calendar-grid-2"></div>
                         </div>
                    </div>
                </div>
            `;
            renderThreeMonthCalendar(data); // Render the calendar with public data

            // FIX: Add an interval to keep the public streak duration live.
            if (data.currentStreakStartDate) {
                setInterval(() => {
                    const el = document.getElementById('public-current-streak');
                    if(el) {
                        el.textContent = calculateDuration(data.currentStreakStartDate, null).formatted;
                    }
                }, 60000); // Update every minute
            }
        }


        // NEW: Top-level startup logic
        async function startApp() {
            const urlParams = new URLSearchParams(window.location.search);
            const publicId = urlParams.get('id'); // NEW: Check for stable ID
            const publicUsername = urlParams.get('u'); // Old username link for fallback
            const publicUserId = urlParams.get('user'); // Oldest user ID link for fallback

            if (publicId) {
                 // Public view mode by STABLE ID
                loadingContainer.classList.add('hidden');
                publicViewContainer.classList.remove('hidden');
                try {
                    const idDoc = await db.collection('publicIds').doc(publicId).get();
                    if (idDoc.exists) {
                        const uid = idDoc.data().uid;
                        const profileDoc = await db.collection('publicProfiles').doc(uid).get();
                        if (profileDoc.exists) {
                            renderPublicView(profileDoc.data());
                        } else {
                            publicViewContainer.innerHTML = '<p style="text-align:center;">This public profile does not exist or has been disabled.</p>';
                        }
                    } else {
                        publicViewContainer.innerHTML = '<p style="text-align:center;">Public profile not found.</p>';
                    }
                } catch (error) {
                    console.error("Error loading public profile by ID:", error);
                    publicViewContainer.innerHTML = '<p style="text-align:center;">Could not load public profile.</p>';
                }
            } else if (publicUsername) {
                // Public view mode by USERNAME (fallback for old links)
                loadingContainer.classList.add('hidden');
                publicViewContainer.classList.remove('hidden');
                try {
                    const usernameDoc = await db.collection('usernames').doc(publicUsername.toLowerCase()).get();
                    if (usernameDoc.exists) {
                        const uid = usernameDoc.data().uid;
                        const profileDoc = await db.collection('publicProfiles').doc(uid).get();
                        if (profileDoc.exists) {
                            renderPublicView(profileDoc.data());
                        } else {
                             publicViewContainer.innerHTML = '<p style="text-align:center;">This public profile does not exist or has been disabled.</p>';
                        }
                    } else {
                         publicViewContainer.innerHTML = '<p style="text-align:center;">Profile not found for this username.</p>';
                    }
                } catch (error) {
                    console.error("Error loading public profile by username:", error);
                    publicViewContainer.innerHTML = '<p style="text-align:center;">Could not load public profile.</p>';
                }

            } else if (publicUserId) {
                // Public view mode by USER ID (fallback for old links)
                loadingContainer.classList.add('hidden');
                publicViewContainer.classList.remove('hidden');
                try {
                    const doc = await db.collection('publicProfiles').doc(publicUserId).get();
                    if (doc.exists) {
                        renderPublicView(doc.data());
                    } else {
                        publicViewContainer.innerHTML = '<p style="text-align:center;">This public profile does not exist or has been disabled.</p>';
                    }
                } catch (error) {
                    console.error("Error loading public profile:", error);
                    publicViewContainer.innerHTML = '<p style="text-align:center;">Could not load public profile.</p>';
                }
            } else {
                // Normal authenticated user mode
                auth.onAuthStateChanged(user => {
                    loadingContainer.classList.add('hidden'); // Hide loading screen first

                    if (user) {
                        initializeAppForUser(user);
                    } else {
                        showLoginScreen();
                    }
                });
            }
        }
        
        startApp();
    </script>
</body>
</html>
